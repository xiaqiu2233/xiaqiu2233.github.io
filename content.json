[{"title":"设计模式","date":"2018-08-26T09:56:45.000Z","path":"2018/08/26/设计模式/","text":"1. 单例模式123456789101112131415class Singleton &#123; constructor(name) &#123; this.name = name this.instance = null &#125; getName() &#123; alert(this.name) &#125; static getInstance(name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name) &#125; return this.instance &#125;&#125; 2. 代理模式虚拟代理：使用proxySynchronousFile来收集一段时间内的请求，最后一次性发送给服务器。 12345678910111213141516171819// 将请求发送给服务器synchronousFile (id)&#123; console.log('开始同步文件，id为：'+id);&#125;//收集请求的代理并一次性发送var proxySynchronousFile=function()&#123; var cache=[]; var timer; return function(id)&#123; cache.push(id); if(timer) return; timer=setTimeout(function()&#123; synchronousFile(cache.join(',')); clearTimeout(timer); timer=null; cache.length=0; &#125;, 5000); &#125;&#125;; 缓存代理： 12345678910var createProxyFactory=function(fn)&#123; var cache=&#123;&#125;; return function () &#123; var args=Array.prototype.join.call(arguments, ','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = fn.apply(this, arguments) &#125;&#125; createProxyFactory是个代理工厂，可以为各种计算方法创建缓存代理。 3. 发布订阅模式Event类似一个中介者的身份，将订阅者和发布者联系起来。 123456789101112131415161718192021222324252627282930class Event&#123; constructor()&#123; this.clientList=&#123;&#125;; &#125; subscribe(key, cb) &#123; this.clientList[key] = this.clientList[key] || []; this.clientList[key].push(cb); &#125; trigger(key, data) &#123; if(!this.clientList[key] || this.clientList[key].length === 0) &#123; return false; &#125; this.clientList[key].forEach((cb) =&gt; &#123; cb.call(this, data); &#125;); &#125; unsubscribe(key, cb) &#123; if(key &amp;&amp; cb) &#123; var ins = this.clientList[key].findIndex((item =&gt; &#123; return Object.is(item, cb); &#125;)); if(ins===-1) return false; this.clientList[key].splice(ins, 1); &#125; else if(key) &#123; this.clientList[key].length = 0; &#125; else &#123; return false; &#125; &#125;&#125; 发布订阅模式不一定是先订阅后发布，也可以是先发布后被订阅，这种情况就需要一个存放离线事件（发布事件）的堆栈 4. 组合模式组合模式可以让我们使用树形方式创建对象结构，将相同的操作应用在组合对象和单个对象上。从而忽略组合对象和单个对象的差别，从而用一致的方式来处理它们。组合模式要求组合对象和叶对象拥有相同的接口，而且还需要对一组叶对象的操作具有一致性。并且需要叶节点对于组合节点是一对一的关系，如果映射关系复杂，就需要引入中介者模式来管理这些对象。可以运用职责链模式来提高组合性能。 5. 装饰者模式装饰者模式在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。它是继承关系的一个替代方案，在不改变接口的前提下，增强类的性能。装饰者模式经常会用在框架开发中，我们会希望框架中的函数提供的是一些稳定而方便移植的功能，那些个性化的功能可以在框架之外动态装饰上去。当不考虑向Function的prototype中添加函数时，我们在Function的prototype中添加before和after函数，这两个函数的功能是将原本函数包围一层，返回一个新的函数，这个新函数的作用是保持上下文不变的执行原有函数和先行或后行执行函数。这个先行函数和后行函数就是需要使用装饰器添加的功能，先行函数实在原函数执行前执行，后行函数是在原函数执行后执行。先来定义这两个函数： 123456789101112131415Function.prototype.before=function(beforeFn)&#123; var _self=this;//_self保存调用before的函数 return function ()&#123; beforeFn.apply(this, arguments); return _self.apply(this, arguments); // 返回原函数的执行结果 &#125;&#125;Function.prototype.after=function(afterFn)&#123; var _self=this;//_self保存调用before的函数 return function ()&#123; let ret = _self.apply(this, arguments); afterFn.apply(this, arguments); return ret; // 返回原函数的执行结果 &#125;&#125; 下面来举一个具体的例子来展示装饰器的功能，有一个button，点击button需要实现两个功能，一是打开模态框，二是写入日志，将写入日志以装饰器的模式来完成。 12345678910111213&lt;html&gt; &lt;button tag=\"login\" id=\"button\"&gt;&lt;/button&gt; &lt;script&gt; var showLogin = function()&#123; console.log( '打开模态框' ); &#125; var log = function()&#123; console.log( ' 写入日志: ' + this.getAttribute( 'tag' )); &#125; showLogin = showLogin.after( log ); // 在打开模态框后写入吗日志 document.getElementById( 'button' ).onclick = showLogin; &lt;/script&gt;&lt;/html&gt; 使用装饰器模式的场景有面向AOP编程 在es7中也有装饰器模式http://taobaofed.org/blog/2015/11/16/es7-decorator/","tags":[]},{"title":"localstorage、sessionstorage、indexedDB的特点和应用场景","date":"2018-08-26T08:29:02.000Z","path":"2018/08/26/localstorage、sessionstorage、indexedDB的特点和应用场景/","text":"对于本地存储空间，在各主流浏览器（包含PC、移动端）竟然惊人的一致，都是 5M 的数量级。当本地存储空间大于5M时，各浏览器都是抛出一个错误 QUOTA_EXCEEDED_ERR 。那么什么样的数据应该保存在本地存储中呢？有以下几个原则： 只保存重要页面的重要数据典型的，首页首屏对业务庞大的站点，这点尤其重要 极大提高用户体验的数据比如表单的状态，可以提交之前保存，当用户刷新页面时可以还原静态资源，比如 js 和 css 一个请求一个 key 值（一个 cgi 一个 key 值）避免请求链接加参数的 key (http://request-ajax.cgi[params])，这样必然让 key 值趋于冗余从而撑爆空间1. cookie cookie生成cookie是存在客户端，session存在服务器端。在cookie当用户第一次访问网页时，服务器会给客户端返回一个cookie，在cookie中保存着服务器端session文件的位置信息，用户第一次访问服务器，服务器就会为它创建一个session文件，并将session的标识保存在cookie中发给它。在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。 cookie访问和设置在 JavaScript 中可以通过 document.cookie 设置字段和进行访问。 cookie优点 Cookie的大小为4kb。cookie主要应用在保存用户身份信息。 2. localstorage localStorage介绍：和cookie很类似，但是localStorage的大小有5M；不需要被发送到服务端。还有一个区别localStorage存储的数据是永久性的，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。 localstorage特点：页面数据同步 好处localStorage 只能做为提升用户体验的手段，而不能成为客户端逻辑的可靠的、唯一的依赖。方便网页的加载，避免取回数据前页面一片空白，如果不需要最新数据也可以减少向服务端请求的次数，从而减少用户等待从服务器获取数据的时间；网络状态不佳时仍可以显示离线数据。 访问限制只有当前设定localstorage的域下才能访问； 单标签页：两个tab（相同域）之间不能互通； 刷新或新开 tab 是可以访问到的，关闭浏览器重新打开原先tab也可访问。 localStorage应用：存储一些需要刷新保存并且需要在页面关闭后仍然留下的信息。可以用于保存购物车中的内容；在之前项目中，用于保存上一次的用户浏览标签，并跳转到相应的路径下。 localstorage注意事项：因为性能问题，不能过于依赖 JSON.stringify。value 尽量使用 string。如果需要多次写入localstorage，尽量一次性写入。localstorage是同步执行，可能会阻塞UI 3. sessionstoragesessionStorage：sessionStorage的有效期仅存在于浏览器的标签页。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，如果同一标签页中包含多个元素，这两者之间也是可以共享sessionStorage的。sessionStorage的作用于不仅限定在文档源级别，甚至限定在窗口中。sessionStorage的有效期尽存在于浏览器的标签页。 访问限制只有当前设定sessionStorage的域下才能访问； 单标签页：两个tab（相同域）之间不能互通； 在新开的tab下或者关闭本tab之后再打开，也不能访问之前写下的sessionStorage； 刷新本tab可以访问。 应用场景存储一些当前页面刷新需要存储，且不需要在tab关闭时候留下的信息。可以用来检测用户是否是刷新进入的页面，如音乐播放器恢复播放进度条的功能。 非常适合单页应用程序，可以方便在各业务模块进行传值。 4. cookie和web storage的区别Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 5. IndexDBwebsql 像关系型数据库，使用 sql 语句进行操作。 indexdb 像 nosql，直接使用 js 方法操作数据。 访问：indexdb与 web storage 一致，均是在创建数据库的域名下才能访问。且不能指定访问域名。 存储时间：存储时间永久，除非用户清除数据，可以用作长效的存储。 大小限制：理论上讲，这种存储的方式是没有大小限制的。然而IndexDB的数据库超过50M的时候浏览器会弹出确认。基本上也相当于没有限制了。 性能测试：indexeddb查询少量数据花费差不多20MS左右。大量数据的情况下，相对耗时会变长一些，但是也就在30MS左右，也是相当给力了，10W数据+，毕竟nosql。 特点异步。它的数据不是保存在表中，而是保存在对象存储空间中。 创建对象存储空间时，需要定义一个键，然后就可以添加数据。 可以使用游标在对象存储空间中查询特定的对象。 而索引则是为了提高查询速度而基于特定的属性创建的。 说明：indexDB 目前兼容性还不是很好","tags":[]},{"title":"CSS备忘","date":"2018-08-25T02:22:16.000Z","path":"2018/08/25/CSS备忘/","text":"1. 选择器的特殊性如果一个元素有两个或多个冲突的属性声明，那么有最高特殊性的声明就会胜出。声明也分为重要声明（就是!important）和非重要声明。这两类声明解决冲突的规则入下： 对于重要声明就没有特殊性一说 非重要声明的解决冲突使用特殊性 重要声明与非重要声明发生冲突时，胜出的总是重要声明非重要声明的特殊性由选择器本身确定。特殊性值表述为4个部分，如0，0，0，0. 对于内联样式特殊性加1，0，0，0； 对于ID选择器特殊性加0，1，0，0； 对于类选择器、伪类选择器、属性选择器特殊性加0，0，1，0； 对于元素选择器和伪元素选择器特殊性加0，0，0，1； 对于通配选择器的特殊性加0，0，0，0；（这个和没有特殊性不一样）对于子元素从父元素继承来的值是没有特殊性的，因此通配选择器会覆盖继承来的值。如果特殊性相同的两个规则同时应用到同一个元素，则按照声明的顺序进行排序，一个声明在文档中越后出现，权重越大。导入样式表的出现顺序一般认为出现在主样式表的前面。以及按角色分为创作人员样式、读者样式和用户代理样式。其中用户代理样式的优先级最低。一般而言创作人员样式优先级最高，除了读者样式设置为!important的情况，这种情况就算是创作人员样式设置为!important都是比他弱的。层叠规则如下： 2. 继承css不可继承的属性有：大多数框模型属性（外边距、内边距、背景和边框）。css可继承的属性有：颜色，文字，字体间距行高对齐方式，和列表的样式可以继承所有元素可继承：visibility和cursor。内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。终端块状元素可继承：text-indent和text-align。列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 3. 选择器的解析方向从左到右，先拿到目标节点的描述，匹配到可能的节点后，查找父节点。而从右到左解析，先匹配上层元素，再一层层向下匹配，当匹配不到，需要回溯上一层重新匹配。结果显而易见了，众所周知，在 DOM 树中一个元素可能有若干子元素，如果每一个都去判断一下显然性能太差。而一个子元素只有一个父元素，所以找起来非常方便。所以从右向左方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。 4. 盒模型W3C标准盒模型和IE盒模型水平方向盒模型是由margin-left、border-left、padding-left、content、padding-right、border-right、margin-right组成。W3C标准盒模型width的宽度和高度分别是content的width和heightIE标准盒模型width的宽度和高度分别是content+padding+border的width和height使用box-sizing来切换盒模型。Box-sizing:border-box就是IE盒模型，box-sizing:content-box就是W3C盒模型。 块级元素和行内元素块级元素：div\\p\\form\\table \\header\\footer \\section\\h1-6行内元素：span\\i\\a\\input\\button\\label\\select 5. 颜色颜色有几种表示方法： RGBrgb有三原色，每种颜色的范围是0-255，百分比是0-100% 16进制将三个介于00-FF的十六进制连起来 6. 长度单位绝对长度：in、cm、mm、pt、pc相对长度单位：em、ex、rem、pxpx像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。em是相对长度单位。相对于当前对象内文本的字体尺寸。元素不同则em的值也不同。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)ex。相对于当前元素所用字体中小写x的高度。如果两段文本，font-size相同但是所用字体不同，则ex的值也可能不同。rem。相对于字体font-size的大小，1rem=font-size 7. 字体font-family：设置使用的字体类型。font-weight：字体加粗。normal、bold、lighter、100、200…font-size：百分比是相对于父元素的字体大小。font-size单位可以是所有的长度单位。font-style：italic（斜体）、oblique（倾斜）、normal、inheritfont的前三个值是font-style，font-weight,font-variant这三个值的顺序随意、后两个值font-size/line-height、font-family则一定要以这个顺序 8. 文本属性 text-indent作用：用于首行缩进,针对块级元素。值：length、百分数、inherit、number百分数：相对于缩进元素父元素的宽度。即如果对一个div设置了这个属性，则百分数是相对于div的父元素。继承：有 text-align作用：影响元素中文本行相互之间的对齐方式。值：left、center、right、justify、inherit。left、center、right导致文本的左中右对齐；justify是两端对齐。继承：有作用于：块级元素 line-height作用：文本行基线之间的距离，而不是字体的大小，，确定了将各个元素框的高度增加或减少多少值：normal、百分数、长度normal：字体的1.2倍百分数：相对于元素字体的大小number：是一个缩放因子，用于解决font-size如果是百分比或者em为单位，会相对父元素的font-size计算出line-height然后由子元素继承，子元素从父元素继承line-height时，继承自父元素的line-height和子元素自身的font-size不匹配。使用缩放因子，子元素就继承的是这个因子而不是计算值，因此子元素再用这个因子计算出line-height的值。应用：所有元素块级元素应用：line-height定义了元素中文本基线之间的最小距离。因为是最小，所以文本基线的距离可能会比line-height的值大替换元素应用：继承：有行间距：文本行之间超出字体大小的额外空间。line-height和font-size之差就是行间距文本行、内容区和行内框line-height的值定义行内框的大小；font-size定义内容区的大小；行内框-内容区的部分就是行间距；所有行内框的最高顶部和最低底部就是行框的范围。 vertical-align应用：行内元素和替换元素值：baseline（默认）、sub、sup、bottom、text-bottom、top、text-top、middle、百分数、数值baseline：一个元素的基线和父元素的基线对齐。如果是图像】输入框这一类的替换元素，则该元素的底部和父元素的基线对齐sub：使一个元素变成下标，该元素的基线（或是替换元素的底部）会低于父元素的基线，低多少由用户代理决定。sup和sub相反bottom：将元素行内框的底部和行框的底部对齐text-bottom：将元素行内框的底端和行内文本框的底部对齐middle：往往（但并不总是）应用于图片，middle将元素行内框的中点与父元素基线上的0.5ex对齐。百分数：将元素的基线（或替换元素的底边）相对于父元素基线升高或降低指定的量。这个百分数是相对于该元素line-height的百分数。总结：可以看到所有垂直对齐的元素都会影响行高。行框的描述是，高度要足以包含最高行内框的顶端和最低行内框的底端。数值：继承：无 word-spacing作用：增加或减少单词之间的间隔值：normal、inherit、数值应用：所有元素继承：有 letter-spacing作用：增加或减少字母之间的间隔值：normal、inherit、数值应用：所有元素继承：有 text-transform作用：处理文本大小写值：uppercase、lowercase、capitalize、none、inheritcapitalize：对每个单词首字母大写应用：所有元素继承：有 text-decoration作用：文本装饰值：none、underline、overline、line-through、blinkblink：文本闪烁应用：所有元素继承：无 text-shadow作用：文本阴影值：三个（color、length[左右偏移]、length[上下偏移]、length[阴影模糊半径]）应用：所有元素继承：无 white-space作用：影响用户代理对源文档中的空格、换行和tab字符的处理值：normal、nowrap、pre、pre-wrap、pre-line、inheritpre：会保留空格，不换行nowrap：不会保留空格，不换行pre-wrap：会保留空格，换行pre-line：不会保留空格，换行应用：所有元素继承：无 9. 基本视觉格式化margin-left、width、margin-right可以设置为auto。margin-left和width都为auto则margin-left是0，width尽可能大margin-left、width、margin-right都是auto，则margin-left和margin-right都是0，width尽可能大。margin、width、padding的百分数都是相比于父元素的width。边框没有百分数。不可替换块级元素和可替换块级元素的区别是：前者当width为auto时，宽度是内容的固有宽度。后者width为auto，宽度就是元素的实际宽度，比如一张图片的实际宽度在垂直方向，不可以通过设置margin-top margin-bottom的方式来 10. 居中 水平居中块级元素：设置width，margin-left和margin-right设置为auto。行内元素和块级元素：在父级元素上设置text-align:center设置flex布局，justify-content设置为center 垂直居中 行内元素：单行：可以用line-height，让line-height=父元素的高度多行：.father{ display: table-cell; width: 500px; vertical-align: middle; height: 500px;}.child{ white-space: wrap;} 行内元素和块级元素：可以使用absolute和translate。.father{ position: relative; height: 600px;}.child{ position: absolute; top: 50%; transform: translateY(-50%);}可以使用flex.father{ height: 600px; display: flex; align-items: center;} 垂直水平居中可以使用absolute和translate。可以使用flex 11. 定位根元素（html）的包含块由用户代理建立非根元素，position是relative或static的元素，其包含块是最近的块级框、表单元格或行内块祖先框非根元素，position是absolute的元素，包含块是最近的position值不为static的祖先元素left和right的百分比相对于包含块的宽度；top和bottom的百分比相对于包含块的高度 12. float浮动元素的包含块就是最近的块级祖先元素 12. padding和margin左右上下padding、左右上下margin的值如果是百分比，都是相对于父元素的宽度来计算的 13. 去除行内块元素的间隙 在父元素上设置font-size为0 在父元素上设置letter-spacing和word-spacing为-6左右 14. 两个垂直块元素边距塌陷的条件有： 这两个在同一个BFC中 这两个没有padding、border、内联元素分离它们 15. box-shadow三个（color、length[左右偏移]、length[上下偏移]、length[阴影模糊半径,值越大阴影越大，越模糊（可选）]、length[阴影半径,值越大阴影越大，不会模糊（可选）]、颜色） 一个框里横向排列三个块，怎样让这三个块的宽度均为包含块的1/3，尽量说出两种方法 使用flex 使用float，让三个元素都float 使用display: inline-block，并用font-size去除行内块元素的间隔","tags":[]},{"title":"Promise、Generator和async的原理","date":"2018-08-22T12:40:49.000Z","path":"2018/08/22/promise、generator和async的原理/","text":"1. 回调的缺陷想完全的理解Promise，需要从异步的发展开始深究，理解Promise的出现是为了解决什么问题。那么我们从回调开始。回调的缺点是 代码中表达异步的方式不利于开发人员的理解 回调最大的问题就是控制反转，如果将回调传入一个第三方的api，那么无法信任这个api的安全性 可以发明一些特定逻辑来解决这些信任问题，但是会产生更加笨重、更难维护的代码。 回调没有为我们提供一种机制来核实返回类型检查其中第二点是关于回调编码的信任问题。把一个回调传入api可能出现以下问题： 调用回调过早 调用回调过晚 调用回调次数过多或过少 未能传递所需的环境和参数 吞掉可能出现的错误和异常为了更加优雅的处理错误，有些api提供了分离回调：api(…args, success, failure);。以及node中的error-first风格：回调的第一个参数保留用作错误对象，然而使用这种方法也没有解决多次调用的问题，反而还需要我们在error和sucess两种情况都进行判断处理。为了解决由同步异步行为引起的不确定性，提出了永远异步调用回调，这样所有回调都是可预测的异步回调了。 2. Promise针对回调缺陷的改进回调需要被传入api中，由别的api进行控制调用，而更好的方法则是api返回一个类似监听器的对象，由程序控制监听api的执行完成情况和执行结果即成功或失败。对控制反转的恢复实现了更好的关注点分离。其中类似监听器的对象就是Promise的一个模拟。Promise的一个好处是将控制返还给调用代码。Promise通过以下几种方式奠定了自己可信任的基础： 只提供异步调用 如果回调出错，Promise永远不会决议，如何捕获错误呢？Promise中有一种称为竞争的高级抽象机制。 Promise只会接受一次决议，不会因为多次调用决议而出现问题 通过使用catch或是then的第二个onRejected回调来放置异常被吞掉 通过Promise.resolve返回一个可信任的Promise因此Promise通过把控制返还给调用代码，并且将控制权放在一个可信任的系统中，使异步编码更清晰。 4. Promise的局限性当Promise的错误处理回调函数报错时无法处理。Promise只有一个完成值或拒绝理由。如果完成值比较复杂，那么需要在每一步进行封装和解封。 5. Generator和自执行器co的原理假设有下面一个读取文件的生成器： 12345678910111213141516var fs = require('fs');var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 可以看到readFile返回一个Promise对象。下面让我们手动来实现一个大概的co执行器: 123456789101112function run(gen)&#123; var g = gen(); //生成一个迭代器 function step(data) &#123; var result = g.next(data); if(result.done) return result.value; result.value.then(function(data)&#123; step(data); &#125;); &#125; step();&#125;run(gen); 可以看到这个执行器中，首先生成一个迭代器，然后使用迭代器的next方法开始迭代，先判断当前是否迭代完。如果没有迭代完，通过result.value拿到异步函数的Promise对象，然后在.then中调用step，并将这次Promise的返回值传入step，继续执行异步操作之后的内容。直到迭代完返回最后一次迭代的value。 6. async原理其实一句话async就是Generator的语法糖。上面Generator的例子如果写成async如下： 123456var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。async 函数对 Generator 函数的改进，体现在以下三点。 内置执行器Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 更好的语义async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 更广的适用性co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args)&#123; // ...&#125;// 等同于function fn(args)&#123; return run(function*() &#123; // ... &#125;); &#125; await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。 如何捕获异步错误 定义一个函数将try…catch封装起来，然后在向异步函数中传入被封装过的回调。 123456789101112131415function tryCatchWrap(fn)&#123; return function()&#123; try&#123; fn(); &#125;catch(err)&#123; console.log(err); &#125; &#125;&#125;function test() &#123; console.log('before'); throw Error('error'); console.log('after');&#125;setTimeout(tryCatchWrapper(test) ,1000); 使用window.onerror 监听到了之后统一进行处理 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onerror = function(err) &#123; console.log('window error', err); &#125;; &lt;/script&gt; &lt;script&gt; setTimeout(() =&gt; &#123; throw Error('async error'); &#125;, 3000); throw Error('sync error'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"事件与事件捕获","date":"2018-08-22T07:30:44.000Z","path":"2018/08/22/事件与事件捕获/","text":"1. DOM事件《JS高程》上说，触发事件分为三个阶段：事件捕获、到达目标节点、事件冒泡。然而经测试，发现在事件捕获阶段包含到达目标节点。关于DOM事件触发的顺序，分为三个阶段：事件捕获、到达目标阶段、事件冒泡事件捕获:从window=&gt;document=&gt;html=&gt;body=&gt;…=&gt;目标节点的父节点到达目标阶段：如果事件类型是不可冒泡型，则完成当前阶段后事件对象会停止事件冒泡:从目标节点的父节点=&gt;…=&gt;body=&gt;html=&gt;document=&gt;window不会冒泡的事件有：focus、blur、mouseenter、mouseleave 2.stopPropagationevent.stopPropagation: 无论在捕获还是冒泡阶段都能停止事件对象。event.stopImmediatePropagation：阻止事件冒泡并且阻止相同事件的其他侦听器被调用。除了这个区别，我在使用chrome浏览器测试时发现，如果在目标对象的捕获阶段进行event.stopPropagation，则还是会冒泡到目标对象的冒泡阶段。如果在目标对象的捕获阶段进行event.stopImmediatePropagation，则不会冒泡到目标对象的冒泡阶段。 3. mouseover、mouseenter、mousemove、mouseout、mouseleave的执行顺序mouseover=&gt;mouseenter=&gt;mousemove=&gt;mouseout=&gt;mouseleavemouseover事件是当鼠标位于一个元素外部，用户将鼠标首次移入另一个元素边界之内时触发。mouseenter事件是鼠标从元素外部移动首次移动到元素之内时触发。mouseout事件是鼠标从一个元素，被用户移入另一个元素时触发。mouseleave事件是位于元素上方的鼠标移动到元素范围之外时触发。mouseout和mouseover事件都会先于mouseenter和mouseleave事件，并且mouseout和mouseover事件都会在这种情况下触发：一个父元素内有一个子元素，将鼠标从父元素移动到子元素时，会触发父元素的mouseout事件和子元素的mouseover事件。 4. mouseup、mousedown和click的顺序mouseup=&gt;mousedown=&gt;click 5. DOMContentLoaded、load和jquery.onload的执行点window的load事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。DOMContentLoaded是在完全加载和解析完HTML文档后执行，无需等待样式表、图片、脚本的加载。 6. 事件委托事件委托利用了事件冒泡，在父元素上指定一个事件处理程序，管理某一类的所有事件事件委托的好处：我们需要创建和存储在内存中的事件处理函数变少，在父节点上进行事件委托，那么如果删除或添加一个子节点，就不需要再添加或删除事件监听器。在内存中留有过时不用的“空事件处理程序”，也会造成Web应用程序内存与性能问题。","tags":[]},{"title":"各类排序算法","date":"2018-08-22T02:24:01.000Z","path":"2018/08/22/各类排序算法/","text":"1. 冒泡排序冒泡排序是最简单的排序方法，原理就是从后往前遍历，在遍历一次的过程中，如果后面的数比前面的数小，就将小的数放到前面，因此遍历一次就能将当前最小的数冒泡到最前面。 12345678910111213141516171819function bubbleSort (arr)&#123; let flag=false; for(let i=0;i&lt;arr.length;i++)&#123; flag=false; for(let j=arr.length-1;j&gt;i;j--)&#123; if(arr[j]&lt;arr[j-1])&#123; let tmp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=tmp; flag=true; &#125;&#125; //如果flag在某次循环中没有更改，则说明已经有序 if(flag===false)&#123; break; &#125; &#125; console.log(arr);&#125; 冒泡排序的平均时间是O(n^2)，最坏情况是O(n^2)，即发生在要排序的数组是逆序情况下，最好情况是O(n)，即发生在元素本来有序的情况下。冒泡排序的稳定性因为每次比较后如果两个相邻元素相等我们并不会将他们交换，所以冒泡不会改变相同元素的下标，所以冒泡排序是一个稳定的排序。冒泡排序适用于数据量较小的场景下。 2. 插入排序 直接插入排序插入排序，对于一个数组，我们从第二个数字开始，将其认为是新增加的数字，这样第二个数字只需与其左边的第一个数字比较后排好序；在第三个数字，认为前两个已经排好序的数字为手里整理好的牌，那么只需将第三个数字与前两个数字比较即可；以此类推，直到最后一个数字与前面的所有数字比较结束，插入排序完成。 123456789101112function insertSort(arr)&#123; for(let j=1;j&lt;arr.length;j++)&#123; let key=arr[j]; let i=j-1 while(i&gt;=0 &amp;&amp; key&lt;arr[i])&#123; arr[i+1]=arr[i] i--; &#125; arr[i+1] = key; &#125; console.log(arr);&#125; 插入排序的平均时间是O(n^2)，最坏情况是O(n^2)，即发生在要排序的数组是逆序情况下，最好情况是O(n)，即发生在元素本来有序的情况下。也是稳定排序。适用场景是数据量小时使用。并且大部分已经被排序。 希尔排序https://www.cnblogs.com/chengxiao/p/6104371.html希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2)的第一批算法之一。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。具体例子参见链接。1234567891011121314function shellSort(arr)&#123; for(let gap = Math.floor(arr.length/2); gap &gt;=1; gap = Math.floor(gap/2)) &#123; for(let i = gap; i &lt; arr.length; i++) &#123; let j=i-gap; let key = arr[j]; while(j&gt;=0&amp;&amp;key&lt;arr[j])&#123; arr[j+gap] = arr[j]; j = j - gap; &#125; arr[j+gap] = key; &#125; &#125; return arr;&#125; 3. 选择排序 简单选择排序在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。 1234567891011121314151617function selectSort(arr)&#123; for(let i=0;i&lt;arr.length-1;i++)&#123; let min = i; for(let j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[min])&#123; min = j; &#125; &#125; swap(arr,i,min); &#125; return arr;&#125;function swap(arr, i, j) &#123; let tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125; 堆排序https://www.cnblogs.com/MOBIN/p/5374217.html堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，每个节点都大（小）于它的两个子节点，当每个节点都大于等于它的两个子节点时，就称为大顶堆，也叫堆有序； 当每个节点都小于等于它的两个子节点时，就称为小顶堆。 算法思想(以大顶堆为例)：1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆2.将根节点与尾节点交换并输出此时的尾节点3.将剩余的n -1个节点重新进行堆有序化4.重复步骤2，步骤3直至构造成一个有序序列具体的步骤参见链接。 12345678910111213141516171819202122232425262728293031323334353637383940414243function heapSort(arr)&#123; let result=[];let len = arr.length -1;//构造一个大顶堆，树的根节点是数组中的0~Math.floor(arr.length/2)-1位，所以从下到上对每一个根节点进行一个堆有序化的操作for(let i=Math.floor(arr.length/2)-1;i&gt;=0;i--)&#123; adjustHeap(arr, i, len);&#125;//将第一个节点与最后一个点交换，这样最大的节点就到了最后一位，然后前面的n-1个节点重新进行堆有序化，继续得到一个大顶堆，然后再重复操作。 while(len&gt;=0)&#123; swap(arr, 0, len--); adjustHeap(arr, 0, len); &#125; return arr;&#125;function adjustHeap(arr, i, length)&#123; let tmp = arr[i]; let j; while(2*i+1 &lt;= length)&#123; j = 2*i+1; if (arr[2*i+1] &gt; arr[i]) &#123; if(2*i+2 &lt;= length &amp;&amp; arr[2*i+1] &lt; arr[2*i+2]) &#123; j++; swap(arr, i, 2*i+2) &#125;else&#123; swap(arr, i, 2*i+1) &#125; &#125; else &#123; if(2*i+2 &lt;= length &amp;&amp; arr[i] &lt; arr[2*i+2]) &#123; j++ swap(arr, i, 2*i+2); &#125;else&#123; break; &#125; &#125; i = j; &#125;&#125;function swap(arr, i, j) &#123; let tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125; 4. 归并排序归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之）。 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。代码实现： 1234567891011121314151617181920212223242526272829303132333435function main(arr)&#123; let tmp=[]; sort(arr, 0, arr.length-1, tmp); console.log(arr);&#125;function sort(arr, start, end, tmp)&#123; if(start&lt;end)&#123; let mid=Math.floor((start+end)/2); sort(arr, start, mid, tmp); sort(arr, mid+1, end, tmp); merge(arr, start, mid, end, tmp); &#125;&#125;function merge(arr, start, mid, end, tmp) &#123; let i = start; let k = mid + 1; let t = 0; while(i&lt;=mid &amp;&amp; k&lt;=end)&#123; if(arr[i]&lt;=arr[k])&#123; tmp[t++] = arr[i++] &#125;else&#123; tmp[t++] = arr[k++]; &#125; &#125; while(i&lt;=mid)&#123; tmp[t++] = arr[i++]; &#125; while(k&lt;=end)&#123; tmp[t++] = arr[k++]; &#125; t=0; while(start&lt;=end)&#123; arr[start++] = tmp[t++]; &#125;&#125; 归并排序的时间复杂度是O(N*logN)，是稳定排序，适用于需要稳定，空间不是很重要的情况下，并且n较大的情况","tags":[]},{"title":"谈一谈模块化的发展","date":"2018-08-19T15:58:58.000Z","path":"2018/08/19/谈一谈模块化的发展/","text":"最原始的js写法，将所有的函数变量都定义在全局变量下，这种写法污染全局空间，很可能会导致变量命名冲突。接着出现模块模式的写法，模块模式使用了立即执行函数，并通过函数参数传递需要的模块变量。模块模式勉强满足了封装的需求。然而只有封装是不够的，还需要加载。html中的js文件加载，难以维护，依赖过多，同时请求也过多。接下来出现了commonJS模块规范，让js跳出了浏览器环境，定义了module 、 exports 、 require 、 global 实现模块的定义和引用。通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入。CommonJS以服务器优先的方式来同步载入模块，假使我们引入三个模块的话，他们会一个个地被载入。它在服务器端用起来很爽，可是在浏览器里就不会那么高效了。CommonJS已经挺不错了，但假使我们想要实现异步加载模块该怎么办？答案就是Asynchronous Module Definition（异步模块定义规范），简称AMD.AMD是并行加载所有依赖的模块, 并完成执行后, 再开始执行其他代码。在一些同时需要AMD和CommonJS功能的项目中，你需要使用另一种规范：Universal Module Definition（通用模块定义规范）。UMD创造了一种同时使用两种规范的方法，并且也支持全局变量定义。所以UMD的模块可以同时在客户端和服务端使用。最后再ES6中定义了模块，使用import和export来导出引入模块。现在出现了webpack模块打包器，使用webpack在打包模块的同时进行优化，通过使用loaders可以","tags":[]},{"title":"CORS","date":"2018-08-19T09:51:20.000Z","path":"2018/08/19/跨域/","text":"1. CORS浏览器将CORS分为两种请求：简单请求和非简单请求对于简单请求，浏览器检测到ajax跨域，会在请求头上添加origin字段，origin字段表示当前请求来自哪个源。如果origin指定的源，在许可范围，服务端返回的响应头中会有：access-control-allow-origin、acess-control-allow-credentials、Access-Control-Expose-Headers。如果origin指定的源，不在许可范围，服务端会正常返回，但是响应头中不会有access-control-allow-origin，从而浏览器抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。对于复杂请求，会先发一个OPTIONS类型的预检请求，会携带origin、Access-Control-Request-Method、Access-Control-Request-Headers请求头。服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。返回的响应头中Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers 2. iframe+window.name解决跨域问题window.name属性的神奇之处在于name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。在A页面，创建一个iframe，iframe的src设置为跨域服务器的地址。然后在iframe onload的时候将iframe的src换成和A页面同一个域名下的proxy页面。然后因为iframe的域名和A是同域，因此就能拿到iframe.contentWindow.name。 3. iframe+location.hash解决跨域问题在A页面中创建一个iframe，iframe的src设置为跨域服务器的地址，跨域服务端改变iframe的location并将要传输的数据放在hash中传回。 123456789101112&lt;?php // 如果有必要则进行数据处理 $_GET['..'] // code // 返回的数据 $data = '&#123;\\\"name\\\":\\\"hanzichi\\\",\\\"age\\\":10&#125;'; echo \" &lt;script&gt; window.location = 'http://localhost:81/location-hash/proxy.html' + '#' + \\\"$data\\\"; &lt;/script&gt; \"?&gt; 可以看到跨域服务器将iframe的location设置为http://localhost:81/location-hash/proxy.html，并回传数据。然后iframe在onload中获取iframe.contentWindow.location.hash。 123456789101112131415161718192021222324&lt;body&gt; &lt;script type=\"text/javascript\"&gt; function getData(url, fn) &#123; var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src = url; iframe.onload = function() &#123; fn(iframe.contentWindow.location.hash.substring(1)); window.location.hash = ''; document.body.removeChild(iframe); &#125;; document.body.appendChild(iframe); &#125; // get data from server var url = 'http://localhost:8080/data.php'; getData(url, function(data) &#123; var jsondata = JSON.parse(data); console.log(jsondata.name + ' ' + jsondata.age); &#125;); &lt;/script&gt;&lt;/body&gt;","tags":[]},{"title":"页面优化","date":"2018-08-19T03:06:41.000Z","path":"2018/08/19/页面优化/","text":"本文将从首屏优化和项目优化两个角度阐述页面优化 1. 图片优化如果将图像原始格式直接存储到文件中将会非常大，比如一个50005000 24位图，所占文件大小为50005000*3字节=71.5MB, 其大小非常可观。如果用zip或rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高，因为这些压缩算法没有针对图像数据结构进行特殊处理。于是就有了jpeg,png等格式，同样是图像压缩算法jpeg和png也有不同的适用场景，所以jpeg,png文件之于图像，就相当于zip,rar格式之于普通文件(用zip,rar格式对普通文件进行压缩)。图片一般有三种格式：png、jpeg和bmp。bmp：没有压缩像素格式。jpeg：jpeg是有损压缩格式, 将像素信息用jpeg保存成文件再读取出来，其中某些像素值会有少许变化。jpeg没有透明信息。jpeg比较适合用来存储相机拍出来的照片。png：png是一种无损压缩格式，png可以有透明效果。png比较适合适量图,几何图。jpeg比较适合存储色彩“杂乱”的拍摄图片，png比较适合存储几何特征强的图形类图片。gif：上面提到的bmp,jpeg,png图片都只有一帧，而gif可以保存多帧图像。 使用CSS Sprites将小图片放在一张图片上进行传输，然后使用background-position定位到需要的图片上。雪碧图的优点是：可以减少http请求。缺点是：如果图片请求失败，雪碧图中的图片页面都无法加载。 使用css、svg、canvas或iconfont代替图片svg：矢量图片，不受像素影响。支持透明，缩放，动画，除了android 2.3的手机，其它场景都支持，是一种比较好的图片代替方案。SVG的结构是 XML，其可访问性（盲文、声音朗读等）、可操作性、可编程性、可被CSS样式化完胜Canvas。另外，其支持 ARIA 属性，使其如虎添翼。SVG对动画的支持较好；其DOM结构可以被其特定语法或者Javascript控制，从而轻松的实现动画SVG功能更完善，适合静态图片展示，高保真文档查看和打印的应用场景。SVG不适合大量元素，但是适合屏幕大的。因为DOM比正常的图形慢，而且如果其结点多而杂，就更慢了。不适合网页游戏等 canvas：位图。Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制 css代替图片场景：适用于移动端或较高级的浏览器，而且绘制的图案较为简单。原理：css方式可以用来绘制相对简单的团来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。优势：实现简单，可以实现简单的动态效果劣势：也受限于css的兼容性特点，绘制复杂图案困难 压缩图片优势：减少图片加载流量，效果比较明显 劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持，格式转换要考虑浏览器的兼容性1. 网站优化从首屏加载时间上来看，10%～20%的最终用户响应时间是花在从Web服务器获取HTML文档，并传送到浏览器中。而剩余的80%～90%的时间都花在了HTML文档所引用的所有组件（图片、脚本、样式表等）。所以优化这部分最重要。对于首屏加载可以做的优化有：1、减少http请求（1）使用CSS Sprites（2）使用内联图片，就是通过使用data:URL模式可以在Web页面中包含图片而无需任何额外的HTTP请求。（3）合并脚本、样式表，减少脚本和样式表的数量就减少HTTP请求。以合并脚本为例，不是要将所有的js都合并到一个文件中，而是需要保持js的模块化减少http请求的好处在哪儿呢？在HTTP1.1版本中有keep-alive的特性，当发送多个http请求，只会建立一次tcp连接。因此发送一次请求相比发送多次请求的优点主要体现在网络延迟上。网络延迟其实是在有keep-alive情况下仍然需要请求合并的主要动力。如果考虑丢包，合并请求更有优势。合并后的文件可以允许队首丢包之后在中间传输过程中补上来，而分开资源的时候，前一个资源未加载完成后面的资源内容是不能加载的，会有更严重的队首阻塞问题，所以丢包率能进一步影响keep-alive下多个小文件的传输。当然合并文件也有缺点。文件合并的越多，合并文件的缓存失效率就越高。2、将静态资源比如：图片、脚本、样式表转移到CDN上。CDN是将源站资源分发至距离用户最近的节点，减少用户请求资源的时间，加速用户对网站的访问。3、在服务器上配置使用缓存：expires和cache-control的max-age。当expires和cache-control的max-age没有过期，但是服务器上的资源改变了又应该怎么办呢？最有效的而解决方法就是修改资源链接的文件名。如果时间过期，则发送一个条件GET请求，如果资源没有变则服务器发送一个304的响应，告诉浏览器资源没有改变，并且重新设置expires和cache-control的max-age。4、可以将html、样式表和脚本进行压缩。客户端通过HTTP请求中的Accept-Encodeing来标识对压缩的支持:Accept-Encodeing:gzip, default服务器通过响应中的Content-Encoding:gzip来通知客户端使用哪种压缩方法。压缩通常能将响应的数据量大大减少。压缩的配置取决于服务器的类型和版本。 2. 页面渲染优化3. 实习项目优化 DNS预获取 dns-prefetch 提升页面载入速度使用dns预解析 JavaScript 模块打包使用Webpack模块打包，可以保持js的模块化，对于优化主要体现如下： optimization.splitChunks将entry文件的公共引用模块提取出来，将node_modules提取到vendors中 通过externals配置来提取常用库配置后可以告知webapck遇到此类变量名时就可以不用解析和编译至模块的内部文件中，而改用从外部变量中读取，这样能极大的提升编译速度，同时也能更好的利用CDN来实现缓存。 使用Happypack加速你的代码构建Happypack的出发点就是，让可以并发执行的loader，加快构建。 uglifyJSPlugin压缩js代码使用webpack，保持模块化的同时，减少资源文件的加载，压缩代码，加快项目构建速度和减少http请求 按需加载资源图片懒加载 4. 图片加载优化","tags":[]},{"title":"Webpack4","date":"2018-08-17T06:45:43.000Z","path":"2018/08/17/Webpack4/","text":"webpack的核心是用于现代JavaScript应用程序的静态模块捆绑器。 当webpack处理您的应用程序时，它会在内部构建一个依赖关系图，它映射您的项目所需的每个模块并生成一个或多个包。 1. Webpack解析过程首先，从入口文件开始，webpack开始解析文件中引用到的模块，这里使用JavaScript parser。JavaScript parser是可以读和理解JavaScript代码的工具，它生成一个更抽象的模型，称为AST（抽象语法树）。AST包含了很多我们代码的信息。接下来我们遍历AST找出当前模块依赖哪些模块，也就是当前模块import了哪些模块。在这一步也会使用当前文件对应的loader来编译当前文件，以便将当前文件包含到最终的bundle中。接下来，我们将提取每个模块的依赖模块，原理大概是： 定义一个数组queue，将entry文件的相关信息存入queue，相关信息会包括entry的filename和entry的依赖项dependencies等。 遍历数组queue的每一项，对当前项的dependencies对应路径的文件再进行JavaScript parser，然后将这个文件的相关信息再存入queue中，从而最终遍历完成，构建出一个依赖图。最后，由这个依赖图构建一个bundle文件。简单而言，从入口文件开始，如果有依赖模块，则根据路径拿到该模块export的内容 2. loaderwebpack通过loader支持用各种语言和预编译器编写的模块，loader向webpack描述如何处理非JavaScript模块并将这些依赖项添加到依赖关系图中。常用的loader有：babel-loader、css-loader、file-loader、less-loader下面主要讲一讲babel的原理：babel类似于一个编译器，将同种语言的高版本规则翻译成低版本规则，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下： ES6代码输入 ==》 babylon进行解析 ==》 得到AST==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树==》 用babel-generator通过AST树生成ES5代码 3. optimizationoptimization被用来执行一些优化的操作。CommonsChunkPlugin和optimization.splitChunks：webpack4已经移除CommonsChunkPlugin可以用optimization.splitChunks代替当有多个入口文件时，可能每个入口文件都有相同的引用，所以可以优化将相同的引用给取出来，模块之间的公共引用给取出就叫做chunk，splitChunks可以具体配置如何拆分。vendor是针对node_module中的第三方库，将公用的第三方库提出来，放在公共chunk中。 4. pluginplugin被用来执行一些优化bundle、资产管理和环境变量注入的功能。经常会用到的plugin有：UglifyjsWebpackPlugin、ExtractTextWebpackPlugin、HtmlWebpackPlugin、HotModuleReplacementPlugin下面分别介绍一下： HtmlWebpackPluginHtmlWebpackPlugin简化了html文件的创建 ExtractTextWebpackPluginExtractTextWebpackPlugin将入口文件中所有引入css模块的部分，提出到一个单独的css文件中 UglifyjsWebpackPlugin用来缩小JS的代码量 HotModuleReplacementPlugin热模块更换（HMR）在应用程序运行时交换，添加或删除模块，无需完全重新加载。热加载的好处如下： 保留在完全重新加载期间丢失的应用程序状态。 只需更新已更改的内容，即可节省宝贵的开发时间。 更快地调整样式 - 几乎可以与浏览器调试器中的样式更改相媲美。下面讨论一下热加载的原理：从应用程序来讲：应用程序要求HMR runtime检查更新。runtime异步的下载更新，并且通知应用程序应用程序让runtime去进行更新runtime程序异步的进行更新从编译器来讲：编译器的更新包括两个方面： 更新 manifest 更新chunks编译后需要保持chunks和module的能对应上manifest文件包含了新的编译后的hash和更新的chunks。从模块来讲：应用程序让HMR去进行更新模块，在模块中包含HMR的处理函数，当HMR通知模块更新，模块就进行更新。但是很多时候不强制在模块中写HMR接口，所以当模块没有HMR处理函数，更新就会冒泡，这就意味着，一个小模块的更新会让整个模块树更新。从runtime来讲：runtime可以跟踪父模块和子模块。runtime支持check和apply这两个方法。check方法发送HTTP请求更新manifest。如果请求失败，就没有内容可更新；请求成功，则下载所有需要更新的chunks，所有的模块更新都存储在runtime中。当所有的chunks更新都被下载下来并且准备被应用，runtime的状态切换到ready状态。apply方法将所有待更新的模块标记为无效，无效模块或者其父模块需要有更新处理函数，否则，将其父模块也标记为无效，并继续冒泡，一直冒到某个模块有更新处理函数，如果一直冒到entry文件都没有，则处理失败。之后，所有无效模块都被处理（通过配置处理程序）并卸载。runtime切换回空闲状态，一切都正常继续。上面讲的都是放屁，实现HMR需要开启一个server，然后当文件改变通过websocket或者sse通知浏览器，浏览器获取到改变了之后的内容，再更新到网页中去。 5. mode这是webpack4的新特性，通过设置mode为production或development，可以启用与每个环境相对应的webpack内置优化。 默认值为production。 6. runtime在一个用webpack构建的应用程序中，有三类代码： 源代码 第三方库的代码 用于执行所有模块交互的webpack runtime和manifest下面主要介绍第三类代码。分为runtime和manifest。runtime和manifest是当运行在浏览器时，webpack用来连接模块化应用程序的代码，它包含在模块交互时连接模块所需的加载和解析逻辑。 这包括连接已经加载到浏览器中的模块以及延迟加载尚未加载的模块的逻辑。随着编译器进入，解析并映射出应用程序，manifest会记录所有模块的详细说明，包括模块的位置等。当运行时，runtime在解析并加载模块时，会需要从manifest中查询模块位置。 7. Webpack4的新特性 需要设置mode在webpack4中直接指定mode，可以针对不同环境的默认优化配置，比如development模式的NamedModulesPlugin和NamedChunksPlugin。production模式的UglifyJsPlugin、NoEmitOnErrorsPlugin、ModuleConcatenationPlugin webpack4删除了CommonsChunkPlugin插件，它使用内置API optimization.splitChunks 需要安装webpack -cli 8. development和production环境下配置的不同development source-map方便展示错误信息来自具体哪个文件，方便调试 webpack-dev-server提供一个简单的server","tags":[]},{"title":"输入一个URL","date":"2018-08-16T15:41:11.000Z","path":"2018/08/16/输入一个URL/","text":"总体来说分为以下几个过程: DNS解析 封装HTTP请求 TCP连接 IP层 服务器处理请求并返回响应报文 浏览器解析渲染页面 连接结束 1. DNS解析首先对请求的域名进行DNS解析成一个IP地址。过程如下：（1）将待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。如果本地域名服务器查找到域名，就把对应的IP地址返回。如果本地域名服务器不能查找到域名，则由本地域名服务器接手查询（2）本地域名服务器向根域名服务器的查询通常采用迭代查询。也就是根域名服务器告诉本地域名服务器需要向某个顶级域名服务器请求，然后本地域名服务器去请求顶级域名服务器（3）本地域名服务器去请求顶级域名服务器，顶级域名服务器要么给出所要查询的ip地址，要么告诉本地域名服务器下一步应当向哪个权限域名服务器进行查询（4）最终一步一步的本地域名服务器知道了ip地址，将结果返回给发起查询的主机。（5）为了提高查询效率，在域名服务器中广泛使用了高速缓存。 2. 封装HTTP请求发送一个HTTP请求，一个HTTP请求包括：状态行、请求头、请求体http请求头有四种类型，分别是通用头部，请求头部，响应头部以及内容头部content-type是属于内容头部前端向后台传输的数据有几种类型：表单、字符串、json通过Content-Type来告诉后台当前请求数据的类型，常见的媒体格式类型如下：text/html ： HTML格式text/plain ：纯文本格式text/xml ： XML格式image/gif ：gif图片格式image/jpeg ：jpg图片格式image/png：png图片格式通过Content-Type来告诉后台前端传输的数据类型，常见的类型如下：application/json ：传递的是一个json对象。application/x-www-form-urlencoded ：发送表单multipart/form-data ：需要在表单中进行文件上传时，就需要使用该格式。 3. TCP连接3.1 TCP的特性TCP 提供一种面向连接的、可靠的字节流服务在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCPTCP 使用校验和，确认和重传机制来保证可靠传输TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 3.2 TCP三次握手ACK是确认包，SYN是同步位第一次客户端发送SYN=1，seq=x，发送完毕，客户端进入 SYN_SEND 状态。第二次服务端发送SYN=1，ACK=1，ack=x+1，seq=y，发送完毕，服务端进入 SYN_RCVD 状态。第三次客户端发送ACK=1，seq=x+1,ack=y+1，发送完毕，客户端进入ESTABLISHED状态。进行三次握手的原因是防止已失效的链接2请求报文又传回了服务器，如果客户端发送连接请求给服务端，但是请求延误，客户端认为请求失败，可能又会发起一次新的请求。过了一会儿刚才延误的请求报文发送到了服务器，服务器发送响应包，如果只有两次握手，则此时服务器认为连接建立完成，分配好了资源和客户端通信，但客户端在之前已经认为第一次请求失败，便不会理会服务端发送的响应包。因此可以看出只有两次握手的话，可能会浪费服务器资源。 3.3 TCP四次挥手FIN是连接终止位第一次客户端发送FIN=1，seq=u，客户端进入FIN-WAIT-1状态第二次服务端发送ACK=1，seq=v，ack=u+1，服务端进入CLOSE_WAIT状态。此时客户端到服务端的连接释放了，此时TCP处于半关闭的状态。也就是客户端不会发送数据给服务端了。第三次服务端发送FIN=1，ACK=1，seq=w，ack=u+1，客户端进入FIN_WAIT_2阶段。第四次客户端发送ACK=1，seq=u+1,ack=w+1,客户端进入TIME_WAIT状态，经过TIME_WAIT设置的等待时间2MSL后，客户端才进入CLOSED状态。服务端收到后进入CLOSE状态 3.4 UDPUDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。UDP 支持多播和广播。 4. IP层建立起TCP连接后，请求也被传送到客户端主机的网络层。网络层实现的最重要的功能是路由选择，简单地说，就是怎么把这一个IP数据报从客户端主机出发，通过网络中的若干个路由器，到达目的主机。路由选择机制的基础是在每一台主机和路由器里都存储着一张路由表。路由表的每一项包含了目的主机IP地址、下一跳路由器（或主机）的IP地址。 5. 服务器处理请求并返回HTTP报文目标主机收到了请求后，自底向上地对该请求进行处理。链路层把数据报传给网络层，网路层将TCP数据段通过对应的Socket传给应用程序。应用程序处理请求后产生一个应答的HTTP报文，又经过了一层层的封装、一跳跳的传输到达了源主机。 6. 浏览器解析渲染页面首先需要了解到浏览器是多进程，包括Browser进程（1个）、GPU进程（1个）、Render进程（多个）。Browser进程：UI线程（创建tab页面，用户操作选择tab页）、IO线程、File线程、数据库线程Render进程：主要的那个进程，每个tab一个。负责执行JS和页面渲染。包含3个线程：Compositor Thread、Tile Worker、Main thread，后文会介绍这三个线程。GPU进程：是和GPU打交道的进程，负责将Renderer进程中绘制好的位图作为纹理上传至GPU，并调用GPU的相关方法把纹理draw到屏幕上。打开浏览器Browser进程启动，调用Browser进程创建一个Tab，用户输入url回车后，将请求结果传递给Render进程，Render进程将结果交给main线程，main线程解析并开始解析渲染网页。 生成render tree首先将html解析成DOM树，将CSS解析成CSS对象模型（CSSOM），对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则，DOM树和CSSOM两者结合生成render tree。在解析过程中如果遇到js标签就会下载解析执行。 layout阶段render tree结束之后进入layout阶段。在上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。 paint阶段 Render Objectlayout阶段之后是paint阶段。paint阶段有一个Render Object的概念，Render Object和DOM节点一一对应。Render Object上实现了将其对应的DOM节点绘制进位图的方法，负责绘制这个DOM节点的可见内容如背景、边框、文字内容等等。同时Render Object也是存放在一个树形结构中的。位图：浏览器可以用位图来记录他想在某个区域绘制的内容。使用一个二维数组，数组中的元素记录这个图片中的每一个像素的具体颜色。然后进行绘制。 Render Layer但仅仅只有Render Object还是不够的，因为浏览器还存在层叠上下文，就是元素间的相互覆盖关系。因此还有一个Render Layer的概念。当然Render Layer的出现并不是简单因为层叠上下文等，比如opacity小于1、比如存在mask等等需要先绘制好内容再对绘制出来的内容做一些统一处理的css效果。总之就是有层叠、半透明等等情况的元素（具体哪些情况请参考无线性能优化：Composite）就会从Render Object提升为Render Layer。不提升为Render Layer的Render Object从属于其父级元素中最近的那个Render Layer。当然根元素HTML自己要提升为Render Layer。因此现在Render Object树就变成了Render Layer树，每个Render Layer又包含了属于自己layer的Render Object。Render Layer 树决定了网页绘制的层次顺序，而从属于 Render Layer 的 Render Object 决定了这个 Render Layer 的内容，所有的 Render Layer 和 Render Object 一起就决定了网页在屏幕上最终呈现出来的内容。 Graphics Layers(又称Compositing Layer)和Graphics Context但是事情还没有结束还有Graphics Layers和Graphics Context。上面的过程可以搞定绘制过程。但是浏览器里面经常有动画、video、canvas、3d的css等东西。这意味着页面在有这些元素时，页面显示会经常变动，也就意味着位图会经常变动。每秒60帧的动效里，每次变动都重绘整个位图是很恐怖的性能开销。因此浏览器为了优化这一过程。引出了Graphics Layers(又称Compositing Layer)和Graphics Context，前者就是我们常说的合成层(Compositing Layer)。3D transform、will-change设置为 opacity、transform等 以及 包含opacity、transform的CSS过渡和动画 这3个经常遇到的提升合成层的情况，更多的参见http://taobaofed.org/blog/2016/04/25/performance-composite/每个合成层Graphics Layer 都拥有一个 Graphics Context，Graphics Context 会为该Layer开辟一段位图，也就意味着每个Graphics Layer都拥有一个位图。Graphics Layer负责将自己的Render Layer及其子代所包含的Render Object绘制到位图里。然后将位图作为纹理交给GPU。 composite阶段现在GPU需要对多层纹理进行合成(composite)，而且GPU对于这个过程是底层硬件加速的，性能很好。最终，纹理合成为一幅内容最终draw到屏幕上。所以在元素存在transform、opacity等属性的css animation或者css transition时，动画处理会很高效，这些属性在动画中不需要重绘，只需要重新合成即可。 7. Renderer进程的三个线程 Compositor Thread这个线程既负责接收浏览器传来的垂直同步信号(Vsync，水平同步表示画出一行屏幕线，垂直同步就表示从屏幕顶部到底部的绘制已经完成，指示着前一帧的结束，和新一帧的开始)， 也负责接收OS传来的用户交互，比如滚动、输入、点击、鼠标移动等等。如果可能，Compositor Thread会直接负责处理这些输入，然后转换为对layer的位移和处理，并将新的帧直接commit到GPU Thread，从而直接输出新的页面。否则，比如你在滚动、输入事件等等上注册了回调，又或者当前页面中有动画等情况，那么这个时候Compositor Thread便会唤醒Main Thread，让后者去执行JS、完成重绘、重排等过程，产出新的纹理，然后Compositor Thread再进行相关纹理的commit至GPU Thread，完成输出。 Main Threadchrome devtools的Timeline里Main那一栏显示的内容就是Main Thread完成的相关任务：某段JS的执行、Recalculate、 Layout Tree、Paint、Composite Layers等等。是浏览器执行我们都知道和喜爱的任务的地方：JavaScript，样式，布局和绘画。 Compositor Tile Worker(s)可能有一个或多个线程，比如PC端的chrome是2个或4个，安卓和safari为1个或2个不等。是由Compositor Thread创建的，专门用来处理tile的Rasterization（前文说过的光栅化）。 8. 重排 Layout、强制重排 Force Layout在正常情况下，修改了一个影响元素布局信息的CSS样式，比如width、height、left、top等（transform除外），那么浏览器会将当前的Layout标记为dirty，这会使得浏览器在下一帧执行上述11个步骤的时候执行Layout。因为元素的位置信息变了，将可能会导致整个网页其他元素的位置情况都发生改变，所以需要执行Layout全局重新计算每个元素的位置。需要注意到，浏览器是在下一帧、下一次渲染的时候才重排。并不是JS执行完这一行改变样式的语句之后立即重排，所以你可以在JS语句里写100行改CSS的语句，但是只会在下一帧的时候重排一次。如果你在当前Layout被标记为dirty的情况下，访问了offsetTop、scrollHeight等属性，那么，浏览器会立即重新Layout，计算出此时元素正确的位置信息，以保证你在JS里获取到的offsetTop、scrollHeight等是正确的。会触发重排的属性和方法:比如clientWidth、offsetWidth、scrollWidth、getBoundingClientRect等 9. 进程和线程 进程和线程的本质进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.线程是进程的一个实体,是CPU调度和分派的基本单位, 它是比进程更小的能独立运行的基本单位. 资源管理方式进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径，它可与同属一个进程的其他的线程共享进程所拥有的资源，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉 进程和线程的切换线程上下文切换和进程上下文切换一个最主要的区别是线程的切换使用的内存空间依然是相同的；但是进程切换是不同的，所以进程切换时，耗费资源较大。 参考：https://juejin.im/entry/59f010fdf265da4315231caahttp://taobaofed.org/blog/2016/04/25/performance-composite/","tags":[]},{"title":"React理解","date":"2018-08-15T14:57:00.000Z","path":"2018/08/15/React理解/","text":"1、React ElementReact Element是React的virtual DOM，本质上就是一个普通的对象，相较于浏览器的DOM更加轻量，它是Component的组成部分，是构建React应用的最小单元。React Element通常由render函数返回的JSX创建，但其本质上只是React.createElement(component, props, …children)的语法糖。React Element有类型之分，比如JSX的标签名就决定了React Element的类型，不同的JSX标签，就是不同类型的React Element。React Element有内容（children）和属性（attribute），但是一旦React Element被创建之后，是无法改变其内容或属性的。即，React Element都是immutable不可变的。更新界面的唯一办法是创建一个新的React Element，会由React DOM对比（diff）新旧React Element\b之后，只把改变了的部分更新到浏览器DOM上。 2、React ComponentsReact的主要特征就是由Components组成。Components可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。所有的React组件必须像纯函数那样使用它们的props，就是不能修改props，只能使用props。满足以下两点称为纯函数： 返回的值仅依赖于传入的参数，而不依赖于内部或外部的其它状态 纯函数运行没有副作用（例如本地静态变量或非局部变量的变异，或执行I / O操作） 2.1 Functional &amp;&amp; Class ComponentFunctional Component 函数定义的组件需要是一个函数，接收单一的props对象作为参数，然后返回一个React Element。Class Component 使用ES6语法定义的组件，必须\b继承自React.Component（或PureComponent），实现render函数并返回React Element。Class Component可以有自己的state，用来实现局部状态（或封装）。 2.2 PureComponentPureComponent改变了生命周期方法shouldComponentUpdate，并且它会自动检查组件是否需要重新渲染。这时，只有PureComponent检测到state或者props发生变化时，PureComponent才会调用render方法。所以PureComponent的使用场景是： props和state的对象中的属性值都是简单类型 确定深层数据结构改变时使用forceUpdate 使用immutable对象React.PureComponent 的 shouldComponentUpdate() 会跳过整个组件子树的 prop 更新，也就是如果父PureComponent不更新，子组件也不可能更新；父PureComponent更新，子组件才更新。因此使用时请确保所有子组件同样是“纯”的。 3、 组件生命周期 首次装载组件时，按顺序执行：getDefaultProps、getInitialState、componentWillMount、render和componentDidMount； 在重新装载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps； 当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。 当卸载组件时，执行 componentWillUnmount；如下图所示：React 通过三种状态：MOUNTING、RECEIVE_PROPS、UNMOUNTING，管理整个生命周期的执行顺序。这三个状态对应三种方法，分别为：mountComponent、updateComponent、unmountComponent。状态一：MOUNTINGmountComponent负责管理生命周期中的getInitialState、componentWillMount、render和componentDidMount。由于getDefaultProps是通过Constructor进行管理，因此也是整个生命周期中最先开始执行，而mountComponent只能望洋兴叹，无法调用到getDefaultProps。这就解释了为何getDefaultProps只执行1次的原因。由于通过ReactCompositeComponentBase返回的是一个虚拟节点，因此需要利用instantiateReactComponent去得到实例，再使用mountComponent拿到结果作为当前自定义元素的结果。关于这部分将虚拟节点转换成DOM元素的过程还是有必要再深挖的。首先通过mountComponent装载组件，此时，将状态设置为MOUNTING，利用getInitialState获取初始化state，初始化更新队列。若存在componentWillMount，则执行；如果此时在componentWillMount中调用setState，是不会触发reRender，而是进行state合并。到此时，已经完成MOUNTING的工作，更新状态为NULL，同时state也将执行更新操作，此刻在render中可以获取更新后的this.state数据。其实，mountComponent本质上是通过递归渲染内容的，由于递归的特性，父组件的componentWillMount一定在其子组件的componentWillMount之前调用，而父组件的componentDidMount肯定在其子组件的componentDidMount之后调用。当渲染完成之后，若存在componentDidMount则触发。这就解释了componentWillMount-render-componentDidMount三者之间的执行顺序。如下图所示：状态二：RECEIVE_PROPSupdateComponent负责管理生命周期中的componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate。首先通过updateComponent更新组件，如果前后元素不一致说明需要进行组件更新，此时将状态设置为RECEIVING_PROPS。若存在componentWillReceiveProps，则执行；如果此时在componentWillReceiveProps中调用setState，是不会触发reRender，而是进行state合并。到此时，已经完成RECEIVING_PROPS工作，更新状态为NULL，同时state也将执行更新操作，此刻this.state可以获取到更新后的数据。调用shouldComponentUpdate判断是否需要进行组件更新，如果存在componentWillUpdate，则执行。updateComponent本质上也是通过递归渲染内容的，由于递归的特性，父组件的componentWillUpdate一定在其子组件的componentWillUpdate之前调用，而父组件的componentDidUpdate肯定在其子组件componentDidUpdate之后调用。当渲染完成之后，若存在componentDidUpdate，则触发，这就解释了componentWillReceiveProps-componentWillUpdate-render-componentDidUpdate它们之间的执行顺序。如下图所示：状态三：UNMOUNTINGunmountComponent负责管理生命周期中的componentWillUnmount。首先将状态设置为UNMOUNTING，若存在componentWillUnmount，则执行；如果此时在componentWillUnmount中调用setState，是不会触发reRender。更新状态为NULL，完成组件卸载操作。 2 setState的更新机制当调用setState时，会对state以及_pendingState更新队列进行合并操作，但其实真正更新state的幕后黑手是replaceState。replaceState会先判断当前状态是否为MOUNTING，如果不是即会调用ReactUpdates.enqueueUpdate执行更新。当状态不为MOUNTING或RECEIVING_PROPS时，performUpdateIfNecessary会获取_pendingElement、_pendingState、_pendingForceUpdate，并调用updateComponent进行组件更新。如果在shouldComponentUpdate或componentWillUpdate中调用setState，此时的状态已经从RECEIVING_PROPS-&gt;NULL，则performUpdateIfNecessary就会调用updateComponent进行组件更新，但updateComponent又会调用shouldComponentUpdate和componentWillUpdate，因此造成循环调用，使得浏览器内存占满后崩溃。总而言之，禁止在shouldComponentUpdate和componentWillUpdate中调用setState，会造成循环调用，直至耗光浏览器内存后崩溃。（错误）而且setState只有咋event handle里面才会批量触发，如果不是有一个AJAX响应处理程序而不是event handle，则每个setState（）都会在发生时立即处理。setState的异步更新目的是： 123456promise.then(() =&gt; &#123; // We're not in an event handler, so these are flushed separately. this.setState(&#123;a: true&#125;); // Re-renders with &#123;a: true, b: false &#125; this.setState(&#123;b: true&#125;); // Re-renders with &#123;a: true, b: true &#125; this.props.setParentState(); // Re-renders the parent&#125;); 2、React虚拟节点和diff算法在不使用现代框架的早期阶段，当页面上数据状态变更后，需要操作对应的DOM元素，页面上监听的事件越多，回调中的DOM操作也越多。手动进行DOM的操作，有两个缺陷：1、操作DOM的复杂性，使代码结构不清晰2、人为操作DOM，可能性能不回达到最佳既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了MVVM模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图。MVVM可以很好的降低我们维护状态-&gt;视图的复杂程度（大大减少代码中的视图更新逻辑）。然而对于react的VirtualDOM而言，即使一个小小的状态变更都要重新构造整棵DOM。只是在react的实现中，加了一些特别的步骤来避免整棵DOM树变更。一个DOM元素的属性非常多，处理DOM不可能会比JS对象处理起来快。VirtualDOM使用JS对象来表示一个节点 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;, ]&#125; 上面对应的HTML写法是： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 所以上面所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。diff算法返回的是最优更新DOM的方式。然而，使用Virtual DOM不一定在性能上强于直接操作DOM：因为使用diff算法，需要先比较两棵Virtual DOM树，得出需要变化的部分，最后再去修改DOM。这个过程可能不比直接操作DOM要快。但是使用virtual dom最大的好处是： 抽象了视图层的操作方法，使用用户可以不用直接操作DOM； 同时在大量操作DOM时，一定比大量操作Virtual DOM效率低。传统的diff算法，算法复杂度高达 O(n^3)，改进后的算法复杂度为O(n)diff算法优化基于三点前提： Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。 两个不同类型的元素将产生不同的树。 通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。基于以上三个前提假设，React 分别对 tree diff、component diff 以及 element diff 进行算法优化 tree diff根据前提1，React diff算法将树进行分层，两棵树只会对同一层次的节点进行比较。既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。当存在跨层级的移动操作呢？此时也是按层比较，不会进行元素层级间的移动，而会新增或是删除节点。这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。 component diff 针对不同类型的元素React会销毁该元素及其所有的子元素，并重新构建新的\b元素及其所有的子元素；DOM元素：直接销毁并重建；Component\b元素：销毁前，该Component实例会收到componentWillUnmount()；重建时，新Component实例会收到componentWillMount() 和 componentDidMount()，这会导致该Component的state\b丢失。 针对相同类型的元素DOM元素：例如div、h1等，React会比较两者的属性，仅更新变化的属性，并递归其子元素；Component\b元素：会保留该Component的实例，并在\b该实例上依次调用componentWillReceiveProps() 和 componentWillUpdate() 方法，该Component的state会保留。在组件元素的render方法被调用的时候，diff算法会继续以该Component的根元素递归处理； element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。当同一层上节点一样，但是节点顺序不同，更新时对每一个节点都需要进行插入新节点和删除旧节点的操作，导致操作繁琐冗余。因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！有key：为了提高效率并保证稳定性，可以给所有的children加“key”。该key值需要在同一兄弟元素之间应该是独一无二的，这样就能快速\u001d地通过该key值做对比，本质上是一种hash的思想。 3. React 数据是如何驱动视图的MVVM的viewmodel层将数据与视图进行绑定，操作数据等同于操作视图，数据修改后视图自动更新。当state或者是props发生变化后，将该组件标记为dirty，然后 4. 废弃的react生命周期原因及新生命周期如何适配旧的生命周期componentWillMount、componentWillReceiveProps、componentWillUpdate是即将在17版本中被标记为unsafe的生命周期函数。这里的“不安全”不是指安全性，而是传达使用这些生命周期的代码更有可能在React的未来版本中出现错误，特别是在启用异步渲染时。 componentWillMount使用constructor和componentDidMount来覆盖 如果要在componentWillMount中放入setState改变状态，可以将这部分代码放入constructor中。 如果要在componentWillMount中进行异步操作，可以将这部分代码写在componentDidMount中。 如果想在componentWillMount中订阅事件，可能会发生内存泄漏，因为如果server rendering或异步rendering出错，componentWillUnmount将不会触发，因此就无法在componentWillUnmount中进行取消订阅，导致内存泄漏。应该将componentWillMount中的订阅事件放入componentDidMount中，这样只有在server rendering或异步rendering顺利执行后才会调用componentDidMount，就不会发生内存泄漏。 componentWillReceiveProps总结来说当有关根据props更新state就将这部分逻辑存放在getDerivedStateFromProps中，如果和异步操作有关（如数据更新）就使用componentDidUpdate。因为componentWillReceiveProps和componentWillUpdate可能会在正式更新之前调用好几次，所以要避免将有副作用的操作放在这个生命周期函数中执行，而应该将这些放入componentDidUpdate方法中，因为componentDidUpdate确保只执行一次。componentWillReceiveProps方法用于根据props更新state，但它经常被错误地用于确实存在问题的方式。 因此该方法将被弃用。响应props以更新state的推荐方法是使用新的静态getDerivedStateFromProps生命周期。getDerivedStateFromProps使用在实例化组件之后以及re-render组件之前，它可以返回一个更新state的对象，或者返回null以指示新的props不需要任何state更新。 componentWillUpdate使用getSnapshotBeforeUpdate和componentDidUpdate来覆盖。有时候componentWillUpdate需要用来比如重新渲染期间手动保留滚动位置时，但是因为异步渲染，所以“渲染”阶段生命周期（如componentWillUpdate和render）和“commit”阶段生命周期（如componentDidUpdate）之间可能存在延迟。 如果用户在此期间执行类似调整窗口大小的操作，则从componentWillUpdate读取的scrollHeight值将过时。此问题的解决方案是使用新的“提交”阶段生命周期getSnapshotBeforeUpdate。 在进行突变之前（例如在更新DOM之前）立即调用该方法。 它可以返回一个React的值作为参数传递给componentDidUpdate，它在突变后立即被调用。很多时候人们会误用componentWillUpdate是担心componentDidUpdate触发时，更新其他组件的状态“为时已晚”。但react确保任何setState在componentDidMount和componentDidUpdate调用时，会在用户看到UI之前立刻刷新。如果在componentWillUpdate中对state变化进行事件绑定，componentWillUpdate可能会发生多次，导致进行多次事件绑定，因此可以将这部分内容放在componentDidUpdate中进行。 5. react和vue在vue中createElement方法用来创建一个虚拟节点。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\b JSX vs Template对于一些开发者而言，模板更容易理解；并且相比JSX，模板可以更好的把功能和布局分割开来；并且比起模板，渲染函数更易于调试和测试。 数据层React组件内部通过state来维护组件状态的变化，这也是state唯一的作用。React里的state只能用setState方法改变。使用setState可以合并需要修改的state，避免多次触发reRender。Vue中的数据是可变的（mutated） 如何实现批量更新react使用setState，vue使用nextTickVue会把一轮事件循环(即一次task)中所有触发的watcher去重后添加到一个队列里，然后将这个队列交由Vue.nextTick()，即将这个队列添加到microtask中，这样在本次task结束后，按照规则就会取出所有的microtask执行它们，实现DOM的更新。就是说如果方法是通过React调用的比如生命周期函数，React的事件处理等，那么会进行批量更新，自己调用的方法，比如setTimeout，xhr等则是连续更新。当批量更新时，react将组件需要更新的状态放入dirtyComponents队列中。在react中有事务（transaction）的概念，事务就是在真正执行method之前加一些预处理和之后加一些尾处理。react将mounting放入method中，然后在mounting结束后的尾处理中，进行批量更新。看到批量更新vue和react的区别：vue：依赖浏览器Api与事件处理队列不可控(我们无法通过编码改变它)react:纯JS实现，不依赖浏览器Api可控性强，可手动调用(因为可编码)是否异步需要看具体场景，易出错(需要对源码有了解) 生命周期生命周期不一样 组件间的数据通信vue：子=&gt;父通信:通过父组件给子组件传递的回调函数，和子组件的自定义事件通信react：子=&gt;父通信:通过父组件给子组件传递的回调函数共同：父=&gt;子通信:props兄弟组件之间的通信：寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法。全局通信：可以定义一个全局的eventEmitter，一个地方发送消息，另一个地方监听并接收消息，很容易想到的就是发布订阅模式了。 事件vue中的事件分为两种一种DOM绑定事件还有一种是自定义事件，自定义事件用于子组件向父组件传递数据，子组件使用$emit触发一个自定义事件，父组件使用v-on监听这个自定义事件。react中的事件是合成事件。在DOM中事件处理函数是一个字符串，而在react的JSX语法中是一个函数。在react中不能使用return false表明阻止默认行为，而必须明确使用preventDefault，在React中定义了合成事件，不需要考虑浏览器的兼容性。使用es6的class语法来定义一个组件时，事件处理器会成为类的一个方法。DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。合成事件有几个特性：1、合成事件对象是共享的，只有一个，这是出于性能因素考虑。在当前事件回调完成之后，会初始化事件对象属性的内容，以便下一次重用。2、合成事件是基于事件委托实现的。直接在DOM树的document上监听原生事件，然后合成对应的事件，根据target分发到对应的React Element上去。同时还实现了event poll，就是事件池，这样可以复用合成的事件对象。 6. 新特性和改进New render return types: fragments and strings; (支持返回数组组件)Better error handling （更好的错误处理）Portals （新特性）Better server-side rendering （更好的服务端渲染）Support for custom DOM attributes （支持自定义 DOM 属性）Reduced file size （体积更小）New core architecture （新的 Fiber 架构） 参考文章：https://github.com/livoras/blog/issues/13https://zhuanlan.zhihu.com/p/20312691https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973https://github.com/facebook/react/issues/11527#issuecomment-360199710https://zhuanlan.zhihu.com/p/20328570https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/blob/master/stack/book/Part-1.md","tags":[]},{"title":"HTTP杂说","date":"2018-08-15T06:14:46.000Z","path":"2018/08/15/HTTP杂说/","text":"1、GET和POSTGET方法是安全方法，安全是指因为GET方法只是执行获取资源的动作，而POST方法被用于请求服务器接受请求中的实体，作为请求资源的一个新的从属物，所以可能会执行不安全动作。GET方法有幂等性，幂等的意思是相同的请求请求结果一样，所以GET是幂等性如果请求消息包含If-Modified-Since，If-Unmodified-Since，If-Match，If-None-Match或者 If-Range头域， GET的语义将变成“条件(conditionall) GET”。一个条件GET方法会请求满足条件头域的实体。条件 GET 方法的目的是为了减少不必要的网络使用，这通过允许利用缓存里仍然保鲜的实体而不用多次请求或传输客户端已经拥有的实体来实现的。POST里的响应是不可缓存的。 2、HTTP状态码 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 100(Continue)HTTP1.1中新加入100响应码，目的在于允许客户端判定服务器是否愿意接受客户端发来的消息主体（基于请求头，Expect:100-continue），如果服务端愿意接受，返回100（Continue），不愿意接受返回417（Expectation Failed），表示客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。 200(OK)请求成功。请求所希望的响应头或数据体将随此响应返回206(Partial Content) 3XX下面主要介绍3开头的和重定向有关的状态码。客户端发送请求，服务端返回一个3开头的状态码，那么客户端会请求服务端返回的新URL。有很多重定向，可以分为三类：永久重定向、暂时重定向和特殊重定向。永久重定向的是301和308，暂时重定向是302、303和307，特殊重定向是300和304。 301(Moved Permanently)永久移动。请求资源被赋予一个新的永久URI，并且任何将来对此资源的引用都会利用这个新的URI。如果客户端接收了一个来自非GET或HEAD请求方法的301响应， 那么就不能自动的向新URI发送重复请求，除非得到用户的确认。使用场景：网站整顿 308(Permanent Redirect) 302(Found)临时移动。请求的资源暂时地存放在一个不同的URI下。如果客户端发出非GET请求后，收到服务端的302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。但是，很多浏览器都把302当作303处理了，它们获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。使用场景：Web页面因为特殊原因暂时无法获得 303(See Other)见其他。请求的响应被放在一个不同的URI下，并且应该用GET方法获得那个资源。如果客户端发出POST或PUT请求后，收到服务端的303状态码，那么浏览器获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。使用场景：防止POST或PUT请求的二次触发 307(Temporary Redirect)临时重定向。如果客户端发出非GET请求，那么规范要求其他的请求方法必须等客户确认才能跳转。请求方法和请求体都不会改变。307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。 300(Multiple Choice)多项选择。是一种手工重定向：响应的消息主体中包含了一个可能的重定向链接的列表，用户可以从中进行选择。 304(Not Modified)没有修改。表示缓存值依然有效。 3、HTTP请求报文HTTP请求报文包括：起始行、请求头和请求体 4、HTTP版本4.1 HTTP1.1相比HTTP1.0 请求方法HTTP1.0中只有三个请求方法：GET、POST、HEADHTTP1.1中增加了PUT、DELETE、OPTIONS、TRACE、CONNECT 长连接HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 新增100响应码HTTP1.1中新加入100响应码，目的在于允许客户端判定服务器是否愿意接受客户端发来的消息主体（基于请求头，Expect: 100-continue），如果服务端愿意接受，返回100（Continue），不愿意接受返回417（Expectation Failed），表示客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。 新添Host头HTTP1.1中添加Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 缓存HTTP1.0中的缓存使用Pragma和Expires来规范，Pragma通过no-cache来禁用缓存，Expires来规定缓存的过期时间。HTTP1.1中使用cache-control来规定缓存的过期时间，或是禁用缓存，如果缓存过期，则进入第二步与服务端进行再验证使用if-modified-since、if-none-match来进行再验证。 4.2 HTTP2.0相比HTTP1.1 请求数量HTTP1.1协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。而HTTP2中多路复用的特性允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。能实现多路复用是因为新增二进制分帧层，消息分帧后可以乱序发送，然后再根据每个帧头部的流标识符重新组装 请求头压缩在HTTP1.x中，头部元数据都是以纯文本的形式发送的，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务器推送服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。","tags":[]},{"title":"Promise理解进阶篇","date":"2018-08-13T01:52:57.000Z","path":"2018/08/13/Promise理解进阶篇/","text":"1、Promise状态变化首先看下面代码： 123456789101112131415161718function doubleUp(value) &#123; return value * 2;&#125;function increment(value) &#123; return value + 1;&#125;function output(value) &#123; console.log(value);// =&gt; (1 + 1) * 2&#125;var promise = Promise.resolve(1);promise .then(increment) .then(doubleUp) .then(output) .catch(function(error)&#123; // promise chain中出现异常的时候会被调用 console.error(error); &#125;); 这个例子中我们先看这一句： 1var promise = Promise.resolve(1); 意思是决议promise的状态，在promise决议之后，会立刻异步调用两个处理函数中的一个，比如是fulfilled状态，则将then的onFulfilled回调函数放入microTask队列，如果是reject状态，则将调用onRejected回调函数放入microTask队列。increment函数有一个参数，这个参数是由Promise.resolve(1)传入的。进入increment函数后，可以看到return value+1，然后increment函数到此为止，其实没这么简单，return的值会由Promise.resolve(return的返回值); 进行相应的包装处理，不管回调函数返回或者不返回，then都会返回一个新建的promise对象，当回调函数有return返回值时生成一个promise，[[PromiseStatus]]是”resolved”，[[PromiseValue]]是return的返回值。当回调函数没有return时，生成的promise，[[PromiseStatus]]是”resolved”，[[PromiseValue]]是undefined。resolve的中文是决议，决议的结果可能是完成也可能是拒绝。比如可以向resolve中传递一个Promise.reject的返回值，那么决议的结果就是拒绝。reject不像resolve会将传入的值展开，如果向reject传入一个promise/thenable值，它就会原封不动的将这个值设置为拒绝理由。 2、catch和then(onRejected)的区别try…catch很好但是无法用于异步的错误捕获。node中的error-first风格可以用于异步的错误处理，但是无法很好的组合，需要写很多if判断。promise没有采用error-first风格，而是用来分离回调风格，一个回调用于完成情况，一个回调用于拒绝情况。那么catch和then(onRejected)这两种捕获异常的方法，咱们用哪一种呢？首先要考虑的是兼容问题。在IE8以下，使用的是ES3规范，在ECMAScript 3中保留字是不能作为对象的属性名使用的，因此不能将catch作为属性来使用。而现在的浏览器都是基于ECMAScript 5的，而在ECMAScript 5中保留字都属于IdentifierName，也可以作为属性名使用了。在es3中实在想用，可以使用中括号标记法（bracket notation）的话，则可以将非合法标识符作为对象的属性名使用。或者我们不单纯的使用catch，而是使用then也是可以避免这个问题的。还有一个区别是，then中的onRejected是不能捕获到onFulfilled中抛出的错误，而catch可以。 3、使用reject而不是throw在promise中并不需要通过throw来抛出一个错误，完全可以用reject来代替。Promise的构造函数，以及被then调用执行的函数基本上都可以认为是在 try…catch 代码块中执行的，所以在这些代码中即使使用throw，程序本身也不会因为异常而终止。如果在Promise中使用throw语句的话，会被 try…catch 住，最终promise对象也变为Rejected状态。如果使用throw我们很难区分到底是程序抛出异常，还是人为抛出，在浏览器的调试功能中有一个在程序发生异常的时，自动break调试的功能，如果我们人为抛出一个错，浏览器开启这个功能时也会自动break调试，从而影响浏览器提供此功能的正常使用。如果想在then中进行reject，怎么办呢？当然是定义一个promise，并返回，比如： 12345var onRejected = console.error.bind(console);var promise = Promise.resolve();promise.then(function () &#123; return Promise.reject(new Error(\"this promise is rejected\"));&#125;).catch(onRejected); 4、异步错误处理既然上面两节提到了错误处理，这一节我们来研究关于异步的错误处理。使用try…catch只能进行同步的错误处理 5、Promise.all和Promise.racePromise.all接收一个promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用.then方法。比如：1Promise.all([request.comment(), request.people()]); request.comment()和request.people()会同时执行，这两个promise的结果会按照顺序返回，即在下一个then的onFulfilled回调函数中接受的参数首先是一个数组，然后这个数组的顺序和Promise.all参数数组的顺序一致，所以 123main().then(function (results) &#123; console.log(results); // 按照[comment, people]的顺序&#125;); 传递给Promise.all的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。Promise.all在接收到的所有的对象promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，与之相对的是Promise.race只要有一个promise对象进入FulFilled或者Rejected状态的话，就会继续进行后面的处理。Promise.race在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。 6、Promise顺序执行Promise.all方法，传入元素为Promise的数组，all方法开始执行时，所有的Promise同时执行，不分先后，当数组中的每一个Promise状态都变成resolve或reject时，这个方法才算执行完。Promise.all可以提供同时执行，但是无法提供顺序执行。下面就以请求url为例，来实现Promise的顺序执行。 123456789101112131415161718192021222324252627const timeout = (ms) =&gt; new Promsie((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, ms);&#125;);const ajax1 = () =&gt; timeous(2000).then(() =&gt; &#123; console.log('1'); return 1;&#125;);const ajax2 = () =&gt; timeous(1000).then(() =&gt; &#123; console.log('2'); return 2;&#125;);const ajax3 = () =&gt; timeous(2000).then(() =&gt; &#123; console.log('3'); return 3;&#125;);function main() &#123; // tasks中的不是Promise的数组，而是方法 var tasks = [ajax1, ajax, ajax3]; sequenceTasks(tasks).then(function (results) &#123; console.log(results); &#125;).catch(function(err) &#123; console.error(err); &#125;)&#125; 下面的关键就是定义 sequenceTasks 函数。 123456789101112function sequenceTasks(tasks) &#123; var results = []; var resultSave = function (value) &#123; results.push(value); return results; &#125; var promise = Promise.resolve(); for(let i in tasks) &#123; let task = tasks[i]; promise = promise.then(task).then(resultSave); &#125;&#125; 这样一个顺序执行就基本实现了，如果觉得在实现上不好看，可以用 Array.prototype.reduce 来改进 12345678910function sequenceTasks(tasks) &#123; var results = []; var resultSave = function (value) &#123; results.push(value); return results; &#125; tasks.reduce(function(promise, task) &#123; return promise.then(task).then(resultSave); &#125;, Promise.resolve());&#125; 7. promise相比于普通回调的性能","tags":[]},{"title":"HTTP缓存","date":"2018-02-07T02:12:33.000Z","path":"2018/02/07/HTTP缓存/","text":"最近在学习HTTP缓存，使用缓存是网站优化的重要步骤。本文是对《HTTP权威指南》第七章缓存的一些摘要和总结。 在商业应用中，使用缓存服务器来提高性能降低对原始服务器的要求。对一条HTTP GET报文的基本缓存处理过程包括7个步骤 ： (1) 接收——缓存从网络中读取抵达的请求报文。(2) 解析——缓存对报文进行解析，提取出 URL 和各种首部。(3) 查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地)。(4) 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。(5) 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。(6) 发送——缓存通过网络将响应发回给客户端。(7) 日志——缓存可选地创建一个日志文件条目来描述这个事务。 这个过程如下图所示： 其中对于新鲜度检测这一步，HTTP协议有两个机制：文档过期和服务器再验证来保持缓存中副本的新鲜度。 1、文档过期通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。 Cache-Control首部和Expires首部告诉客户端到了某个时间点（比照客户端时间点）后本地缓存就过期了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示返回200（强缓存），一旦资源命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。Chrome下的现象是200 OK (from disk cache) 或者 200 OK (from memory cache). 但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果文档被修改过，就要获取一份新鲜(带有新的过期日期)的副本。 服务器用HTTP/1.0+的Expires首部或HTTP/1.1的Cache-Control: max-age响应首部来指定过期日期，同时还会带有响应主体。Expires首部和Cache-Control: max-age首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。 Cache-Control在浏览器缓存中是金字塔顶尖的规则，它会覆盖一切与之相悖的规则。因此当Expires与之相悖时，就会忽略Expires。 2、服务器再验证如果仅仅是Cache-Control首部和Expires首部规定的时间点过期了，那并不意味着它和原始服务器上目前正处于活跃状态的文档有实际区别。 这只是意味着到了要核对的时间了。这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。 客户端检测到数据过期后，会向服务器发送一个get请求。在请求中一般会携带If-Modified-Since或If-None-Match请求头。 先说If-Modified-Since。如果在指定日期之后资源发生了变化，GET请求就会成功执行返回200响应。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。 如果自指定日期后，文档没被修改过，会向客户端返回一个304 Not Modified 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，Content-Type 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。 再说If-None-Match。有些情况下仅使用最后修改日期进行再验证是不够的。 比如： (1) 有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。(2) 再比如有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。(3) 有些服务器无法准确地判定其页面的最后修改日期。(4) 有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。 在这些情况下HTTP允许用户对被称为实体标签(ETag)的“版本标识符” 进行比较。实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。 当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用 If-None-Match 条件首部收到一条200已缓存的成功响应，返回新的内容以及相应的新 Etag。当实体标签没有被修改，就会返回304未修改响应。 如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有实体标签条件首部ETag，那么只有这两个条件都满足时，才能返回 304 Not Modified 响应。 HTTP规范从未指定生成ETag的方法。生成ETag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 3、关于Cache-Control服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以: 附加一个Cache-Control:no-store首部到响应中去; 附加一个Cache-Control:no-cache首部到响应中去; 附加一个Cache-Control:must-revalidate首部到响应中去; 附加一个Cache-Control:max-age首部到响应中去; 附加一个Expires日期首部到响应中去; 不附加过期信息，让缓存确定自己的过期日期。 标识为 no-store 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。 标识为 no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。 我的理解是no-cache是表示max-age=0即立马过期。 Cache-Control: max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数 。 4、关于Expires响应首部不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。 5、当响应中没有Cache-Control: max-age首部，也没有 Expires 首部时如果响应中没有Cache-Control: max-age首部，也没有 Expires 首部，那么使用LM-Factor 算法 的试探性过期算法，用当前时间Date与文档的最后修改时间之差，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。 6、用户操作行为与缓存用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按F5刷新等，这些行为会对缓存有什么影响呢？ 通过上表我们可以看到，当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；而当用户使用Ctrl+F5进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。","tags":[]},{"title":"DOM中外部资源的解析与优化","date":"2018-01-28T14:57:39.000Z","path":"2018/01/28/DOM中外部资源的解析与优化/","text":"DOM中外部资源的解析与优化 浏览器的渲染简介首先下载html、js、css。接着浏览器首先会将html转换成一种他们能够理解的格式DOM，CSS 样式被映射到 CSSOM 上（css对象模型），这两者结合生成render tree。 解析过程中遇到js标签就会下载解析执行。 render tree结束之后进入layout阶段。 layout是指计算每个DOM元素最终在屏幕上显示的大小和位置。遍历顺序为从左至右，从上到下，由于web页面元素布局是相对的，所以任意元素的位置发生变化，都会引起其他元素位置的变化，这就是reflow。 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来的过程称为paint。当元素改变时并且这种改变不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为repaint。 reflow 的成本比 repaint 的成本高得多的多。一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow 。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是延慢加载和耗电的。 DOM中外部资源的解析和优化看到一篇很好的文章，Building the DOM faster: speculative parsing, async, defer and preload。下文是我对这篇文章在原文的基础上加入了自己一些的理解。 js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析在过去为了执行一个脚本，HTML的解析必须暂停。只有在JavaScript引擎执行完代码之后它才会重新开始解析。如果HTML的解析不暂停，脚本可以改变DOM结构，或者脚本可能会需要获取某个DOM节点，如果是在DOM还在构建时获取，可能会返回意外的结果。所以JS阻塞页面的原因是它可以修改DOM节点。 而css会阻塞js脚本的解析，因为js可能会需要样式信息。 因此总结一下：如果在文档中外部样式表放置在脚本之前，DOM 对象和 CSSOM 对象的构建可以互相干扰。 当解析器获取到一个 script 标签，DOM 将无法继续构建直到 JavaScript 执行完毕，而 JavaScript 在 CSS 下载完，解析完，并且 CSSOM 可以使用的时候，才能执行。 虽然css不阻塞DOM的构建，但它会阻塞DOM的渲染。直到DOM和CSSOM都准备好之前，浏览器什么都不会显示。 预解析在以前当解析器遇到一个脚本就意味着如果是引入脚本，先要下载，然后再解析，如图所示。 脚本下载的时间也阻塞HTML的解析，这样非常耗时，那么有没有一种方法能够让脚本下载异步进行呢？ 这种在同步的脚本执行的时候保持文件下载的方法在不同的浏览器有不同的名字，Chrome 和 Safari 称它为 “预扫描器” 而 Firefox 称它为预解析器。 它的概念是：虽然在执行脚本时构建 DOM 是不安全的，但是你仍然可以解析 HTML 来查看其它需要检索的资源。找到的文件会被添加到一个列表里并开始在后台并行地下载。当脚本执行完毕之后，这些文件很可能已经下载完成了。 所以上面那张图在有了预解析器后会变成这样： 以这种方法触发的下载请求称之为“预测”，因为很有可能脚本还是会改变HTML结构（还记得document.write吗？），导致了预测的浪费。虽然这是有可能的，但是却不常见，所以这就是为什么预解析仍然能够带来很大的性能提升。 可以预加载的东西在浏览器之间有所不同，所有的主要的浏览器都会预加载：脚本、外部CSS、来自img标签的图片。 在预解析HTML页面时，浏览器不会执行内联的JS代码块，这意味着它不会发现任何的脚本注入资源，也意味着，如果当我们需要一些不重要的资源晚一点被加载的时候，就可以使用JS来加载这些资源，从而避免预解析。 defer和async虽然通过预解析可以减少加载资源的时间，但是脚本的解析会阻塞页面解析这依然是个问题。其实并不是所有的脚本都一样重要，对于那些不那么重要的脚本可以采用异步加载。defer和async属性就是提供给开发者一个方式来告诉浏览器哪些脚本需要异步加载。这两个属性都告诉浏览器，它可以一边加载脚本一边解析HTML，并在HTML解析完后再执行脚本，这样脚本的加载和执行就不会阻塞页面解析。 Defer和asycn之间的不同就是它们开始执行脚本的时机不同。 Defer会使js脚本的执行在HTML解析完全结束之后开始，在DOMContentLoaded 事件被触发之前执行。它保证脚本会按照它在HTML中出现的顺序执行，并且不会阻塞解析。（当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。） 而设置了async的脚本会在它们加载完后的第一时间执行。这意味着有可能（并且很有可能）设置了async的脚本不会按照它们在HTML中出现的顺序执行。这也意味着他们可能会中断DOM的构建。不过设置了async的脚本的加载有着较低的优先级。他们通常在所有其他脚本加载之后才加载，而不阻塞DOM构建。然而，如果一个指定async的脚本很快就完成了下载，那么它的执行会阻塞DOM构建以及所有在之后才完成下载的同步脚本。 async和defer属性只对外部脚本起作用，如果没有src属性它们会被忽略。 preload作为作者，你知道哪些资源对你的页面渲染来说是最重要的。它们其中一些经常深藏在CSS或者是脚本当中，甚至浏览器需要花上很长一段时间才会发现他们。对于那些重要的资源，你现在可以使用&lt;link rel=&quot;preload&quot;&gt;来告诉浏览器你需要尽快地加载它们。 你只需要写上:&lt;link rel=&quot;preload&quot; href=&quot;very_important.js&quot; as=&quot;script&quot;&gt;，这样你几乎可以链接到任何东西上，并且as属性告诉浏览器要下载的是什么。一些可能的值是：style、script、image、font、audio、video","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"Promise理解","date":"2018-01-06T13:12:13.000Z","path":"2018/01/06/Promise/","text":"Promise是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，Promise并不是从JavaScript中发祥的概念。 创建一个promise对象要想创建一个Promise对象、可以使用new来调用Promise的构造器来进行实例化。 1234567891011121314const fs = require('fs')function readFile(filename) &#123; return new Promise(function (resolve, reject) &#123; // 异步处理 // 处理结束后、调用resolve 或 reject fs.readFile(filename, &#123;encoding: 'utf8'&#125;, (err, contents) =&gt; &#123; if (err) &#123; reject(err) return &#125; resolve(contents) &#125;) &#125;)&#125; 这段代码中new了一个Promise对象，在这个构造函数中传入的参数是一个执行器，当触发这个执行器的异步操作时，并不会阻塞，而是继续向下执行，直到完成promise对象的创建。然后将这个创建的promise对象return，此时这个promise的状态为pending。 当执行器中的异步操作完成，就会将回调函数放入任务队列中，等到执行该任务时，调用resolve会将promise对象变为resolve（Fulfilled）状态,调用reject会将promise对象变为Rejected状态，此时用then方法来设置resolve后的回调函数， catch 方法来设置发生错误时的回调函数，并将回调函数加入到任务队列末尾：promise.then(onFulfilled, onRejected)。 在resolve(成功)时，onFulfilled 会被调用；reject(失败)时，onRejected 会被调用。resolve和reject会将参数传给onFulfilled和onRejected。onFulfilled、onRejected 两个都为可选参数。 Promise.resolve()和Promise.reject()静态方法Promise.resolve(value) 可以认为是new Promise()方法的快捷方式。比如Promise.resolve(42); 可以认为是以下代码的语法糖。 123new Promise(function(resolve)&#123; resolve(42);&#125;); 在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。 方法 Promise.resolve(value); 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。 123Promise.resolve(42).then(function(value)&#123; console.log(value);&#125;); 在使用Promise.resolve(value) 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 .then 里面指定的方法就是同步调用的呢？实际上， .then 中指定的方法调用是异步进行的。 12345678var promise = new Promise(function (resolve)&#123; console.log(\"inner promise\"); // 1 resolve(42);&#125;);promise.then(function(value)&#123; console.log(value); // 3&#125;);console.log(\"outer promise\"); // 2 promise chain 中传递参数前面例子中的Task都是相互独立的，只是被简单调用而已。这时候如果Task A想给Task B传递一个参数该怎么办呢？答案非常简单，那就是在Task A中return的返回值，会在Task B执行时传给它。 我们还是先来看一个具体例子吧。 123456789101112131415161718function doubleUp(value) &#123; return value * 2;&#125;function increment(value) &#123; return value + 1;&#125;function output(value) &#123; console.log(value);// =&gt; (1 + 1) * 2&#125;var promise = Promise.resolve(1);promise .then(increment) .then(doubleUp) .then(output) .catch(function(error)&#123; // promise chain中出现异常的时候会被调用 console.error(error); &#125;); 每个方法中return的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。 return的值会由Promise.resolve(return的返回值); 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终then的结果都是返回一个新创建的promise对象。也就是说，Promise.then不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个promise对象。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"bind函数","date":"2017-12-28T14:34:08.000Z","path":"2017/12/28/bind函数/","text":"简介存在一种情况比如你想要调用某个对象中的方法，并且该方法中会调用这个对象的某个属性，如果直接调用比如： 12345678this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，\"this\"指向全局作用域 可以看到retrieveX中this指向全局，因此如果需要这个this指向module则需要使用bind函数将module.getX的this变成module。bind函数可以实现创建一个新函数，并且制定这个新函数的this值。 12345var retrieveX = module.getX;// 创建一个新函数，将\"this\"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 用法bind的第一个参数是要指定的this对象，其它都是需要传入的参数： 1fun.bind(thisArg[, arg1[, arg2[, …]]]) 当绑定函数被调用时，thisArg参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 解释为了解释“当使用new 操作符调用绑定函数时，该参数无效”这句话，咱们先来归纳一下当使用new操作符来调用函数时，会执行的操作： 创建（或构造）一个全新的对象。 这个新对象会执行[[Prototype]]连接 这个新对象会绑定到函数调用的this 如果这个函数没有返回其它对象，那么new表达式中的函数调用会自动返回这个新对象。 因为使用new会将新对象绑定到函数调用的this，所以指定的this将不起作用，所以这个参数将无效。 bind函数返回由指定的this值和初始化参数改造的原函数拷贝。 bind 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。 polyfill1234567891011121314151617181920212223if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; //oThis是thisArg if (typeof this !== 'function') &#123; //this是调用bind的函数 // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), //aArgs是[arg1,arg2,….] fToBind = this, //this是调用bind的函数(可以想象为slice) fNOP = function() &#123;&#125;, fBound = function() &#123; // bind函数返回一个函数所以fBound return fToBind.apply(this instanceof fNOP ? this: oThis, aArgs.concat(Array.prototype.slice.call(arguments)));// 获取调用时用户向fBound传递的参数.bind 返回的函数入参往往是这么传递的 &#125;; // 维护原型关系 if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"CSS中的BFC","date":"2017-12-08T02:56:24.000Z","path":"2017/12/08/CSS中的BFC/","text":"BFC是块级格式化上下文。它是由于块级元素设置了某些属性而形成的一个独立的区域。在这个区域中，它里面的布局不会影响到外面元素的布局，反之也一样。 创建一个BFC只需要满足下面条件之一就能创建一个BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 BFC的用处使用BFC来防止外边距折叠属于同一个BFC的两个相邻的BOX的margin上下方向会重叠，如果不想让两个Box的margin重叠则可以将这两个Box放在不同的BFC中。 使用BFC来包含浮动在BFC的布局规则中的第六条： 计算BFC的高度时，浮动元素也参与计算。 所以可以将父元素变成一个BFC从而来清除浮动： 1234567891011121314151617181920&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; overflow:hidden; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 或者最常见的方法就是写一个clearfix的类： 12345678.clearfix&#123; *zoom:1;&#125;.clearfix:after&#123; content:\"\"; display:table; clear:both;&#125; 使用BFC来防止文字环绕有时候一个浮动div周围的文字环绕着它，代码如下： 1234&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt;Floated div&lt;/div&gt; &lt;p&gt;Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita.&lt;/p&gt; &lt;/div&gt; 但是在某些案例中这并不是可取的，我们想要的是外观跟下图中的右图一样的。 为了解决这个问题，我们可以使用外边距，只要给p设置大于div宽度的margin-left就可以，但是我们也可以使用一个BFC来解决。 在BFC的布局规则中的第一条：BFC的区域不会与float box重叠。因此我们可以将p元素设置成一个BFC：给p元素添加一个overflow: hidden来实现。 在多列布局中使用BFC可以用多种方式解决多列布局，比如圣杯、双飞翼还可以用BFC。比如代码如下： 1234567891011121314151617181920212223242526&lt;style&gt; .left &#123; float: left; height: 200px; width: 100px; margin-right: 20px; background-color: red; &#125; .right &#123; width: 200px; height: 200px; float: right; margin-left: 20px; background-color: blue; &#125; .main &#123; height: 200px; overflow: hidden; background-color: green; &#125;&lt;/style&gt;&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/div&gt; 因为BFC的区域不会与float box重叠，所以将类为main的元素设置为BFC。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"全排列","date":"2017-11-20T08:19:32.000Z","path":"2017/11/20/全排列/","text":"全排列就是将给定序列的所有排列方式找出。 递归解法有重复如下这种方式使用递归，将整组数中的所有的数分别与第一个数交换swap(start,i);，这样就总是在处理后n-1个全排列。 12345678910111213141516171819function perm(list,start,end)&#123; if(start&gt;end)&#123; console.log(list); &#125;else&#123; for(let i=start;i&lt;=end;i++)&#123; swap(list,start,i); perm(list,start+1,end); swap(list,start,i) &#125; &#125;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125;let list=[1,2,3,4,5];perm(list,0,4); 去重复那么在这种递归的方法中，如何去掉重复的全排列呢。 先举个例子：1，2，2 在这个数组中将第一个数与第二个数交换得到2，1，2，将第一个与第三个交换得到2，2，1 然后将2，1，2中的第二个与第三个交换2，2，1，额，，，发生了重复，咱们需要转换思路了。 重新梳理。将第一个数与第二个数交换得到2，1，2，然后发现第二个数与第三个数相同，于是第一个数不再与第三个数交换。 再考虑2，1，2，将第二个数与第三个数交换得到2，2，1.此时全排列完成。 这样我们也得到了在全排列中去掉重复项的规则：去重的全排列就是从第一个数字起，每个数分别与它后面非重复出现的数字交换。用编程的话描述就是第i个数与第j个数交换时，要求[i,j]中没有与第j个数相等的数。 新添加了一个isSwap函数： 12345678910111213141516171819202122232425262728function perm(list,start,end)&#123; if(start&gt;end)&#123; console.log(list); &#125;else&#123; for(let i=start;i&lt;=end;i++)&#123; if(isSwap(list, start, i))&#123; swap(list,start,i); perm(list,start+1,end); swap(list,start,i) &#125; &#125; &#125;&#125;function isSwap(list, start,end)&#123; for(let i=start;i&lt;end;i++)&#123; if(list[i]===list[end])&#123; return false; &#125; &#125; return true;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125;let list=[1,2,3,4,5];perm(list,0,4); 字典排序法全排列的另外一种方法是字典排序法。 字典排序法，就是在数组中，从后往前找，找到第一个非递增数比如1，2，4，3中2就是从前往后第一个非递增数。 然后再次从后往前找，找到第一个大于2的数，在这里就是3，交换2和3，数组变成1，3，4，2。 最后再逆置3后面的数即1，3，2，4 12345678910111213141516171819202122232425262728293031323334353637383940414243function main(list)&#123; list.sort((a,b)=&gt;&#123; return a-b; &#125;) console.log(list); while(perm(list))&#123; console.log(list); &#125;&#125;function perm(list)&#123; let index;//从后往前找，找到第一个非递增数 for(let i=list.length-2;i&gt;=0;i--)&#123; if(list[i]&lt;list[i+1])&#123; index=i; break; &#125; else if (i === 0) &#123; //若没找到，说明当前序列已经是最大字典序了 return false; &#125; &#125;//从后往前找，找到第一个大于index位置上的数 for(let i=list.length-1;i&gt;=index;i--)&#123; if(list[i]&gt;list[index])&#123; swap(list, i, index); reverse(list, index+1); break; &#125; &#125; return true;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125;function reverse(list, start)&#123; let end = list.length-1; while(start&lt;end)&#123; swap(list,start,end); start++; end--; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"快速排序","date":"2017-11-04T13:32:46.000Z","path":"2017/11/04/快速排序/","text":"快速排序的时间复杂度为O(N*logN)。 算法思路在快速排序中需要有一个Partition函数，这个方法是在数组中选择一个数字，然后把数组中的数字分为两个部分，比选择的数字小的函数移到数组的左边，比选择的数字大的数字移到数组的右边。这个函数的实现如下： 123456789101112131415161718192021function partition(list, length, start, end)&#123; var mid = Math.floor((start + end)/2); swap(list, mid , end); var small = start - 1; for(let i = start; i &lt; end; i++) &#123; if (list[i] &lt; list[end])&#123; small++; if(small !== i)&#123; swap(list, i, small); &#125; &#125; &#125; small++; swap(list, small, end); return small;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125; 算法解释我来解释一下这个函数。 在数组中选取中间的数，然后从前到后遍历，如果某个数比选定的数小，则交换位置。 一个很重要的变量是small，这个变量是用来统计比listend小的数，当list[i]&lt;list[end]，small加一，然后将所有比list[end]小的数，全都交换到前面去。 最后small的位置存放的是选定的数，在这个数前面的数全是小于它，后面的全部大于它。接下需要的就是使用一个递归函数，对选定数之前的数组和选定数之后的数组再进行排序。 123456789101112function quickSort(list, length, start, end)&#123; if(start === end)&#123; return; &#125; var index = partition(list, length, start, end); if (index &gt; start)&#123; quickSort(list, length, start, index - 1); &#125; if (index &lt; end)&#123; quickSort(list, length, index + 1, end); &#125;&#125; partition方法应用在快速排序中的partition方法能用到的地方很多，比如，在剑指offer的面试题29中：数组中出现次数超过一半的数字。也用到了partition。 剑指offer29题这道题可以先对数组做一次partition，判断返回的数是否正好在n/2位置，则这个数就是我们要找的数；如果返回的数在大于n/2，则中位数在这个数的左边；如果返回的数在小于n/2，则中位数在这个数的右边。 1234567891011121314151617function moreThanHalfNum(list, length) &#123; var start = 0; var end = list.length - 1; var mid = Math.floor((start + end)/2); var index = partition(list, length, start, end); while(index !== mid)&#123; if(index &gt; mid) &#123; end = index - 1; index = partition(list, length, start, end); &#125; else &#123; start = index + 1; index = partition(list, length, start, end); &#125; &#125; var result = list[mid]; return result; &#125; 剑指offer30题再比如在剑指offer的面试题30：最小的k个数，也用到了partition。因为在partition中，将小于选定数的数都放在选定数的前面，大于选定数的数都放在选定数的后面，因此这道题要找出最小的k个数，只需要找到partition的返回值index===k-1即可。 12345678910111213141516171819function getLeastNumbers(list,k)&#123; var start = 0; var end = list.length - 1; var result=[]; var index = partition(list, length, start, end); while(index !== k - 1) &#123; if (index &gt; k - 1)&#123; end = index - 1; index = partition(list, length, start, end); &#125; else &#123; start = index + 1; index = partition(list, length, start, end); &#125; &#125; for(let i=0;i&lt;k;i++)&#123; result.push(list[i]); &#125; console.log(result);&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"CSS3 transition","date":"2017-10-27T12:42:21.000Z","path":"2017/10/27/transition/","text":"transition是过渡的意思，可想而知transition属性让元素的一个或一些属性值随着时间的推移从旧状态向新动态过渡。 1、transition的子属性transition有一些子属性来定义元素属性的过渡细节。transition-property属性指定应用了过渡的CSS属性，并不是所有属性都能过渡，在第二节中会详细介绍。除了指定单个属性，还可以设为all。transition-duration属性指定了过渡过程的时长。transition-timing-function属性描述如何计算在过渡过程中使用的中间值。它允许在其持续时间内改变速度。这些效应通常称为缓和函数，有linear，ease，ease-in，ease-out，ease-in-out，cubic-bezier(n,n,n,n)，steps。其实它们都是贝赛尔曲线。如下图所示。 看贝赛尔曲线就知道了，linear是匀速过渡，ease是先快再慢的节奏，ease-in是加速冲刺的节奏，ease-out是减速到停止的节奏，ease-in-out是先加速后减速的节奏。transition-delay属性定义过渡经过一段延迟时间后开始。对于缩写的transition可以包含上面的四项： &lt;single-transition&gt; = [ none | &lt;single-transition-property&gt; ] || &lt;time&gt; || &lt;single-transition-timing-function&gt; || &lt;time&gt; ||代表各部分至少出现一个，可以不按顺序；[ ]强调优先级，即transition-property要放在第一位。有两个time第一个设置的time代表transition-duration，第二个设置的time代表transition-delay。 2、可以transition的属性在transition中，transition-property指定CSS过渡属性。并不是所有属性都能过渡的，只有能数字量化的CSS属性才能过渡。哪些属于能数字量化的CSS属性呢？例如：颜色系：color，background-color，border-color，outline-color等数字系：实在太多了，如width，height，top，right，bottom，left，zoom，opacity，line-height，background-position，word-spacing，font-weight，vertical-align，outline-outset，z-index等。01系：如visibility（0表示隐藏，1表示显示）。 W3C上有可过渡属性一览表Properties from CSS。通常只要能设数字（包括百分比）的属性都能过渡。 3、transition触发那么transition是何时触发的？transition用于定义一个元素在两个状态之间的过渡：css伪类比如:hover、:active可以标识两个状态，在元素上定义transition属性和transition-property指定的属性，然后在元素:hover上改变transition-property指定属性的状态;或者动态的使用js来改变该元素应用了过渡的属性；还有例如@media媒体查询，根据设备大小，横屏竖屏切换时触发。比如mdn上的一个例子，使用:hover来触发过渡： 123&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718.box &#123; border-style: solid; border-width: 1px; display: block; width: 100px; height: 100px; background-color: #0000FF; -webkit-transition:width 2s, height 2s, background-color 2s, -webkit-transform 2s; transition:width 2s, height 2s, background-color 2s, transform 2s;&#125;.box:hover &#123; background-color: #FFCCCC; width:200px; height:200px; -webkit-transform:rotate(180deg); transform:rotate(180deg);&#125; 或者改成使用js改变元素属性，html代码和上面一样。 12345678910.box &#123; border-style: solid; border-width: 1px; display: block; width: 100px; height: 100px; background-color: #0000FF; -webkit-transition: width 2s, height 2s, background-color 2s, -webkit-transform 2s, display 2s; transition: width 2s, height 2s, background-color 2s, transform 2s, display 2s; &#125; 12345678910(function()&#123; const box = document.getElementsByClassName(\"box\")[0]; setTimeout(transition, 2000); function transition()&#123; box.style.backgroundColor = \"#FFCCCC\"; box.style.width = \"200px\"; box.style.height = \"200px\"; box.style.transform = \"rotate(180deg)\"; &#125;;&#125;)() 4、transitionend事件当过渡结束会触发transitionend事件。但如果一个transition在完成之前就被移除（定义transition属性的元素被删除，比如transition的过渡属性display从block到none），那么transitionend事件不会被触发。比如对上面第二个例子进行改进，监听transitionend事件： 1234567891011121314(function()&#123; const box = document.getElementsByClassName(\"box\")[0]; setTimeout(transition, 2000); function transition()&#123; box.style.backgroundColor = \"#FFCCCC\"; box.style.width = \"200px\"; box.style.height = \"200px\"; box.style.transform = \"rotate(180deg)\"; box.style.display = \"none\"; &#125;; box.addEventListener(\"transitionend\", function()&#123; console.log('transitionend'); &#125;, false);&#125;)() 会发现，对display属性进行由block到none的过渡就不会触发transitionend事件。当删除display过渡属性，保留背景颜色、宽、高和transform这四个过渡属性，就会触发transitionend事件四次。如果过渡属性指定的是padding，即同时过渡padding-left\\top\\right\\bottom这四个属性，transitionend事件会触发四次。因此例如padding，margin，border之类的属性，用transitionend事件会有多次捕获的情况发生。 5、auto过渡通常我们属性过渡时，都是定值到定值的过渡，例如width:100px过渡到200px。但要过渡到width:auto就不行了。就算你指定transition:width 1s;会发现不会有1秒的过渡效果，而是会瞬间完成过渡。可以将width瞬间置为auto，使用window.getComputedStyle()获得当前width的数值，然后将width置回100px。再用事件触发改变width。可以看到过渡过程，代码如下： 12345678910111213(function()&#123; const box = document.getElementsByClassName(\"box\")[0]; box.style.width = \"auto\"; let auto_width = window.getComputedStyle(box, null).getPropertyValue(\"width\"); box.style.width = \"200px\"; setTimeout(transition, 2000); function transition()&#123; box.style.width = auto_width; &#125;; box.addEventListener(\"transitionend\", function()&#123; console.log('transitionend'); &#125;, false);&#125;)() 参考：CSS3 transition介绍CSS3 transition MDNCSS3 transition W3C","tags":[]},{"title":"删除二叉搜索树的节点","date":"2017-10-11T07:43:54.000Z","path":"2017/10/11/删除二叉搜索树的节点/","text":"总结了一下删除二叉搜索树节点的迭代和递归方法。 1、二叉搜索树二叉搜索树的重要性质：（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）左、右子树也分别为二叉搜索树； 2、删除二叉搜索树的节点删除二叉搜索树的节点有三种情况。（1）删除节点没有子节点；（2）删除节点只有一个子节点；（3）删除节点有两个子节点。如下是一棵二叉搜索树： 第一种情况，比如删除节点4，只要把当前节点4直接删除即可。第二种情况，比如删除节点5，只要把节点5的左子树挂到节点5的父节点上。第三种情况，比如删除节点3，我们要在节点3的右子树中找到大于3的最小节点，在这儿是节点4。然后用找到的最小节点4赋值给节点3，最后再删掉节点4即可。下面使用迭代和递归两种方法来解决问题。 2.1、迭代deleteNode函数主要找到删除节点的位置。其中node是要删除的节点，pre是删除节点的父节点。del函数是删除节点函数。分为三种情况：（1）要删除的节点没有子节点时，就返回null；（2）要删除的该节点只有左子树或只有右子树时，就返回要删除节点的左子树或右子树；（3）要删除节点有两个子节点时，就要将删除节点右子树中的最小值赋值给要删除节点，然后删去最小节点。这里还有两种情况要讨论，这部分代码如下： 123456789let pre = node;let cur = node.right;while(cur.left)&#123; pre = cur; cur = cur.left;&#125;node.val = cur.val;console.log(pre.left);pre === node ? pre.right = cur.right : pre.left = cur.right; 这段代码中cur是找到的最小节点，node是要删除节点，pre是最小节点的父节点。因为最后要删去cur所以，还是需要记录它的父节点pre。如果是删除下图中的根节点6，此时pre===node。 123if(pre===node)&#123; pre.right=cur.right;&#125; 如果是删除下图中的节点3，那么pre是节点5。 123if(pre !== node)&#123; pre.left = cur.right;&#125; 完整代码和注释如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var deleteNode = function(root, key) &#123; let node=root; let pre=null; //找到要删除节点node while(node!==null)&#123; if(node.val===key)&#123; break; &#125; pre=node; if(node.val&gt;key)&#123; node=node.left; &#125;else&#123; node=node.right; &#125; &#125; //没有找到删除节点的情况 if(node===null)&#123; return root; &#125; //pre是当前节点的父节点，这个是删除头结点的情况 if(pre===null)&#123; return del(node); &#125; //删除pre的左节点或者右节点 if(pre.left&amp;&amp;pre.left.val===key)&#123; pre.left=del(node); &#125;else if (pre.right&amp;&amp;pre.right.val===key)&#123; pre.right=del(node); &#125; return root;&#125;;function del(node)&#123; //当要删除的该节点没有左右子树 if(node.left===null&amp;&amp;node.right===null)&#123; return null; &#125; //当要删除的该节点只有左子树或只有右子树 if (!node.left || !node.right) &#123; return (node.left) ? node.left : node.right; &#125; //左右子树都有 let pre=node; let cur=node.right; while(cur.left)&#123; pre=cur; cur=cur.left; &#125; node.val=cur.val; console.log(pre.left); pre===node?pre.right=cur.right:pre.left=cur.right; return node;&#125; 2.2、递归先判断根节点是否为空；然后开始寻找二叉搜索树中key的位置，如果当前节点的值比key大则去找当前节点的左子树，小则找右子树，直到找到与key值相同的节点；接着判断节点子树的个数，分为节点至多只有一个子树，和有两个子树这两种情况；代码如下： 1234567891011121314151617181920212223var deleteNode = function(root, key) &#123; if(root===null)&#123; return null; &#125; if(root.val&gt;key)&#123; root.left=deleteNode(root.left,key); &#125; else if(root.val&lt;key)&#123; root.right = deleteNode(root.right,key); &#125; else&#123; //找到key的位置root，当root至多只有一个子树 if(!root.left||!root.right)&#123; root=root.left?root.left:root.right; &#125;else&#123; let cur=root.right; while(cur.left)&#123; cur=cur.left; &#125; root.val=cur.val; root.right=deleteNode(root.right,cur.val); &#125; &#125; return root;&#125;;","tags":[]},{"title":"二叉树的广度和深度优先遍历（先序、中序、后序）","date":"2017-10-04T07:45:11.000Z","path":"2017/10/04/二叉树的广度和深度优先遍历（先序、中序、后序）/","text":"总结了一下二叉树的广度优先遍历、深度优先遍历的递归和非递归实现方式。 二叉树的遍历方式： 1、广度优先按照树的深度，一层一层的访问树的节点 2、深度优先： 1)先序遍历：先访问根节点，再依次访问左子树和右子树 2)中序遍历：先访问左子树，再访问根节点吗，最后访问右子树 3)后序遍历：先访问左子树，再访问右子树，最后访问根节点 1、广度优先遍历 图1是一个二叉树，使用广度优先遍历的顺序应该是1、2、3、4、5、6。思路是定义一个队列，先将root节点push进去作为初始值，并计算当前层所包含的节点数，root层就为1，将root从列表最前面弹出，然后访问root的left和right，将访问到的节点存入列表中。此时root层遍历结束，列表中存储的是下一层的所有节点，计算当前层所包含的节点数，然后从列表中依次弹出当前层的每个节点，并且访问每个节点的left和right节点，再存入列表中。代码如下： 123456789101112131415161718var BFS = function(root) &#123; let a=[]; let tmp; if(root===null)&#123; return 0; &#125; a.push(root); let count; while(a.length!==0)&#123; count=a.length; while(count)&#123; tmp=a.shift(); if(tmp.left!==null)&#123;a.push(tmp.left);&#125; if(tmp.right!==null)&#123;a.push(tmp.right);&#125; count--; &#125; &#125;&#125;; 2、深度优先遍历深度优先遍历分为先序遍历、中序遍历和后序遍历。下面每种遍历方式都会使用递归和迭代两种方法。 2.1 先序遍历图1的二叉树使用深度优先遍历的结果是1、2、4、5、3、6。迭代的思路是定义一个栈，先将root节点push进去作为初始值，检测栈是否为空，不为空，则弹出最上面的元素将其输出，然后如果该元素有左右节点则，先将右节点入栈，再将左节点入栈。代码如下： 12345678910111213141516var DFS= function(root) &#123; let stack=[]; if(root!==null)&#123; stack.push(root) while(stack.length!==0)&#123; let top = stack.pop(); console.log(top.val); if(top.right!==null)&#123; stack.push(top.right); &#125; if(top.left!==null)&#123; stack.push(top.left); &#125; &#125; &#125;&#125;; 递归的代码如下： 1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function(root) &#123; let result=[]; DFS(root, result); return result;&#125;;function DFS(root,result)&#123; if(root)&#123; result.push(root.val); DFS(root.left,result); DFS(root.right,result); &#125;&#125; 2.2 中序遍历图1的二叉树使用中序遍历的结果是4、2、5、1、3、6。迭代的思路是定义一个栈，先将当前节点的所有左侧子结点压入栈，直到指针指向空，然后再一个一个弹出栈中的节点并访问当前节点的右节点（对右节点也是将每个子节点进行入栈）。代码如下： 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function(root) &#123; let stash=[]; let result=[]; while(stash.length||root)&#123; if(root)&#123; stash.push(root); root=root.left; &#125;else&#123; root = stash.pop(); result.push(root.val); root=root.right; &#125; &#125; return result;&#125;; 递归的代码如下： 1234567var DFS = function(root) &#123; if(root!==null)&#123; DFS (root.left); console.log(root.val); DFS (root.right); &#125;&#125;; 2.3 后序遍历图1的二叉树使用后序遍历的结果是4、5、2、6、3、1。迭代思路是定义一个栈，先将当前节点的所有左侧子结点压入栈，现在要保证在访问当前节点的右子结点之后才能访问当前节点。所以每次从栈中拿出左侧节点时，都需要判断该节点的右子树是否存在或右子树是否被访问过，这里使用了一个preNode来记录刚被访问过的节点，这样就可以实现只有当前节点的右子结点访问完成，才能访问当前节点。代码如下： 1234567891011121314151617181920212223242526var DFS = function(root) &#123; let stack=[]; let node=root; let preNode=null; while(node!==null||stack.length!==0)&#123; //所有左侧子结点压入栈 while(node!==null)&#123; stack.push(node); node=node.left; &#125; if(stack.length!==0)&#123; let tmp = stack[stack.length-1].right; // 一个根节点被访问的前提是：无右子树或右子树已被访问过 if(tmp===null||tmp===preNode)&#123; node=stack.pop(); console.log(node.val); // 记录刚被访问过的节点 preNode=node; node=null; &#125;else&#123; // 处理右子树 node=tmp; &#125; &#125; &#125;&#125;; 递归的代码如下： 1234567var DFS = function(root) &#123; if(root!==null)&#123; DFS (root.left); DFS (root.right); console.log(root.val); &#125;&#125;;","tags":[]},{"title":"css布局","date":"2017-09-24T06:23:18.000Z","path":"2017/09/24/css布局之双飞翼和圣杯布局/","text":"1、float&amp;clearclear属性一般是在清除浮动元素中设置，下面以clear：left为例。当浮动元素先于清除浮动元素，且清除浮动元素设置为clear：left，则浮动元素不允许在清除浮动元素的左侧出现，所以清除浮动元素必须移到浮动元素的下面。(清除浮动元素可能是浮动元素也可能不是) 2、双飞翼布局&amp;圣杯布局圣杯布局的来历是2006年发在a list part上的这篇文章：In Search of the Holy Grail · An A List Apart Article。圣杯是西方表达“渴求之物”的意思，不是一种对页面的形象表达。双飞翼据考源自淘宝UED，应该是一种页面的形象的表达。圣杯布局和双飞翼布局解决的问题是一样的，就是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。圣杯布局，为了中间div内容不被遮挡，在外部container设置左右padding，再对左右栏进行相对定位，拉到两边。感觉比圣杯布局思路更直接和简洁一点。简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“。来源：知乎 3、双飞翼布局html代码如下，可以看到中间div要在放在文档流前面以优先渲染，而且为了中间div内容不被遮挡，在中间div内创建一个子div用于存放内容。 12345678910&lt;div id=\"container\"&gt; &lt;div id=\"center\"&gt; &lt;div class=\"main-wrap\"&gt; 我是主列，出来吧！ &lt;/div&gt; &lt;/div&gt; &lt;div id=\"left\"&gt;我是子列&lt;/div&gt; &lt;div id=\"right\"&gt;我是附加列&lt;/div&gt; &lt;div class=\"clearfix\" id=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt; css代码如下： 123456789101112131415161718192021222324252627/* 双飞翼 */#center&#123; float:left; width:100%; min-height:30px; background-color: #F08383; /*粉色*/&#125;#center .main-wrap&#123; margin-left:90px; /*与col-sub产生10像素距离*/ margin-right:90px; /*与col-extra产生10像素距离*/ background-color: #a9a9a9; /*灰色*/ min-height:30px;&#125;#left&#123; float:left; width:80px; min-height:30px; background-color: rgb(38, 170, 12);/*绿色*/ margin-left:-100%;&#125;#right&#123; float:left; width:80px; min-height:30px; background-color: rgb(231, 188, 47);/*黄色*/ margin-left:-80px;&#125; 可以看到三栏全部float，中间宽度100%，两边通过margin-left负值移动到指定位置，左栏设置margin-left:-100%将其移动到中间栏的最左位置，右栏通过margin-left:-80px移动自身宽度的位置到中间栏的最右位置。如果将代码中#center .main-wrap注释掉，则结果如图所示： 此时中间div被左边div挡住，所以添加子div的目的是设置margin-left和margin-right使其与左右栏保持距离。最终结果如图所示： 4、圣杯布局html代码如下，可以看到与双飞翼的差别在于没有在中间div设置子div元素。 12345678&lt;div id=\"container\"&gt; &lt;div id=\"center\"&gt; 我是主列，出来吧！ &lt;/div&gt; &lt;div id=\"left\"&gt;我是左列&lt;/div&gt; &lt;div id=\"right\"&gt;我是右列&lt;/div&gt; &lt;div class=\"clearfix\" id=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt; css代码如下： 1234567891011121314151617181920212223242526272829#container&#123; padding-left:80px; padding-right:80px;&#125;#center&#123; position: relative; float:left; width:100%; min-height:30px; background-color: #F08383;&#125;#left&#123; position: relative; float:left; width:80px; margin-left:-100%; left:-80px; min-height:30px; background-color: rgb(38, 170, 12);&#125;#right&#123; position: relative; float:left; width:80px; margin-left:-80px; right:-80px; min-height:30px; background-color: rgb(231, 188, 47);&#125; 可以看到在解决”中间栏div内容不被遮挡“问题上，圣杯使用的是在container上设置左右padding，此时左右栏会和中间栏一起被拉回来，所以就对left使用相对定位 left:-80px 同理，right也要相对定位还原 right:-80px。 4、普通的三栏布局这里所讲的三栏布局是两边定宽，中间自适应的三栏布局，中间栏不需要在放在文档流前面的情况，这种情况很简单，代码如下： 1234567891011121314151617181920212223#container:after&#123; content: ''; display: block; clear: both;&#125;#left&#123; float: left; width: 80px; min-height:30px; background-color: rgb(38, 170, 12);&#125;#right&#123; float: right; width: 80px; min-height:30px; background-color:rgb(231, 188, 47);&#125;#center&#123; margin-right: 100px; margin-left: 100px; min-height:30px; background-color: #F08383;&#125; 5、使用float+BFC实现三栏布局在BFC中有一个特性： BFC的区域不会与float box重叠。 利用这个特性，不需要左右定宽，也能实现三栏布局，代码如下所示，可以看到center中设置了overflow: hidden;，使center成为了一个BFC容器。 详细的原理张鑫旭在CSS深入理解流体特性和BFC特性下多栏自适应布局中有深刻的讨论。 123456789101112131415161718192021222324#container:after&#123; content: ''; display: block; clear: both;&#125;#left&#123; float: left; width: 80px; min-height:30px; margin-right: 20px; background-color: rgb(38, 170, 12);&#125;#right&#123; float: right; width: 80px; min-height:30px; margin-left: 20px; background-color:rgb(231, 188, 47);&#125;#center&#123; min-height:30px; background-color: #F08383; overflow: hidden;&#125;","tags":[]},{"title":"UI组件之浮出层","date":"2017-09-21T14:25:59.000Z","path":"2017/09/21/UI组件之浮出层/","text":"UI组件之浮出层 这是2017年百度前端学院的一道题，要求做出一个如图所示的浮出层。 以下是浮出层的html代码。 12345678910111213141516171819&lt;div class=\"modal\"&gt; &lt;div class=\"modal-dialog\" draggable=\"true\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"close\"&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle e-resize\"&gt;&lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle n-resize\"&gt;&lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle w-resize\"&gt;&lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle s-resize\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对外提供了一些可以用来定制浮出层的选项。选项表如下： 选项名称 选项默认值 选项描述 size size:{ width: ‘600px’, height: ‘138px’} 允许自定义浮出层的宽高。 resizeable resizeable: true 允许通过拖拽浮出层的一边来改变大小 dragable dragable: true 允许通过拖拽来改变浮出层的位置 keyboard keyboard: true 当按下 escape 键时关闭浮出层，设置为 false 时则按键无效。 backdrop backdrop: true 指定一个静态的背景，当用户点击模态框外部时不会关闭模态框。 open open: null 指定打开浮出层时的回调函数。 beforeClose beforeClose: null 指定关闭浮出层之前的回调函数。 close close: null 指定关闭浮出层的回调函数。 除了这八个选项，还提供了show和hide两个方法。 方法 描述 实例 show 打开弹出层 let modal=new ModalFunc(options); modal.show(); hide 关闭弹出层 let modal=new ModalFunc(options); modal.hide(); 接下来聊一聊我在实现过程中遇到的问题和收获。 1、创建自定义类型在这里创建了一个ModalFunc的自定义类型，采用的方式是组合使用构造函数与原型模式。基本代码如下。 123456789let ModalFunc = function(elem, opts)&#123; this.element = elem; this.options = &#123;&#125;;&#125;;ModalFunc.prototype = &#123; setConfig: function()&#123;&#125;， show:function()&#123;&#125;, hide:function()&#123;&#125;&#125; 这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。 2、提供定制浮出层的选项在ModalFunc构造函数中初始化options属性，options的值来源于用户定义或默认值。如下是在ModalFunc构造函数中初始化options属性的代码。_default_options是options的默认值，opts是用户定义的值。 1234567891011121314151617181920212223242526//定义options默认值const _default_options = &#123; size:&#123; width: '600px', height: '138px' &#125;, resizeable: true, dragable: true, //当按下 escape 键时关闭浮出层，设置为 false 时则按键无效。 keyboard: true, //当用户点击浮出层外部是否会关闭浮出层。 backdrop: true, // open回调 open: null, // close回调 close: null, beforeClose: null&#125;this.options = &#123;&#125;;if (opts === undefined) &#123; this.options = _default_options;&#125; else &#123; for (let key in _default_options) &#123; this.options[key] = opts[key]!==null ? opts[key] : _default_options[key]; &#125;&#125; 用户是在使用浮出层的页面中new一个ModalFunc的对象，并且传入element和options两个参数。如下代码所示： 1234567891011121314151617181920212223let modal=new ModalFunc(myModal,&#123; size:&#123; width:\"500px\", height:'138px' &#125;, keyboard:true, resizeable: true, dragable: true, backdrop:true, open: () =&gt; &#123; console.log('浮出层打开'); &#125;, beforeClose: (done) =&gt; &#123; if (confirm('before close')) &#123; done(); &#125; else &#123; console.log('close failed by before close callback.'); &#125; &#125;, close: () =&gt; &#123; console.log('浮出层关闭') &#125;&#125;); 3、实现keyboard选项keyboard选项控制当按下 escape 键时关闭浮出层，当设置为 false 则按键无效。这里我遇上的问题是如何在不人为调整焦点的情况下，当浮出层弹出，焦点自动处于其上。解决方法是在使用show方法打开浮出层的时候，添加如下代码： 12this.element.setAttribute('tabindex', 0);this.element.focus(); this.element是指modal元素。这样当打开浮出层，焦点就在浮出层上。 4、实现backdrop选项backdrop选项控制用户点击浮出层外部时是否关闭浮出层。当设置true则关闭。这里我遇上的问题是如何实现点击阴影背景可关闭，但点击弹框不可关闭。解决方法是在modal-dialog元素上设置event.stopPropagation();从而阻止冒泡进一步传播到modal元素上。代码如下： 123456789if(this.options.backdrop)&#123; const dialog = document.getElementsByClassName(\"modal-dialog\"); dialog[0].addEventListener(\"click\",(event)=&gt;&#123; event.stopPropagation(); &#125;,false); this.element.addEventListener(\"click\",(e)=&gt;&#123; this.hide(); &#125;,false);&#125; 5、实现dragable选项插件中的dragable选项控制浮出层是否可以拖拽。想要实现的效果是用鼠标点击浮出层然后在页面内拖动，最终放开鼠标，浮出层就处于放开最后一刻的位置。在写浮出层的拖拽时，modal-dialog需要定位浮出层在drag过程中的位置，这里使用绝对定位。top和left设置为0，然后使用js使浮出层居中。这里使用了html5原生的drag和drop事件。制作可拖动对象非常简单。在要设为可移动的元素上设置 draggable=”true” 属性，再设置dragstart事件监听。 1234this.element.addEventListener('dragstart',(event) =&gt; &#123; dragOffset.x = event.offsetX; dragOffset.y = event.offsetY;&#125;,false); 在drag事件中只要计算出模态框left和top的值，就能进行定位，代码如下所示。 1234567891011this.element.addEventListener('drag',(event) =&gt; &#123; event.preventDefault(); if(event.clientX - dragOffset.x&lt;0)&#123; dialog[0].style.left = '0px'; &#125;else if(event.clientY - dragOffset.y&lt;0)&#123; dialog[0].style.top = '0px'; &#125;else&#123; dialog[0].style.left = (event.clientX - dragOffset.x ) + 'px'; dialog[0].style.top = (event.clientY - dragOffset.y ) + 'px'; &#125;&#125;,false); 在drag事件中有一些和位置有关的属性可以帮助定位：event.clientX和event.clientY，这两个值是当前鼠标焦点到页面最左上角，两个坐标之间的X和Y。除了这两个值，我们还需要鼠标焦点到对话框最左上角的距离，这个值可以通过dragstart事件event.offsetX和event.offsetY获取。如图所示： 在dragenter和dragover事件期间调用preventDefault（）方法将指示在该位置允许放置。 1234this.element.addEventListener(\"dragover\", function(event) &#123; // prevent default to allow drop event.preventDefault();&#125;, false); 但是令我困惑的是，未定义dragend事件，浮出层依然可以被放置到正确位置。 6、实现resizeable选项插件中的resizeable选项实现了横向或纵向拖动浮出层的边框可以改变浮出层的宽度或高度。实现参考了jquery-ui的缩放功能。在浮出层的html结构上加了四条透明边框线（为了显示效果加了颜色），如图： 然后分别对这四条边进行drag&amp;drop事件监听。下面以左边为例，只要计算出当前模态框宽度、left和top值就可以实现左边的拖拽。 12345678910111213141516171819202122w_resize[0].addEventListener('dragstart',(event) =&gt; &#123; dialogWidth = parseInt(dialogContent[0].style.width); clientX = event.clientX; dragOffset.x = event.offsetX; dragOffset.y = event.offsetY;&#125;,false);w_resize[0].addEventListener('drag',(event) =&gt; &#123; event.stopPropagation(); dialogContent[0].style.width = (dialogWidth - (event.clientX - clientX)) + 'px'; if(event.clientX - dragOffset.x&lt;0)&#123; dialog[0].style.left = '0px'; &#125;else if(event.clientY - dragOffset.y&lt;0)&#123; dialog[0].style.top = '0px'; &#125;else&#123; dialog[0].style.left = (event.clientX - dragOffset.x ) + 'px'; dialog[0].style.top = (event.clientY - dragOffset.y ) + 'px'; &#125;&#125;,false);w_resize[0].addEventListener(\"dragover\", function(event) &#123; // prevent default to allow drop event.preventDefault();&#125;, false);","tags":[]}]