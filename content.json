[{"title":"CSS3 transition","date":"2018-10-27T12:42:21.000Z","path":"2018/10/27/transition/","text":"transition是过渡的意思，可想而知transition属性让元素的一个或一些属性值随着时间的推移从旧状态向新动态过渡。 1、transition的子属性transition有一些子属性来定义元素属性的过渡细节。transition-property属性指定应用了过渡的CSS属性，并不是所有属性都能过渡，在第二节中会详细介绍。除了指定单个属性，还可以设为all。transition-duration属性指定了过渡过程的时长。transition-timing-function属性描述如何计算在过渡过程中使用的中间值。它允许在其持续时间内改变速度。这些效应通常称为缓和函数，有linear，ease，ease-in，ease-out，ease-in-out，cubic-bezier(n,n,n,n)，steps。其实它们都是贝赛尔曲线。如下图所示。 看贝赛尔曲线就知道了，linear是匀速过渡，ease是先快再慢的节奏，ease-in是加速冲刺的节奏，ease-out是减速到停止的节奏，ease-in-out是先加速后减速的节奏。transition-delay属性定义过渡经过一段延迟时间后开始。对于缩写的transition可以包含上面的四项： &lt;single-transition&gt; = [ none | &lt;single-transition-property&gt; ] || &lt;time&gt; || &lt;single-transition-timing-function&gt; || &lt;time&gt; ||代表各部分至少出现一个，可以不按顺序；[ ]强调优先级，即transition-property要放在第一位。有两个time第一个设置的time代表transition-duration，第二个设置的time代表transition-delay。 2、可以transition的属性在transition中，transition-property指定CSS过渡属性。并不是所有属性都能过渡的，只有能数字量化的CSS属性才能过渡。哪些属于能数字量化的CSS属性呢？例如：颜色系：color，background-color，border-color，outline-color等数字系：实在太多了，如width，height，top，right，bottom，left，zoom，opacity，line-height，background-position，word-spacing，font-weight，vertical-align，outline-outset，z-index等。01系：如visibility（0表示隐藏，1表示显示）。 W3C上有可过渡属性一览表Properties from CSS。通常只要能设数字（包括百分比）的属性都能过渡。 3、transition触发那么transition是何时触发的？transition用于定义一个元素在两个状态之间的过渡：css伪类比如:hover、:active可以标识两个状态，在元素上定义transition属性和transition-property指定的属性，然后在元素:hover上改变transition-property指定属性的状态;或者动态的使用js来改变该元素应用了过渡的属性；还有例如@media媒体查询，根据设备大小，横屏竖屏切换时触发。比如mdn上的一个例子，使用:hover来触发过渡： 123&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/body&gt; 123456789101112131415161718.box &#123; border-style: solid; border-width: 1px; display: block; width: 100px; height: 100px; background-color: #0000FF; -webkit-transition:width 2s, height 2s, background-color 2s, -webkit-transform 2s; transition:width 2s, height 2s, background-color 2s, transform 2s;&#125;.box:hover &#123; background-color: #FFCCCC; width:200px; height:200px; -webkit-transform:rotate(180deg); transform:rotate(180deg);&#125; 或者改成使用js改变元素属性，html代码和上面一样。 12345678910.box &#123; border-style: solid; border-width: 1px; display: block; width: 100px; height: 100px; background-color: #0000FF; -webkit-transition: width 2s, height 2s, background-color 2s, -webkit-transform 2s, display 2s; transition: width 2s, height 2s, background-color 2s, transform 2s, display 2s; &#125; 12345678910(function()&#123; const box = document.getElementsByClassName(\"box\")[0]; setTimeout(transition, 2000); function transition()&#123; box.style.backgroundColor = \"#FFCCCC\"; box.style.width = \"200px\"; box.style.height = \"200px\"; box.style.transform = \"rotate(180deg)\"; &#125;;&#125;)() 4、transitionend事件当过渡结束会触发transitionend事件。但如果一个transition在完成之前就被移除（定义transition属性的元素被删除，比如transition的过渡属性display从block到none），那么transitionend事件不会被触发。比如对上面第二个例子进行改进，监听transitionend事件： 1234567891011121314(function()&#123; const box = document.getElementsByClassName(\"box\")[0]; setTimeout(transition, 2000); function transition()&#123; box.style.backgroundColor = \"#FFCCCC\"; box.style.width = \"200px\"; box.style.height = \"200px\"; box.style.transform = \"rotate(180deg)\"; box.style.display = \"none\"; &#125;; box.addEventListener(\"transitionend\", function()&#123; console.log('transitionend'); &#125;, false);&#125;)() 会发现，对display属性进行由block到none的过渡就不会触发transitionend事件。当删除display过渡属性，保留背景颜色、宽、高和transform这四个过渡属性，就会触发transitionend事件四次。如果过渡属性指定的是padding，即同时过渡padding-left\\top\\right\\bottom这四个属性，transitionend事件会触发四次。因此例如padding，margin，border之类的属性，用transitionend事件会有多次捕获的情况发生。 5、auto过渡通常我们属性过渡时，都是定值到定值的过渡，例如width:100px过渡到200px。但要过渡到width:auto就不行了。就算你指定transition:width 1s;会发现不会有1秒的过渡效果，而是会瞬间完成过渡。可以将width瞬间置为auto，使用window.getComputedStyle()获得当前width的数值，然后将width置回100px。再用事件触发改变width。可以看到过渡过程，代码如下： 12345678910111213(function()&#123; const box = document.getElementsByClassName(\"box\")[0]; box.style.width = \"auto\"; let auto_width = window.getComputedStyle(box, null).getPropertyValue(\"width\"); box.style.width = \"200px\"; setTimeout(transition, 2000); function transition()&#123; box.style.width = auto_width; &#125;; box.addEventListener(\"transitionend\", function()&#123; console.log('transitionend'); &#125;, false);&#125;)() 参考：CSS3 transition介绍CSS3 transition MDNCSS3 transition W3C","tags":[]},{"title":"删除二叉搜索树的节点","date":"2018-10-11T07:43:54.000Z","path":"2018/10/11/删除二叉搜索树的节点/","text":"总结了一下删除二叉搜索树节点的迭代和递归方法。 1、二叉搜索树二叉搜索树的重要性质：（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）左、右子树也分别为二叉搜索树； 2、删除二叉搜索树的节点删除二叉搜索树的节点有三种情况。（1）删除节点没有子节点；（2）删除节点只有一个子节点；（3）删除节点有两个子节点。如下是一棵二叉搜索树： 第一种情况，比如删除节点4，只要把当前节点4直接删除即可。第二种情况，比如删除节点5，只要把节点5的左子树挂到节点5的父节点上。第三种情况，比如删除节点3，我们要在节点3的右子树中找到大于3的最小节点，在这儿是节点4。然后用找到的最小节点4赋值给节点3，最后再删掉节点4即可。下面使用迭代和递归两种方法来解决问题。 2.1、迭代deleteNode函数主要找到删除节点的位置。其中node是要删除的节点，pre是删除节点的父节点。del函数是删除节点函数。分为三种情况：（1）要删除的节点没有子节点时，就返回null；（2）要删除的该节点只有左子树或只有右子树时，就返回要删除节点的左子树或右子树；（3）要删除节点有两个子节点时，就要将删除节点右子树中的最小值赋值给要删除节点，然后删去最小节点。这里还有两种情况要讨论，这部分代码如下： 123456789let pre = node;let cur = node.right;while(cur.left)&#123; pre = cur; cur = cur.left;&#125;node.val = cur.val;console.log(pre.left);pre === node ? pre.right = cur.right : pre.left = cur.right; 这段代码中cur是找到的最小节点，node是要删除节点，pre是最小节点的父节点。因为最后要删去cur所以，还是需要记录它的父节点pre。如果是删除下图中的根节点6，此时pre===node。 123if(pre===node)&#123; pre.right=cur.right;&#125; 如果是删除下图中的节点3，那么pre是节点5。 123if(pre !== node)&#123; pre.left = cur.right;&#125; 完整代码和注释如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var deleteNode = function(root, key) &#123; let node=root; let pre=null; //找到要删除节点node while(node!==null)&#123; if(node.val===key)&#123; break; &#125; pre=node; if(node.val&gt;key)&#123; node=node.left; &#125;else&#123; node=node.right; &#125; &#125; //没有找到删除节点的情况 if(node===null)&#123; return root; &#125; //pre是当前节点的父节点，这个是删除头结点的情况 if(pre===null)&#123; return del(node); &#125; //删除pre的左节点或者右节点 if(pre.left&amp;&amp;pre.left.val===key)&#123; pre.left=del(node); &#125;else if (pre.right&amp;&amp;pre.right.val===key)&#123; pre.right=del(node); &#125; return root;&#125;;function del(node)&#123; //当要删除的该节点没有左右子树 if(node.left===null&amp;&amp;node.right===null)&#123; return null; &#125; //当要删除的该节点只有左子树或只有右子树 if (!node.left || !node.right) &#123; return (node.left) ? node.left : node.right; &#125; //左右子树都有 let pre=node; let cur=node.right; while(cur.left)&#123; pre=cur; cur=cur.left; &#125; node.val=cur.val; console.log(pre.left); pre===node?pre.right=cur.right:pre.left=cur.right; return node;&#125; 2.2、递归先判断根节点是否为空；然后开始寻找二叉搜索树中key的位置，如果当前节点的值比key大则去找当前节点的左子树，小则找右子树，直到找到与key值相同的节点；接着判断节点子树的个数，分为节点至多只有一个子树，和有两个子树这两种情况；代码如下： 1234567891011121314151617181920212223var deleteNode = function(root, key) &#123; if(root===null)&#123; return null; &#125; if(root.val&gt;key)&#123; root.left=deleteNode(root.left,key); &#125; else if(root.val&lt;key)&#123; root.right = deleteNode(root.right,key); &#125; else&#123; //找到key的位置root，当root至多只有一个子树 if(!root.left||!root.right)&#123; root=root.left?root.left:root.right; &#125;else&#123; let cur=root.right; while(cur.left)&#123; cur=cur.left; &#125; root.val=cur.val; root.right=deleteNode(root.right,cur.val); &#125; &#125; return root;&#125;;","tags":[]},{"title":"二叉树的广度和深度优先遍历（先序、中序、后序）","date":"2018-10-04T07:45:11.000Z","path":"2018/10/04/二叉树的广度和深度优先遍历（先序、中序、后序）/","text":"总结了一下二叉树的广度优先遍历、深度优先遍历的递归和非递归实现方式。 二叉树的遍历方式： 1、广度优先按照树的深度，一层一层的访问树的节点 2、深度优先： 1)先序遍历：先访问根节点，再依次访问左子树和右子树 2)中序遍历：先访问左子树，再访问根节点吗，最后访问右子树 3)后序遍历：先访问左子树，再访问右子树，最后访问根节点 1、广度优先遍历 图1是一个二叉树，使用广度优先遍历的顺序应该是1、2、3、4、5、6。思路是定义一个队列，先将root节点push进去作为初始值，并计算当前层所包含的节点数，root层就为1，将root从列表最前面弹出，然后访问root的left和right，将访问到的节点存入列表中。此时root层遍历结束，列表中存储的是下一层的所有节点，计算当前层所包含的节点数，然后从列表中依次弹出当前层的每个节点，并且访问每个节点的left和right节点，再存入列表中。代码如下： 123456789101112131415161718var BFS = function(root) &#123; let a=[]; let tmp; if(root===null)&#123; return 0; &#125; a.push(root); let count; while(a.length!==0)&#123; count=a.length; while(count)&#123; tmp=a.shift(); if(tmp.left!==null)&#123;a.push(tmp.left);&#125; if(tmp.right!==null)&#123;a.push(tmp.right);&#125; count--; &#125; &#125;&#125;; 2、深度优先遍历深度优先遍历分为先序遍历、中序遍历和后序遍历。下面每种遍历方式都会使用递归和迭代两种方法。 2.1 先序遍历图1的二叉树使用深度优先遍历的结果是1、2、4、5、3、6。迭代的思路是定义一个栈，先将root节点push进去作为初始值，检测栈是否为空，不为空，则弹出最上面的元素将其输出，然后如果该元素有左右节点则，先将右节点入栈，再将左节点入栈。代码如下： 12345678910111213141516var DFS= function(root) &#123; let stack=[]; if(root!==null)&#123; stack.push(root) while(stack.length!==0)&#123; let top = stack.pop(); console.log(top.val); if(top.right!==null)&#123; stack.push(top.right); &#125; if(top.left!==null)&#123; stack.push(top.left); &#125; &#125; &#125;&#125;; 递归的代码如下： 1234567var DFS = function(root) &#123; if(root!==null)&#123; console.log(root.val); DFS (root.left); DFS (root.right); &#125;&#125;; 2.2 中序遍历图1的二叉树使用中序遍历的结果是4、2、5、1、3、6。迭代的思路是定义一个栈，先将当前节点的所有左侧子结点压入栈。然后再访问该节点和它的右子树。代码如下： 1234567var DFS = function(root) &#123; if(root!==null)&#123; DFS (root.left); console.log(root.val); DFS (root.right); &#125;&#125;; 2.3 后序遍历图1的二叉树使用后序遍历的结果是4、5、2、6、3、1。迭代思路是定义一个栈，先将当前节点的所有左侧子结点压入栈，现在要保证在访问当前节点的右子结点之后才能访问当前节点。所以每次从栈中拿出左侧节点时，都需要判断该节点的右子树是否存在或右子树是否被访问过，这里使用了一个preNode来记录刚被访问过的节点，这样就可以实现只有当前节点的右子结点访问完成，才能访问当前节点。代码如下： 1234567891011121314151617181920212223242526var DFS = function(root) &#123; let stack=[]; let node=root; let preNode=null; while(node!==null||stack.length!==0)&#123; //所有左侧子结点压入栈 while(node!==null)&#123; stack.push(node); node=node.left; &#125; if(stack.length!==0)&#123; let tmp = stack[stack.length-1].right; // 一个根节点被访问的前提是：无右子树或右子树已被访问过 if(tmp===null||tmp===preNode)&#123; node=stack.pop(); console.log(node.val); // 记录刚被访问过的节点 preNode=node; node=null; &#125;else&#123; // 处理右子树 node=tmp; &#125; &#125; &#125;&#125;; 递归的代码如下： 1234567var DFS = function(root) &#123; if(root!==null)&#123; DFS (root.left); DFS (root.right); console.log(root.val); &#125;&#125;;","tags":[]},{"title":"css布局之双飞翼和圣杯布局","date":"2018-09-24T06:23:18.000Z","path":"2018/09/24/css布局之双飞翼和圣杯布局/","text":"1、float&amp;clearclear属性一般是在清除浮动元素中设置，下面以clear：left为例。当浮动元素先于清除浮动元素，且清除浮动元素设置为clear：left，则浮动元素不允许在清除浮动元素的左侧出现，所以清除浮动元素必须移到浮动元素的下面。(清除浮动元素可能是浮动元素也可能不是) 2、双飞翼布局&amp;圣杯布局圣杯布局的来历是2006年发在a list part上的这篇文章：In Search of the Holy Grail · An A List Apart Article。圣杯是西方表达“渴求之物”的意思，不是一种对页面的形象表达。双飞翼据考源自淘宝UED，应该是一种页面的形象的表达。圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。圣杯布局，为了中间div内容不被遮挡，在外部container设置左右padding，再对左右栏进行相对定位，拉到两边。感觉比圣杯布局思路更直接和简洁一点。简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“。来源：知乎 3、双飞翼布局html代码如下，可以看到中间div要在放在文档流前面以优先渲染，而且为了中间div内容不被遮挡，在中间div内创建一个子div用于存放内容。 12345678910&lt;div id=\"container\"&gt; &lt;div id=\"center\"&gt; &lt;div class=\"main-wrap\"&gt; 我是主列，出来吧！ &lt;/div&gt; &lt;/div&gt; &lt;div id=\"left\"&gt;我是子列&lt;/div&gt; &lt;div id=\"right\"&gt;我是附加列&lt;/div&gt; &lt;div class=\"clearfix\" id=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt; css代码如下： 123456789101112131415161718192021222324252627/* 双飞翼 */#center&#123; float:left; width:100%; min-height:30px; background-color: #F08383; /*粉色*/&#125;#center .main-wrap&#123; margin-left:90px; /*与col-sub产生10像素距离*/ margin-right:90px; /*与col-extra产生10像素距离*/ background-color: #a9a9a9; /*灰色*/ min-height:30px;&#125;#left&#123; float:left; width:80px; min-height:30px; background-color: rgb(38, 170, 12);/*绿色*/ margin-left:-100%;&#125;#right&#123; float:left; width:80px; min-height:30px; background-color: rgb(231, 188, 47);/*黄色*/ margin-left:-80px;&#125; 可以看到三栏全部float，中间宽度100%，两边通过margin-left负值移动到指定位置，左栏设置margin-left:-100%将其移动到中间栏的最左位置，右栏通过margin-left:-80px移动自身宽度的位置到中间栏的最右位置。如果将代码中#center .main-wrap注释掉，则结果如图所示： 此时中间div被左边div挡住，所以添加子div的目的是设置margin-left和margin-right使其与左右栏保持距离。最终结果如图所示： 4、圣杯布局html代码如下，可以看到与双飞翼的差别在于没有在中间div设置子div元素。 12345678&lt;div id=\"container\"&gt; &lt;div id=\"center\"&gt; 我是主列，出来吧！ &lt;/div&gt; &lt;div id=\"left\"&gt;我是左列&lt;/div&gt; &lt;div id=\"right\"&gt;我是右列&lt;/div&gt; &lt;div class=\"clearfix\" id=\"bottom\"&gt;&lt;/div&gt;&lt;/div&gt; css代码如下： 1234567891011121314151617181920212223242526272829#container&#123; padding-left:80px; padding-right:80px;&#125;#center&#123; position: relative; float:left; width:100%; min-height:30px; background-color: #F08383;&#125;#left&#123; position: relative; float:left; width:80px; margin-left:-100%; left:-80px; min-height:30px; background-color: rgb(38, 170, 12);&#125;#right&#123; position: relative; float:left; width:80px; margin-left:-80px; right:-80px; min-height:30px; background-color: rgb(231, 188, 47);&#125; 可以看到在解决”中间栏div内容不被遮挡“问题上，圣杯使用的是在container上设置左右padding，此时左右栏会和中间栏一起被拉回来，所以就对left使用相对定位 left:-80px 同理，right也要相对定位还原 right:-80px。","tags":[]},{"title":"HTTP缓存","date":"2018-02-07T02:12:33.000Z","path":"2018/02/07/HTTP缓存/","text":"最近在学习HTTP缓存，使用缓存是网站优化的重要步骤。本文是对《HTTP权威指南》第七章缓存的一些摘要和总结。 在商业应用中，使用缓存服务器来提高性能降低对原始服务器的要求。对一条HTTP GET报文的基本缓存处理过程包括7个步骤 ： (1) 接收——缓存从网络中读取抵达的请求报文。(2) 解析——缓存对报文进行解析，提取出 URL 和各种首部。(3) 查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地)。(4) 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。(5) 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。(6) 发送——缓存通过网络将响应发回给客户端。(7) 日志——缓存可选地创建一个日志文件条目来描述这个事务。 这个过程如下图所示： 其中对于新鲜度检测这一步，HTTP协议有两个机制：文档过期和服务器再验证来保持缓存中副本的新鲜度。 1、文档过期通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。 Cache-Control首部和Expires首部告诉客户端到了某个时间点（比照客户端时间点）后本地缓存就过期了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示返回200（强缓存），一旦资源命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。Chrome下的现象是200 OK (from disk cache) 或者 200 OK (from memory cache). 但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果文档被修改过，就要获取一份新鲜(带有新的过期日期)的副本。 服务器用HTTP/1.0+的Expires首部或HTTP/1.1的Cache-Control: max-age响应首部来指定过期日期，同时还会带有响应主体。Expires首部和Cache-Control: max-age首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。 Cache-Control在浏览器缓存中是金字塔顶尖的规则，它会覆盖一切与之相悖的规则。因此当Expires与之相悖时，就会忽略Expires。 2、服务器再验证如果仅仅是Cache-Control首部和Expires首部规定的时间点过期了，那并不意味着它和原始服务器上目前正处于活跃状态的文档有实际区别。 这只是意味着到了要核对的时间了。这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。 客户端检测到数据过期后，会向服务器发送一个get请求。在请求中一般会携带If-Modified-Since或If-None-Match请求头。 先说If-Modified-Since。如果在指定日期之后资源发生了变化，GET请求就会成功执行返回200响应。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。 如果自指定日期后，文档没被修改过，会向客户端返回一个304 Not Modified 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，Content-Type 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。 再说If-None-Match。有些情况下仅使用最后修改日期进行再验证是不够的。 比如： (1) 有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。(2) 再比如有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。(3) 有些服务器无法准确地判定其页面的最后修改日期。(4) 有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。 在这些情况下HTTP允许用户对被称为实体标签(ETag)的“版本标识符” 进行比较。实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。 当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用 If-None-Match 条件首部收到一条200已缓存的成功响应，返回新的内容以及相应的新 Etag。当实体标签没有被修改，就会返回304未修改响应。 如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有实体标签条件首部ETag，那么只有这两个条件都满足时，才能返回 304 Not Modified 响应。 HTTP规范从未指定生成ETag的方法。生成ETag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 3、关于Cache-Control服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以: 附加一个Cache-Control:no-store首部到响应中去; 附加一个Cache-Control:no-cache首部到响应中去; 附加一个Cache-Control:must-revalidate首部到响应中去; 附加一个Cache-Control:max-age首部到响应中去; 附加一个Expires日期首部到响应中去; 不附加过期信息，让缓存确定自己的过期日期。 标识为 no-store 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。 标识为 no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。 我的理解是no-cache是表示max-age=0即立马过期。 Cache-Control: max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数 。 4、关于Expires响应首部不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。 5、当响应中没有Cache-Control: max-age首部，也没有 Expires 首部时如果响应中没有Cache-Control: max-age首部，也没有 Expires 首部，那么使用LM-Factor 算法 的试探性过期算法，用当前时间Date与文档的最后修改时间之差，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。 6、用户操作行为与缓存用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按F5刷新等，这些行为会对缓存有什么影响呢？ 通过上表我们可以看到，当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；而当用户使用Ctrl+F5进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。","tags":[]},{"title":"DOM中外部资源的解析与优化","date":"2018-01-28T14:57:39.000Z","path":"2018/01/28/DOM中外部资源的解析与优化/","text":"DOM中外部资源的解析与优化 浏览器的渲染简介首先下载html、js、css。接着浏览器首先会将html转换成一种他们能够理解的格式DOM，CSS 样式被映射到 CSSOM 上（css对象模型），这两者结合生成render tree。 解析过程中遇到js标签就会下载解析执行。 render tree结束之后进入layout阶段。 layout是指计算每个DOM元素最终在屏幕上显示的大小和位置。遍历顺序为从左至右，从上到下，由于web页面元素布局是相对的，所以任意元素的位置发生变化，都会引起其他元素位置的变化，这就是reflow。 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来的过程称为paint。当元素改变时并且这种改变不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为repaint。 reflow 的成本比 repaint 的成本高得多的多。一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow 。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是延慢加载和耗电的。 DOM中外部资源的解析和优化看到一篇很好的文章，Building the DOM faster: speculative parsing, async, defer and preload。下文是我对这篇文章在原文的基础上加入了自己一些的理解。 js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析在过去为了执行一个脚本，HTML的解析必须暂停。只有在JavaScript引擎执行完代码之后它才会重新开始解析。如果HTML的解析不暂停，脚本可以改变DOM结构，或者脚本可能会需要获取某个DOM节点，如果是在DOM还在构建时获取，可能会返回意外的结果。所以JS阻塞页面的原因是它可以修改DOM节点。 而css会阻塞js脚本的解析，因为js可能会需要样式信息。 因此总结一下：如果在文档中外部样式表放置在脚本之前，DOM 对象和 CSSOM 对象的构建可以互相干扰。 当解析器获取到一个 script 标签，DOM 将无法继续构建直到 JavaScript 执行完毕，而 JavaScript 在 CSS 下载完，解析完，并且 CSSOM 可以使用的时候，才能执行。 虽然css不阻塞DOM的构建，但它会阻塞DOM的渲染。直到DOM和CSSOM都准备好之前，浏览器什么都不会显示。 预解析在以前当解析器遇到一个脚本就意味着如果是引入脚本，先要下载，然后再解析，如图所示。 脚本下载的时间也阻塞HTML的解析，这样非常耗时，那么有没有一种方法能够让脚本下载异步进行呢？ 这种在同步的脚本执行的时候保持文件下载的方法在不同的浏览器有不同的名字，Chrome 和 Safari 称它为 “预扫描器” 而 Firefox 称它为预解析器。 它的概念是：虽然在执行脚本时构建 DOM 是不安全的，但是你仍然可以解析 HTML 来查看其它需要检索的资源。找到的文件会被添加到一个列表里并开始在后台并行地下载。当脚本执行完毕之后，这些文件很可能已经下载完成了。 所以上面那张图在有了预解析器后会变成这样： 以这种方法触发的下载请求称之为“预测”，因为很有可能脚本还是会改变HTML结构（还记得document.write吗？），导致了预测的浪费。虽然这是有可能的，但是却不常见，所以这就是为什么预解析仍然能够带来很大的性能提升。 可以预加载的东西在浏览器之间有所不同，所有的主要的浏览器都会预加载：脚本、外部CSS、来自img标签的图片。 在预解析HTML页面时，浏览器不会执行内联的JS代码块，这意味着它不会发现任何的脚本注入资源，也意味着，如果当我们需要一些不重要的资源晚一点被加载的时候，就可以使用JS来加载这些资源，从而避免预解析。 defer和async虽然通过预解析可以减少加载资源的时间，但是脚本的解析会阻塞页面解析这依然是个问题。其实并不是所有的脚本都一样重要，对于那些不那么重要的脚本可以采用异步加载。defer和async属性就是提供给开发者一个方式来告诉浏览器哪些脚本需要异步加载。这两个属性都告诉浏览器，它可以一边加载脚本一边解析HTML，并在HTML解析完后再执行脚本，这样脚本的加载和执行就不会阻塞页面解析。 Defer和asycn之间的不同就是它们开始执行脚本的时机不同。 Defer会使js脚本的执行在HTML解析完全结束之后开始，在DOMContentLoaded 事件被触发之前执行。它保证脚本会按照它在HTML中出现的顺序执行，并且不会阻塞解析。（当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。） 而设置了async的脚本会在它们加载完后的第一时间执行。这意味着有可能（并且很有可能）设置了async的脚本不会按照它们在HTML中出现的顺序执行。这也意味着他们可能会中断DOM的构建。不过设置了async的脚本的加载有着较低的优先级。他们通常在所有其他脚本加载之后才加载，而不阻塞DOM构建。然而，如果一个指定async的脚本很快就完成了下载，那么它的执行会阻塞DOM构建以及所有在之后才完成下载的同步脚本。 async和defer属性只对外部脚本起作用，如果没有src属性它们会被忽略。 preload作为作者，你知道哪些资源对你的页面渲染来说是最重要的。它们其中一些经常深藏在CSS或者是脚本当中，甚至浏览器需要花上很长一段时间才会发现他们。对于那些重要的资源，你现在可以使用&lt;link rel=&quot;preload&quot;&gt;来告诉浏览器你需要尽快地加载它们。 你只需要写上:&lt;link rel=&quot;preload&quot; href=&quot;very_important.js&quot; as=&quot;script&quot;&gt;，这样你几乎可以链接到任何东西上，并且as属性告诉浏览器要下载的是什么。一些可能的值是：style、script、image、font、audio、video","tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"Promise理解","date":"2018-01-06T13:12:13.000Z","path":"2018/01/06/Promise/","text":"Promise是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，Promise并不是从JavaScript中发祥的概念。 创建一个promise对象要想创建一个Promise对象、可以使用new来调用Promise的构造器来进行实例化。 1234567891011121314const fs = require('fs')function readFile(filename) &#123; return new Promise(function (resolve, reject) &#123; // 异步处理 // 处理结束后、调用resolve 或 reject fs.readFile(filename, &#123;encoding: 'utf8'&#125;, (err, contents) =&gt; &#123; if (err) &#123; reject(err) return &#125; resolve(contents) &#125;) &#125;)&#125; 这段代码中new了一个Promise对象，在这个构造函数中传入的参数是一个执行器，当触发这个执行器的异步操作时，并不会阻塞，而是继续向下执行，直到完成promise对象的创建。然后将这个创建的promise对象return，此时这个promise的状态为pending。 当执行器中的异步操作完成，就会将回调函数放入任务队列中，等到执行该任务时，调用resolve会将promise对象变为resolve（Fulfilled）状态,调用reject会将promise对象变为Rejected状态，此时用then方法来设置resolve后的回调函数， catch 方法来设置发生错误时的回调函数，并将回调函数加入到任务队列末尾：promise.then(onFulfilled, onRejected)。 在resolve(成功)时，onFulfilled 会被调用；reject(失败)时，onRejected 会被调用。resolve和reject会将参数传给onFulfilled和onRejected。onFulfilled、onRejected 两个都为可选参数。 Promise.resolve()和Promise.reject()静态方法Promise.resolve(value) 可以认为是new Promise()方法的快捷方式。比如Promise.resolve(42); 可以认为是以下代码的语法糖。 123new Promise(function(resolve)&#123; resolve(42);&#125;); 在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。 方法 Promise.resolve(value); 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。 123Promise.resolve(42).then(function(value)&#123; console.log(value);&#125;); 在使用Promise.resolve(value) 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 .then 里面指定的方法就是同步调用的呢？实际上， .then 中指定的方法调用是异步进行的。 12345678var promise = new Promise(function (resolve)&#123; console.log(\"inner promise\"); // 1 resolve(42);&#125;);promise.then(function(value)&#123; console.log(value); // 3&#125;);console.log(\"outer promise\"); // 2 promise chain 中传递参数前面例子中的Task都是相互独立的，只是被简单调用而已。这时候如果Task A想给Task B传递一个参数该怎么办呢？答案非常简单，那就是在Task A中return的返回值，会在Task B执行时传给它。 我们还是先来看一个具体例子吧。 123456789101112131415161718function doubleUp(value) &#123; return value * 2;&#125;function increment(value) &#123; return value + 1;&#125;function output(value) &#123; console.log(value);// =&gt; (1 + 1) * 2&#125;var promise = Promise.resolve(1);promise .then(increment) .then(doubleUp) .then(output) .catch(function(error)&#123; // promise chain中出现异常的时候会被调用 console.error(error); &#125;); 每个方法中return的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。 return的值会由Promise.resolve(return的返回值); 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终then的结果都是返回一个新创建的promise对象。也就是说，Promise.then不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个promise对象。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"bind函数","date":"2017-12-28T14:34:08.000Z","path":"2017/12/28/bind函数/","text":"bind函数 简介存在一种情况比如你想要调用某个对象中的方法，并且该方法中会调用这个对象的某个属性，如果直接调用比如： 12345678this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，\"this\"指向全局作用域 可以看到retrieveX中this指向全局，因此如果需要这个this指向module则需要使用bind函数将module.getX的this变成module。bind函数可以实现创建一个新函数，并且制定这个新函数的this值。 12345var retrieveX = module.getX;// 创建一个新函数，将\"this\"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 用法bind的第一个参数是要指定的this对象，其它都是需要传入的参数： 1fun.bind(thisArg[, arg1[, arg2[, …]]]) 当绑定函数被调用时，thisArg参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 解释为了解释“当使用new 操作符调用绑定函数时，该参数无效”这句话，咱们先来归纳一下当使用new操作符来调用函数时，会执行的操作： 创建（或构造）一个全新的对象。 这个新对象会执行[[Prototype]]连接 这个新对象会绑定到函数调用的this 如果这个函数没有返回其它对象，那么new表达式中的函数调用会自动返回这个新对象。 因为使用new会将新对象绑定到函数调用的this，所以指定的this将不起作用，所以这个参数将无效。 bind函数返回由指定的this值和初始化参数改造的原函数拷贝。 bind 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。 polyfill1234567891011121314151617181920212223if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; //oThis是thisArg if (typeof this !== 'function') &#123; //this是调用bind的函数 // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), //aArgs是[arg1,arg2,….] fToBind = this, //this是调用bind的函数(可以想象为slice) fNOP = function() &#123;&#125;, fBound = function() &#123; // bind函数返回一个函数所以fBound return fToBind.apply(this instanceof fNOP ? this: oThis, aArgs.concat(Array.prototype.slice.call(arguments)));// 获取调用时用户向fBound传递的参数.bind 返回的函数入参往往是这么传递的 &#125;; // 维护原型关系 if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound; &#125;;&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"CSS中的BFC","date":"2017-12-08T02:56:24.000Z","path":"2017/12/08/CSS中的BFC/","text":"BFC是块级格式化上下文。它是由于块级元素设置了某些属性而形成的一个独立的区域。在这个区域中，它里面的布局不会影响到外面元素的布局，反之也一样。 创建一个BFC只需要满足下面条件之一就能创建一个BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 BFC的用处使用BFC来防止外边距折叠属于同一个BFC的两个相邻的BOX的margin上下方向会重叠，如果不想让两个Box的margin重叠则可以将这两个Box放在不同的BFC中。 使用BFC来包含浮动在BFC的布局规则中的第六条： 计算BFC的高度时，浮动元素也参与计算。 所以可以将父元素变成一个BFC从而来清除浮动： 1234567891011121314151617181920&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; overflow:hidden; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 或者最常见的方法就是写一个clearfix的类： 12345678.clearfix&#123; *zoom:1;&#125;.clearfix:after&#123; content:\"\"; display:table; clear:both;&#125; 使用BFC来防止文字环绕有时候一个浮动div周围的文字环绕着它，代码如下： 1234&lt;div class=\"container\"&gt; &lt;div class=\"floated\"&gt;Floated div&lt;/div&gt; &lt;p&gt;Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita.&lt;/p&gt; &lt;/div&gt; 但是在某些案例中这并不是可取的，我们想要的是外观跟下图中的右图一样的。 为了解决这个问题，我们可以使用外边距，只要给p设置大于div宽度的margin-left就可以，但是我们也可以使用一个BFC来解决。 在BFC的布局规则中的第一条：BFC的区域不会与float box重叠。因此我们可以将p元素设置成一个BFC：给p元素添加一个overflow: hidden来实现。 在多列布局中使用BFC可以用多种方式解决多列布局，比如圣杯、双飞翼还可以用BFC。比如代码如下： 1234567891011121314151617181920212223242526&lt;style&gt; .left &#123; float: left; height: 200px; width: 100px; margin-right: 20px; background-color: red; &#125; .right &#123; width: 200px; height: 200px; float: right; margin-left: 20px; background-color: blue; &#125; .main &#123; height: 200px; overflow: hidden; background-color: green; &#125;&lt;/style&gt;&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/div&gt; 因为BFC的区域不会与float box重叠，所以将类为main的元素设置为BFC。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"全排列","date":"2017-11-20T08:19:32.000Z","path":"2017/11/20/全排列/","text":"全排列就是将给定序列的所有排列方式找出。 递归解法有重复如下这种方式使用递归，将整组数中的所有的数分别与第一个数交换swap(start,i);，这样就总是在处理后n-1个全排列。 12345678910111213141516171819function perm(list,start,end)&#123; if(start&gt;end)&#123; console.log(list); &#125;else&#123; for(let i=start;i&lt;=end;i++)&#123; swap(list,start,i); perm(list,start+1,end); swap(list,start,i) &#125; &#125;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125;let list=[1,2,3,4,5];perm(list,0,4); 去重复那么在这种递归的方法中，如何去掉重复的全排列呢。 先举个例子：1，2，2 在这个数组中将第一个数与第二个数交换得到2，1，2，将第一个与第三个交换得到2，2，1 然后将2，1，2中的第二个与第三个交换2，2，1，额，，，发生了重复，咱们需要转换思路了。 重新梳理。将第一个数与第二个数交换得到2，1，2，然后发现第二个数与第三个数相同，于是第一个数不再与第三个数交换。 再考虑2，1，2，将第二个数与第三个数交换得到2，2，1.此时全排列完成。 这样我们也得到了在全排列中去掉重复项的规则：去重的全排列就是从第一个数字起，每个数分别与它后面非重复出现的数字交换。用编程的话描述就是第i个数与第j个数交换时，要求[i,j]中没有与第j个数相等的数。 新添加了一个isSwap函数： 12345678910111213141516171819202122232425262728function perm(list,start,end)&#123; if(start&gt;end)&#123; console.log(list); &#125;else&#123; for(let i=start;i&lt;=end;i++)&#123; if(isSwap(list, start, i))&#123; swap(list,start,i); perm(list,start+1,end); swap(list,start,i) &#125; &#125; &#125;&#125;function isSwap(list, start,end)&#123; for(let i=start;i&lt;end;i++)&#123; if(list[i]===list[end])&#123; return false; &#125; &#125; return true;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125;let list=[1,2,3,4,5];perm(list,0,4); 字典排序法全排列的另外一种方法是字典排序法。 字典排序法，就是在数组中，从后往前找，找到第一个非递增数比如1，2，4，3中2就是从前往后第一个非递增数。 然后再次从后往前找，找到第一个大于2的数，在这里就是3，交换2和3，数组变成1，3，4，2。 最后再逆置3后面的数即1，3，2，4 12345678910111213141516171819202122232425262728293031323334353637383940414243function main(list)&#123; list.sort((a,b)=&gt;&#123; return a-b; &#125;) console.log(list); while(perm(list))&#123; console.log(list); &#125;&#125;function perm(list)&#123; let index;//从后往前找，找到第一个非递增数 for(let i=list.length-2;i&gt;=0;i--)&#123; if(list[i]&lt;list[i+1])&#123; index=i; break; &#125; else if (i === 0) &#123; //若没找到，说明当前序列已经是最大字典序了 return false; &#125; &#125;//从后往前找，找到第一个大于index位置上的数 for(let i=list.length-1;i&gt;=index;i--)&#123; if(list[i]&gt;list[index])&#123; swap(list, i, index); reverse(list, index+1); break; &#125; &#125; return true;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125;function reverse(list, start)&#123; let end = list.length-1; while(start&lt;end)&#123; swap(list,start,end); start++; end--; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"快速排序","date":"2017-11-04T13:32:46.000Z","path":"2017/11/04/快速排序/","text":"快速排序的时间复杂度为O(N*logN)。 算法思路在快速排序中需要有一个Partition函数，这个方法是在数组中选择一个数字，然后把数组中的数字分为两个部分，比选择的数字小的函数移到数组的左边，比选择的数字大的数字移到数组的右边。这个函数的实现如下： 123456789101112131415161718192021function partition(list, length, start, end)&#123; var mid = Math.floor((start + end)/2); swap(list, mid , end); var small = start - 1; for(let i = start; i &lt; end; i++) &#123; if (list[i] &lt; list[end])&#123; small++; if(small !== i)&#123; swap(list, i, small); &#125; &#125; &#125; small++; swap(list, small, end); return small;&#125;function swap(list,i,j)&#123; let tmp=list[i]; list[i]=list[j]; list[j]=tmp;&#125; 算法解释我来解释一下这个函数。 在数组中选取中间的数，然后从前到后遍历，如果某个数比选定的数小，则交换位置。 一个很重要的变量是small，这个变量是用来统计比listend小的数，当list[i]&lt;list[end]，small加一，然后将所有比list[end]小的数，全都交换到前面去。 最后small的位置存放的是选定的数，在这个数前面的数全是小于它，后面的全部大于它。接下需要的就是使用一个递归函数，对选定数之前的数组和选定数之后的数组再进行排序。 123456789101112function quickSort(list, length, start, end)&#123; if(start === end)&#123; return; &#125; var index = partition(list, length, start, end); if (index &gt; start)&#123; quickSort(list, length, start, index - 1); &#125; if (index &lt; end)&#123; quickSort(list, length, index + 1, end); &#125;&#125; partition方法应用在快速排序中的partition方法能用到的地方很多，比如，在剑指offer的面试题29中：数组中出现次数超过一半的数字。也用到了partition。 剑指offer29题这道题可以先对数组做一次partition，判断返回的数是否正好在n/2位置，则这个数就是我们要找的数；如果返回的数在大于n/2，则中位数在这个数的左边；如果返回的数在小于n/2，则中位数在这个数的右边。 1234567891011121314151617function moreThanHalfNum(list, length) &#123; var start = 0; var end = list.length - 1; var mid = Math.floor((start + end)/2); var index = partition(list, length, start, end); while(index !== mid)&#123; if(index &gt; mid) &#123; end = index - 1; index = partition(list, length, start, end); &#125; else &#123; start = index + 1; index = partition(list, length, start, end); &#125; &#125; var result = list[mid]; return result; &#125; 剑指offer30题再比如在剑指offer的面试题30：最小的k个数，也用到了partition。因为在partition中，将小于选定数的数都放在选定数的前面，大于选定数的数都放在选定数的后面，因此这道题要找出最小的k个数，只需要找到partition的返回值index===k-1即可。 12345678910111213141516171819function getLeastNumbers(list,k)&#123; var start = 0; var end = list.length - 1; var result=[]; var index = partition(list, length, start, end); while(index !== k - 1) &#123; if (index &gt; k - 1)&#123; end = index - 1; index = partition(list, length, start, end); &#125; else &#123; start = index + 1; index = partition(list, length, start, end); &#125; &#125; for(let i=0;i&lt;k;i++)&#123; result.push(list[i]); &#125; console.log(result);&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"UI组件之浮出层","date":"2017-09-21T14:25:59.000Z","path":"2017/09/21/UI组件之浮出层/","text":"UI组件之浮出层 这是2017年百度前端学院的一道题，要求做出一个如图所示的浮出层。 以下是浮出层的html代码。 12345678910111213141516171819&lt;div class=\"modal\"&gt; &lt;div class=\"modal-dialog\" draggable=\"true\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"close\"&gt;取消&lt;/button&gt; &lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle e-resize\"&gt;&lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle n-resize\"&gt;&lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle w-resize\"&gt;&lt;/div&gt; &lt;div draggable=\"true\" class=\"resizable-handle s-resize\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对外提供了一些可以用来定制浮出层的选项。选项表如下： 选项名称 选项默认值 选项描述 size size:{ width: ‘600px’, height: ‘138px’} 允许自定义浮出层的宽高。 resizeable resizeable: true 允许通过拖拽浮出层的一边来改变大小 dragable dragable: true 允许通过拖拽来改变浮出层的位置 keyboard keyboard: true 当按下 escape 键时关闭浮出层，设置为 false 时则按键无效。 backdrop backdrop: true 指定一个静态的背景，当用户点击模态框外部时不会关闭模态框。 open open: null 指定打开浮出层时的回调函数。 beforeClose beforeClose: null 指定关闭浮出层之前的回调函数。 close close: null 指定关闭浮出层的回调函数。 除了这八个选项，还提供了show和hide两个方法。 方法 描述 实例 show 打开弹出层 let modal=new ModalFunc(options); modal.show(); hide 关闭弹出层 let modal=new ModalFunc(options); modal.hide(); 接下来聊一聊我在实现过程中遇到的问题和收获。 1、创建自定义类型在这里创建了一个ModalFunc的自定义类型，采用的方式是组合使用构造函数与原型模式。基本代码如下。 123456789let ModalFunc = function(elem, opts)&#123; this.element = elem; this.options = &#123;&#125;;&#125;;ModalFunc.prototype = &#123; setConfig: function()&#123;&#125;， show:function()&#123;&#125;, hide:function()&#123;&#125;&#125; 这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。 2、提供定制浮出层的选项在ModalFunc构造函数中初始化options属性，options的值来源于用户定义或默认值。如下是在ModalFunc构造函数中初始化options属性的代码。_default_options是options的默认值，opts是用户定义的值。 1234567891011121314151617181920212223242526//定义options默认值const _default_options = &#123; size:&#123; width: '600px', height: '138px' &#125;, resizeable: true, dragable: true, //当按下 escape 键时关闭浮出层，设置为 false 时则按键无效。 keyboard: true, //当用户点击浮出层外部是否会关闭浮出层。 backdrop: true, // open回调 open: null, // close回调 close: null, beforeClose: null&#125;this.options = &#123;&#125;;if (opts === undefined) &#123; this.options = _default_options;&#125; else &#123; for (let key in _default_options) &#123; this.options[key] = opts[key]!==null ? opts[key] : _default_options[key]; &#125;&#125; 用户是在使用浮出层的页面中new一个ModalFunc的对象，并且传入element和options两个参数。如下代码所示： 1234567891011121314151617181920212223let modal=new ModalFunc(myModal,&#123; size:&#123; width:\"500px\", height:'138px' &#125;, keyboard:true, resizeable: true, dragable: true, backdrop:true, open: () =&gt; &#123; console.log('浮出层打开'); &#125;, beforeClose: (done) =&gt; &#123; if (confirm('before close')) &#123; done(); &#125; else &#123; console.log('close failed by before close callback.'); &#125; &#125;, close: () =&gt; &#123; console.log('浮出层关闭') &#125;&#125;); 3、实现keyboard选项keyboard选项控制当按下 escape 键时关闭浮出层，当设置为 false 则按键无效。这里我遇上的问题是如何在不人为调整焦点的情况下，当浮出层弹出，焦点自动处于其上。解决方法是在使用show方法打开浮出层的时候，添加如下代码： 12this.element.setAttribute('tabindex', 0);this.element.focus(); this.element是指modal元素。这样当打开浮出层，焦点就在浮出层上。 4、实现backdrop选项backdrop选项控制用户点击浮出层外部时是否关闭浮出层。当设置true则关闭。这里我遇上的问题是如何实现点击阴影背景可关闭，但点击弹框不可关闭。解决方法是在modal-dialog元素上设置event.stopPropagation();从而阻止冒泡进一步传播到modal元素上。代码如下： 123456789if(this.options.backdrop)&#123; const dialog = document.getElementsByClassName(\"modal-dialog\"); dialog[0].addEventListener(\"click\",(event)=&gt;&#123; event.stopPropagation(); &#125;,false); this.element.addEventListener(\"click\",(e)=&gt;&#123; this.hide(); &#125;,false);&#125; 5、实现dragable选项插件中的dragable选项控制浮出层是否可以拖拽。想要实现的效果是用鼠标点击浮出层然后在页面内拖动，最终放开鼠标，浮出层就处于放开最后一刻的位置。在写浮出层的拖拽时，modal-dialog需要定位浮出层在drag过程中的位置，这里使用绝对定位。top和left设置为0，然后使用js使浮出层居中。这里使用了html5原生的drag和drop事件。制作可拖动对象非常简单。在要设为可移动的元素上设置 draggable=”true” 属性，再设置dragstart事件监听。 1234this.element.addEventListener('dragstart',(event) =&gt; &#123; dragOffset.x = event.offsetX; dragOffset.y = event.offsetY;&#125;,false); 在drag事件中只要计算出模态框left和top的值，就能进行定位，代码如下所示。 1234567891011this.element.addEventListener('drag',(event) =&gt; &#123; event.preventDefault(); if(event.clientX - dragOffset.x&lt;0)&#123; dialog[0].style.left = '0px'; &#125;else if(event.clientY - dragOffset.y&lt;0)&#123; dialog[0].style.top = '0px'; &#125;else&#123; dialog[0].style.left = (event.clientX - dragOffset.x ) + 'px'; dialog[0].style.top = (event.clientY - dragOffset.y ) + 'px'; &#125;&#125;,false); 在drag事件中有一些和位置有关的属性可以帮助定位：event.clientX和event.clientY，这两个值是当前鼠标焦点到页面最左上角，两个坐标之间的X和Y。除了这两个值，我们还需要鼠标焦点到对话框最左上角的距离，这个值可以通过dragstart事件event.offsetX和event.offsetY获取。如图所示： 在dragenter和dragover事件期间调用preventDefault（）方法将指示在该位置允许放置。 1234this.element.addEventListener(\"dragover\", function(event) &#123; // prevent default to allow drop event.preventDefault();&#125;, false); 但是令我困惑的是，未定义dragend事件，浮出层依然可以被放置到正确位置。 6、实现resizeable选项插件中的resizeable选项实现了横向或纵向拖动浮出层的边框可以改变浮出层的宽度或高度。实现参考了jquery-ui的缩放功能。在浮出层的html结构上加了四条透明边框线（为了显示效果加了颜色），如图： 然后分别对这四条边进行drag&amp;drop事件监听。下面以左边为例，只要计算出当前模态框宽度、left和top值就可以实现左边的拖拽。 12345678910111213141516171819202122w_resize[0].addEventListener('dragstart',(event) =&gt; &#123; dialogWidth = parseInt(dialogContent[0].style.width); clientX = event.clientX; dragOffset.x = event.offsetX; dragOffset.y = event.offsetY;&#125;,false);w_resize[0].addEventListener('drag',(event) =&gt; &#123; event.stopPropagation(); dialogContent[0].style.width = (dialogWidth - (event.clientX - clientX)) + 'px'; if(event.clientX - dragOffset.x&lt;0)&#123; dialog[0].style.left = '0px'; &#125;else if(event.clientY - dragOffset.y&lt;0)&#123; dialog[0].style.top = '0px'; &#125;else&#123; dialog[0].style.left = (event.clientX - dragOffset.x ) + 'px'; dialog[0].style.top = (event.clientY - dragOffset.y ) + 'px'; &#125;&#125;,false);w_resize[0].addEventListener(\"dragover\", function(event) &#123; // prevent default to allow drop event.preventDefault();&#125;, false);","tags":[]}]