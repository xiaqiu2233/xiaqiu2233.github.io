<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="keywords" content="js, css, dom"><title>React理解 | fyt的博客</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React理解</h1><a id="logo" href="/.">fyt的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">React理解</h1><div class="post-meta"><a href="/2018/08/15/React理解/#comments" class="comment-count"></a><p><span class="date">Aug 15, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="1、React-Element"><a href="#1、React-Element" class="headerlink" title="1、React Element"></a>1、React Element</h3><p>React Element是React的virtual DOM，本质上就是一个普通的对象，相较于浏览器的DOM更加轻量，它是Component的组成部分，是构建React应用的最小单元。<br>React Element通常由render函数返回的JSX创建，但其本质上只是React.createElement(component, props, …children)的语法糖。<br>React Element有类型之分，比如JSX的标签名就决定了React Element的类型，不同的JSX标签，就是不同类型的React Element。<br>React Element有内容（children）和属性（attribute），但是一旦React Element被创建之后，是无法改变其内容或属性的。即，React Element都是immutable不可变的。<br>更新界面的唯一办法是创建一个新的React Element，会由React DOM对比（diff）新旧React Element之后，只把改变了的部分更新到浏览器DOM上。</p>
<h3 id="2、React-Components"><a href="#2、React-Components" class="headerlink" title="2、React Components"></a>2、React Components</h3><p>React的主要特征就是由Components组成。Components可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。<br><strong>所有的React组件必须像纯函数那样使用它们的props</strong>，就是不能修改props，只能使用props。<br>满足以下两点称为纯函数：</p>
<ul>
<li>返回的值仅依赖于传入的参数，而不依赖于内部或外部的其它状态</li>
<li>纯函数运行没有副作用（例如本地静态变量或非局部变量的变异，或执行I / O操作）</li>
</ul>
<h4 id="2-1-Functional-amp-amp-Class-Component"><a href="#2-1-Functional-amp-amp-Class-Component" class="headerlink" title="2.1 Functional &amp;&amp; Class Component"></a>2.1 Functional &amp;&amp; Class Component</h4><p>Functional Component 函数定义的组件需要是一个函数，接收单一的props对象作为参数，然后返回一个React Element。<br>Class Component 使用ES6语法定义的组件，必须继承自React.Component（或PureComponent），实现render函数并返回React Element。Class Component可以有自己的state，用来实现局部状态（或封装）。</p>
<h4 id="2-2-PureComponent"><a href="#2-2-PureComponent" class="headerlink" title="2.2 PureComponent"></a>2.2 PureComponent</h4><p>PureComponent改变了生命周期方法shouldComponentUpdate，并且它会自动检查组件是否需要重新渲染。这时，只有PureComponent检测到state或者props发生变化时，PureComponent才会调用render方法。<br>所以PureComponent的使用场景是：</p>
<ul>
<li>props和state的对象中的属性值都是简单类型</li>
<li>确定深层数据结构改变时使用forceUpdate</li>
<li>使用immutable对象<br>React.PureComponent 的 shouldComponentUpdate() 会跳过整个组件子树的 prop 更新，也就是如果父PureComponent不更新，子组件也不可能更新；父PureComponent更新，子组件才更新。因此使用时请确保所有子组件同样是“纯”的。</li>
</ul>
<h3 id="3、-组件生命周期"><a href="#3、-组件生命周期" class="headerlink" title="3、 组件生命周期"></a>3、 组件生命周期</h3><ol>
<li>首次装载组件时，按顺序执行：getDefaultProps、getInitialState、componentWillMount、render和componentDidMount；</li>
<li>在重新装载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps；</li>
<li>当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。</li>
<li>当卸载组件时，执行 componentWillUnmount；<br>如下图所示：<br><img src="react1.png" alt=""><br>React 通过三种状态：MOUNTING、RECEIVE_PROPS、UNMOUNTING，管理整个生命周期的执行顺序。这三个状态对应三种方法，分别为：mountComponent、updateComponent、unmountComponent。<br>状态一：MOUNTING<br>mountComponent负责管理生命周期中的getInitialState、componentWillMount、render和componentDidMount。<br>由于getDefaultProps是通过Constructor进行管理，因此也是整个生命周期中最先开始执行，而mountComponent只能望洋兴叹，无法调用到getDefaultProps。这就解释了为何getDefaultProps只执行1次的原因。<br>由于通过ReactCompositeComponentBase返回的是一个虚拟节点，因此需要利用instantiateReactComponent去得到实例，再使用mountComponent拿到结果作为当前自定义元素的结果。关于这部分将虚拟节点转换成DOM元素的过程还是有必要再深挖的。<br>首先通过mountComponent装载组件，此时，将状态设置为MOUNTING，利用getInitialState获取初始化state，初始化更新队列。<br>若存在componentWillMount，则执行；如果此时在componentWillMount中调用setState，是不会触发reRender，而是进行state合并。<br>到此时，已经完成MOUNTING的工作，更新状态为NULL，同时state也将执行更新操作，此刻在render中可以获取更新后的this.state数据。<br>其实，mountComponent本质上是通过递归渲染内容的，由于递归的特性，父组件的componentWillMount一定在其子组件的componentWillMount之前调用，而父组件的componentDidMount肯定在其子组件的componentDidMount之后调用。<br>当渲染完成之后，若存在componentDidMount则触发。这就解释了componentWillMount-render-componentDidMount三者之间的执行顺序。<br>如下图所示：<br><img src="react2.png" alt=""><br>状态二：RECEIVE_PROPS<br>updateComponent负责管理生命周期中的componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate。<br>首先通过updateComponent更新组件，如果前后元素不一致说明需要进行组件更新，此时将状态设置为RECEIVING_PROPS。<br>若存在componentWillReceiveProps，则执行；如果此时在componentWillReceiveProps中调用setState，是不会触发reRender，而是进行state合并。<br>到此时，已经完成RECEIVING_PROPS工作，更新状态为NULL，同时state也将执行更新操作，此刻this.state可以获取到更新后的数据。<br>调用shouldComponentUpdate判断是否需要进行组件更新，如果存在componentWillUpdate，则执行。<br>updateComponent本质上也是通过递归渲染内容的，由于递归的特性，父组件的componentWillUpdate一定在其子组件的componentWillUpdate之前调用，而父组件的componentDidUpdate肯定在其子组件componentDidUpdate之后调用。<br>当渲染完成之后，若存在componentDidUpdate，则触发，这就解释了componentWillReceiveProps-componentWillUpdate-render-componentDidUpdate它们之间的执行顺序。<br>如下图所示：<br><img src="react3.png" alt=""><br>状态三：UNMOUNTING<br>unmountComponent负责管理生命周期中的componentWillUnmount。<br>首先将状态设置为UNMOUNTING，若存在componentWillUnmount，则执行；如果此时在componentWillUnmount中调用setState，是不会触发reRender。更新状态为NULL，完成组件卸载操作。</li>
</ol>
<h3 id="2-setState的更新机制"><a href="#2-setState的更新机制" class="headerlink" title="2 setState的更新机制"></a>2 setState的更新机制</h3><p>当调用setState时，会对state以及_pendingState更新队列进行合并操作，但其实真正更新state的幕后黑手是replaceState。replaceState会先判断当前状态是否为MOUNTING，如果不是即会调用ReactUpdates.enqueueUpdate执行更新。<br>当状态不为MOUNTING或RECEIVING_PROPS时，performUpdateIfNecessary会获取_pendingElement、_pendingState、_pendingForceUpdate，并调用updateComponent进行组件更新。<br>如果在shouldComponentUpdate或componentWillUpdate中调用setState，此时的状态已经从RECEIVING_PROPS-&gt;NULL，则performUpdateIfNecessary就会调用updateComponent进行组件更新，但updateComponent又会调用shouldComponentUpdate和componentWillUpdate，因此造成循环调用，使得浏览器内存占满后崩溃。<br>总而言之，禁止在shouldComponentUpdate和componentWillUpdate中调用setState，会造成循环调用，直至耗光浏览器内存后崩溃。（错误）<br>而且setState只有咋event handle里面才会批量触发，如果不是有一个AJAX响应处理程序而不是event handle，则每个setState（）都会在发生时立即处理。<br>setState的异步更新目的是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// We're not in an event handler, so these are flushed separately.</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">a</span>: <span class="literal">true</span>&#125;); <span class="comment">// Re-renders with &#123;a: true, b: false &#125;</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">b</span>: <span class="literal">true</span>&#125;); <span class="comment">// Re-renders with &#123;a: true, b: true &#125;</span></span><br><span class="line">  <span class="keyword">this</span>.props.setParentState(); <span class="comment">// Re-renders the parent</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2、React虚拟节点和diff算法"><a href="#2、React虚拟节点和diff算法" class="headerlink" title="2、React虚拟节点和diff算法"></a>2、React虚拟节点和diff算法</h3><p>在不使用现代框架的早期阶段，当页面上数据状态变更后，需要操作对应的DOM元素，页面上监听的事件越多，回调中的DOM操作也越多。手动进行DOM的操作，有两个缺陷：<br>1、操作DOM的复杂性，使代码结构不清晰<br>2、人为操作DOM，可能性能不回达到最佳<br>既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了MVVM模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图。<br>MVVM可以很好的降低我们维护状态-&gt;视图的复杂程度（大大减少代码中的视图更新逻辑）。<br>然而对于react的VirtualDOM而言，即使一个小小的状态变更都要重新构造整棵DOM。只是在react的实现中，加了一些特别的步骤来避免整棵DOM树变更。<br>一个DOM元素的属性非常多，处理DOM不可能会比JS对象处理起来快。VirtualDOM使用JS对象来表示一个节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    id: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面对应的HTML写法是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以上面所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。<br>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。<br>diff算法返回的是最优更新DOM的方式。<br>然而，使用Virtual DOM不一定在性能上强于直接操作DOM：<br>因为使用diff算法，需要先比较两棵Virtual DOM树，得出需要变化的部分，最后再去修改DOM。这个过程可能不比直接操作DOM要快。<br>但是使用virtual dom最大的好处是：</p>
<ul>
<li>抽象了视图层的操作方法，使用用户可以不用直接操作DOM；</li>
<li>同时在大量操作DOM时，一定比大量操作Virtual DOM效率低。<br>传统的diff算法，算法复杂度高达 O(n^3)，改进后的算法复杂度为O(n)<br>diff算法优化基于三点前提：</li>
<li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li>
<li>两个不同类型的元素将产生不同的树。</li>
<li>通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。<br>基于以上三个前提假设，React 分别对 tree diff、component diff 以及 element diff 进行算法优化</li>
</ul>
<ol>
<li><p>tree diff<br>根据前提1，React diff算法将树进行分层，两棵树只会对同一层次的节点进行比较。<br>既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br>当存在跨层级的移动操作呢？此时也是按层比较，不会进行元素层级间的移动，而会新增或是删除节点。这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。</p>
</li>
<li><p>component diff</p>
</li>
</ol>
<ul>
<li><p>针对不同类型的元素<br>React会销毁该元素及其所有的子元素，并重新构建新的元素及其所有的子元素；<br>DOM元素：直接销毁并重建；<br>Component元素：销毁前，该Component实例会收到componentWillUnmount()；重建时，新Component实例会收到componentWillMount() 和 componentDidMount()，这会导致该Component的state丢失。</p>
</li>
<li><p>针对相同类型的元素<br>DOM元素：例如div、h1等，React会比较两者的属性，仅更新变化的属性，并递归其子元素；<br>Component元素：会保留该Component的实例，并在该实例上依次调用componentWillReceiveProps() 和 componentWillUpdate() 方法，该Component的state会保留。在组件元素的render方法被调用的时候，diff算法会继续以该Component的根元素递归处理；</p>
</li>
</ul>
<ol>
<li>element diff<br>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。<br>当同一层上节点一样，但是节点顺序不同，更新时对每一个节点都需要进行插入新节点和删除旧节点的操作，导致操作繁琐冗余。因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。<br>针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！<br>有key：为了提高效率并保证稳定性，可以给所有的children加“key”。该key值需要在同一兄弟元素之间应该是独一无二的，这样就能快速地通过该key值做对比，本质上是一种hash的思想。</li>
</ol>
<h4 id="3-React-数据是如何驱动视图的"><a href="#3-React-数据是如何驱动视图的" class="headerlink" title="3. React 数据是如何驱动视图的"></a>3. React 数据是如何驱动视图的</h4><p>MVVM的viewmodel层将数据与视图进行绑定，操作数据等同于操作视图，数据修改后视图自动更新。<br>当state或者是props发生变化后，将该组件标记为dirty，然后</p>
<h4 id="4-废弃的react生命周期原因及新生命周期如何适配旧的生命周期"><a href="#4-废弃的react生命周期原因及新生命周期如何适配旧的生命周期" class="headerlink" title="4. 废弃的react生命周期原因及新生命周期如何适配旧的生命周期"></a>4. 废弃的react生命周期原因及新生命周期如何适配旧的生命周期</h4><p>componentWillMount、componentWillReceiveProps、componentWillUpdate是即将在17版本中被标记为unsafe的生命周期函数。这里的“不安全”不是指安全性，而是传达使用这些生命周期的代码更有可能在React的未来版本中出现错误，特别是在启用异步渲染时。</p>
<ol>
<li>componentWillMount<br><strong>使用constructor和componentDidMount来覆盖</strong></li>
</ol>
<ul>
<li>如果要在componentWillMount中放入setState改变状态，可以将这部分代码放入constructor中。</li>
<li>如果要在componentWillMount中进行异步操作，可以将这部分代码写在componentDidMount中。</li>
<li>如果想在componentWillMount中订阅事件，可能会发生内存泄漏，因为如果server rendering或异步rendering出错，componentWillUnmount将不会触发，因此就无法在componentWillUnmount中进行取消订阅，导致内存泄漏。应该将componentWillMount中的订阅事件放入componentDidMount中，这样只有在server rendering或异步rendering顺利执行后才会调用componentDidMount，就不会发生内存泄漏。</li>
</ul>
<ol>
<li>componentWillReceiveProps<br><strong>总结来说当有关根据props更新state就将这部分逻辑存放在getDerivedStateFromProps中，如果和异步操作有关（如数据更新）就使用componentDidUpdate。</strong><br>因为componentWillReceiveProps和componentWillUpdate可能会在正式更新之前调用好几次，所以要避免将有副作用的操作放在这个生命周期函数中执行，而应该将这些放入componentDidUpdate方法中，因为componentDidUpdate确保只执行一次。<br>componentWillReceiveProps方法用于根据props更新state，但它经常被错误地用于确实存在问题的方式。 因此该方法将被弃用。<br>响应props以更新state的推荐方法是使用新的静态getDerivedStateFromProps生命周期。getDerivedStateFromProps使用在实例化组件之后以及re-render组件之前，它可以返回一个更新state的对象，或者返回null以指示新的props不需要任何state更新。</li>
<li>componentWillUpdate<br><strong>使用getSnapshotBeforeUpdate和componentDidUpdate来覆盖。</strong><br>有时候componentWillUpdate需要用来比如重新渲染期间手动保留滚动位置时，但是因为异步渲染，所以“渲染”阶段生命周期（如componentWillUpdate和render）和“commit”阶段生命周期（如componentDidUpdate）之间可能存在延迟。 如果用户在此期间执行类似调整窗口大小的操作，则从componentWillUpdate读取的scrollHeight值将过时。此问题的解决方案是使用新的“提交”阶段生命周期getSnapshotBeforeUpdate。 在进行突变之前（例如在更新DOM之前）立即调用该方法。 它可以返回一个React的值作为参数传递给componentDidUpdate，它在突变后立即被调用。<br>很多时候人们会误用componentWillUpdate是担心componentDidUpdate触发时，更新其他组件的状态“为时已晚”。但react确保任何setState在componentDidMount和componentDidUpdate调用时，会在用户看到UI之前立刻刷新。如果在componentWillUpdate中对state变化进行事件绑定，componentWillUpdate可能会发生多次，导致进行多次事件绑定，因此可以将这部分内容放在componentDidUpdate中进行。</li>
</ol>
<h4 id="5-react和vue"><a href="#5-react和vue" class="headerlink" title="5. react和vue"></a>5. react和vue</h4><p>在vue中createElement方法用来创建一个虚拟节点。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。<br></p>
<ul>
<li>JSX vs Template<br>对于一些开发者而言，模板更容易理解；并且相比JSX，模板可以更好的把功能和布局分割开来；并且比起模板，渲染函数更易于调试和测试。</li>
<li>数据层<br>React组件内部通过state来维护组件状态的变化，这也是state唯一的作用。<br>React里的state只能用setState方法改变。使用setState可以合并需要修改的state，避免多次触发reRender。<br>Vue中的数据是可变的（mutated）</li>
<li>如何实现批量更新<br>react使用setState，vue使用nextTick<br>Vue会把一轮事件循环(即一次task)中所有触发的watcher去重后添加到一个队列里，然后将这个队列交由Vue.nextTick()，即将这个队列添加到microtask中，这样在本次task结束后，按照规则就会取出所有的microtask执行它们，实现DOM的更新。<br>就是说如果方法是通过React调用的比如生命周期函数，React的事件处理等，那么会进行批量更新，自己调用的方法，比如setTimeout，xhr等则是连续更新。当批量更新时，react将组件需要更新的状态放入dirtyComponents队列中。在react中有事务（transaction）的概念，事务就是在真正执行method之前加一些预处理和之后加一些尾处理。react将mounting放入method中，然后在mounting结束后的尾处理中，进行批量更新。<br>看到批量更新vue和react的区别：<br>vue：<br>依赖浏览器Api与事件处理队列<br>不可控(我们无法通过编码改变它)<br>react:<br>纯JS实现，不依赖浏览器Api<br>可控性强，可手动调用(因为可编码)<br>是否异步需要看具体场景，易出错(需要对源码有了解)</li>
<li>生命周期<br>生命周期不一样</li>
<li>组件间的数据通信<br>vue：<br>子=&gt;父通信:通过父组件给子组件传递的回调函数，和子组件的自定义事件通信<br>react：<br>子=&gt;父通信:通过父组件给子组件传递的回调函数<br>共同：<br>父=&gt;子通信:props<br>兄弟组件之间的通信：寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法。<br>全局通信：可以定义一个全局的eventEmitter，一个地方发送消息，另一个地方监听并接收消息，很容易想到的就是发布订阅模式了。</li>
<li>事件<br>vue中的事件分为两种一种DOM绑定事件还有一种是自定义事件，自定义事件用于子组件向父组件传递数据，子组件使用$emit触发一个自定义事件，父组件使用v-on监听这个自定义事件。<br>react中的事件是合成事件。在DOM中事件处理函数是一个字符串，而在react的JSX语法中是一个函数。在react中不能使用return false表明阻止默认行为，而必须明确使用preventDefault，在React中定义了合成事件，不需要考虑浏览器的兼容性。使用es6的class语法来定义一个组件时，事件处理器会成为类的一个方法。<br>DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。<br>合成事件有几个特性：<br>1、合成事件对象是共享的，只有一个，这是出于性能因素考虑。在当前事件回调完成之后，会初始化事件对象属性的内容，以便下一次重用。<br>2、合成事件是基于事件委托实现的。直接在DOM树的document上监听原生事件，然后合成对应的事件，根据target分发到对应的React Element上去。同时还实现了event poll，就是事件池，这样可以复用合成的事件对象。</li>
</ul>
<h4 id="6-新特性和改进"><a href="#6-新特性和改进" class="headerlink" title="6. 新特性和改进"></a>6. 新特性和改进</h4><p>New render return types: fragments and strings; (支持返回数组组件)<br>Better error handling （更好的错误处理）<br>Portals （新特性）<br>Better server-side rendering （更好的服务端渲染）<br>Support for custom DOM attributes （支持自定义 DOM 属性）<br>Reduced file size （体积更小）<br>New core architecture （新的 Fiber 架构）</p>
<p>参考文章：<br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a><br><a href="https://zhuanlan.zhihu.com/p/20312691" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20312691</a><br><a href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973" target="_blank" rel="noopener">https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973</a><br><a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710" target="_blank" rel="noopener">https://github.com/facebook/react/issues/11527#issuecomment-360199710</a><br><a href="https://zhuanlan.zhihu.com/p/20328570" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20328570</a><br><a href="https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/blob/master/stack/book/Part-1.md" target="_blank" rel="noopener">https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/blob/master/stack/book/Part-1.md</a></p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/08/16/输入一个URL/" class="pre">输入一个URL</a><a href="/2018/08/15/HTTP杂说/" class="next">HTTP杂说</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、React-Element"><span class="toc-text">1、React Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、React-Components"><span class="toc-text">2、React Components</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Functional-amp-amp-Class-Component"><span class="toc-text">2.1 Functional &amp;&amp; Class Component</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-PureComponent"><span class="toc-text">2.2 PureComponent</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-组件生命周期"><span class="toc-text">3、 组件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-setState的更新机制"><span class="toc-text">2 setState的更新机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、React虚拟节点和diff算法"><span class="toc-text">2、React虚拟节点和diff算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-React-数据是如何驱动视图的"><span class="toc-text">3. React 数据是如何驱动视图的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-废弃的react生命周期原因及新生命周期如何适配旧的生命周期"><span class="toc-text">4. 废弃的react生命周期原因及新生命周期如何适配旧的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-react和vue"><span class="toc-text">5. react和vue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-新特性和改进"><span class="toc-text">6. 新特性和改进</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/设计模式/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/localstorage、sessionstorage、indexedDB的特点和应用场景/">localstorage、sessionstorage、indexedDB的特点和应用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/25/CSS备忘/">CSS备忘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/promise、generator和async的原理/">Promise、Generator和async的原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/事件与事件捕获/">事件与事件捕获</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/各类排序算法/">各类排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/谈一谈模块化的发展/">谈一谈模块化的发展</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/跨域/">CORS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/页面优化/">页面优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/17/Webpack4/">Webpack4</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-na33me1" target="_blank">site-na33me1</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">fyt.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>