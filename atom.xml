<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fyt的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T02:55:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找</title>
    <link href="http://yoursite.com/2018/09/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/09/03/二分查找/</id>
    <published>2018-09-03T01:33:36.000Z</published>
    <updated>2018-09-03T02:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h3><p>二分查找是一个基础的算法，二分查找就是将查找的键和子数组的中间键做比较，如果被查找的键小于中间键，就在左子数组中继续查找，如果大于中间键就在右子数中查找，否则中间键就是要找的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&lt;key)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二分查找的变种"><a href="#2-二分查找的变种" class="headerlink" title="2. 二分查找的变种"></a>2. 二分查找的变种</h3><h4 id="2-1-查找第一个与key相等的元素"><a href="#2-1-查找第一个与key相等的元素" class="headerlink" title="2.1 查找第一个与key相等的元素"></a>2.1 查找第一个与key相等的元素</h4><p>也就是查找下标最小的与key相等的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstEqual</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;arr.length &amp;&amp; arr[left] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-查找最后一个与key相等的元素"><a href="#2-2-查找最后一个与key相等的元素" class="headerlink" title="2.2 查找最后一个与key相等的元素"></a>2.2 查找最后一个与key相等的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLastEqual</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;arr.length &amp;&amp; arr[right] === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-查找第一个等于或者大于key的元素-对照2-1"><a href="#2-3-查找第一个等于或者大于key的元素-对照2-1" class="headerlink" title="2.3 查找第一个等于或者大于key的元素(对照2.1)"></a>2.3 查找第一个等于或者大于key的元素(对照2.1)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstEqualOrLarger</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-查找最后一个等于或者小于key的元素-对照2-2"><a href="#2-4-查找最后一个等于或者小于key的元素-对照2-2" class="headerlink" title="2.4 查找最后一个等于或者小于key的元素(对照2.2)"></a>2.4 查找最后一个等于或者小于key的元素(对照2.2)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLastEqualOrSmaller</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-查找第一个大于key的元素-对照2-3"><a href="#2-5-查找第一个大于key的元素-对照2-3" class="headerlink" title="2.5 查找第一个大于key的元素(对照2.3)"></a>2.5 查找第一个大于key的元素(对照2.3)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstLarger</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-查找最后一个小于key的元素-对照2-4"><a href="#2-6-查找最后一个小于key的元素-对照2-4" class="headerlink" title="2.6 查找最后一个小于key的元素(对照2.4)"></a>2.6 查找最后一个小于key的元素(对照2.4)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLastSmaller</span>(<span class="params">arr, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result=[<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> result[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        result[i] = result[i<span class="number">-1</span>]+result[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-二分查找&quot;&gt;&lt;a href=&quot;#1-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1. 二分查找&quot;&gt;&lt;/a&gt;1. 二分查找&lt;/h3&gt;&lt;p&gt;二分查找是一个基础的算法，二分查找就是将查找的键和子数组的中间键做比较，如果被查找的键小于中间键，就在左
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>服务端推送</title>
    <link href="http://yoursite.com/2018/09/02/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81/"/>
    <id>http://yoursite.com/2018/09/02/服务端推送/</id>
    <published>2018-09-02T05:56:11.000Z</published>
    <updated>2018-09-02T06:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>http协议通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><h3 id="1-websocket"><a href="#1-websocket" class="headerlink" title="1. websocket"></a>1. websocket</h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br>其他特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。<br>概括起来就是：双向的，可跨域，可传输文本二进制。<br>连接过程：<br>1) 客户端发送http的get请求：</p><ul><li>Upgrade: websocket</li><li>Connection: Upgrade</li><li>必须包含Sec-WebSocket-Key头部，值是一个Base64编码的16字节随机字符串。</li><li>必须包含Sec-WebSocket-Version头部，值必须为13<br>2) 服务端验证客户端的握手包符合规范之后也会发送一个握手包给客户端。格式如下：</li><li>状态行中返回Switching Protocol</li><li>必须包含Connection头部，值必须为Upgrade</li><li>必须包含一个Upgrade头部，值必须为websocket</li><li>必须包含一个Sec-Websocket-Accept头部，值是根据如下规则计算的：首先将一个固定的字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接到Sec-WebSocket-Key对应值的后面。对拼接后的字符串进行一次SHA-1计算将计算结果进行Base-64编码<br>客户端收到服务端的握手包之后，验证报文格式时候符合规范，以2）中同样的方式计算Sec-WebSocket-Accept并与服务端握手包里的值进行比对。</li></ul><h3 id="2-server-sent-event"><a href="#2-server-sent-event" class="headerlink" title="2. server-sent event"></a>2. server-sent event</h3><p>SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。<br>其他特点包括：<br> (1) SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。<br> (2) SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。<br> (3) SSE 默认支持断线重连，WebSocket 需要自己实现。<br> (4) SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。<br> (5) SSE 支持自定义发送的消息类型。<br> 概括起来特点就是：单向的，基于文本的，客户端自动重连的。<br> 适用场景：实时监控、股票报价</p><h3 id="3-Commet（长轮询和流）"><a href="#3-Commet（长轮询和流）" class="headerlink" title="3. Commet（长轮询和流）"></a>3. Commet（长轮询和流）</h3><p> 传统轮询是浏览器定时向服务器发送请求，看有没有更新的数据。<br> 长轮询是客户端发送请求，等待服务端响应。服务端拿到请求，一直保持连接打开，直到有数据或是超时的时候返回。发送完数据，浏览器关闭连接，随即又发起一个到服务器的心情求。这一过程在页面打开期间一直持续不断。<br> 轮询的优势：所有浏览器都支持，因为使用XHR和setTimeout就能实现。<br> 流不同于上面两种轮询，因为它在页面的整个生命周期内只使用一个HTTP连接，具体来说就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向浏览器发送数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;http协议通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>节流与防抖</title>
    <link href="http://yoursite.com/2018/09/01/%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <id>http://yoursite.com/2018/09/01/节流与防抖/</id>
    <published>2018-09-01T13:28:13.000Z</published>
    <updated>2018-09-02T05:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-throttle和debounce-应用场景"><a href="#1-throttle和debounce-应用场景" class="headerlink" title="1. throttle和debounce 应用场景"></a>1. throttle和debounce 应用场景</h3><p>首先，咱们来讲一讲节流和防抖的应用场景。节流和防抖出现的场景一般都伴随着客户端DOM事件的监听，并且一般是触发频率高的DOM事件，比如：scroll、mousemove事件。下面会针对节流和防抖举两个例子，让大家品味一下这两个函数的应用场景。<br>举个例子，实现一个原生的拖拽功能（不能用 H5 Drag&amp;Drop API），需要一路监听 mousemove 事件，在回调中获取元素当前位置，然后重置 dom 的位置（样式改变）。如果我们不加以控制，每移动一定像素而触发的回调数量是会非常惊人的，回调中又伴随着 DOM 操作，继而引发浏览器的重排与重绘，性能差的浏览器可能就会直接假死，这样的用户体验是非常糟糕的。我们需要做的是降低触发回调的频率，比如让它 500ms 触发一次，或者 200ms，甚至 100ms，这个阈值不能太大，太大了拖拽就会失真，也不能太小，太小了低版本浏览器可能就会假死，这样的解决方案就是函数节流，英文名字叫「throttle」。<br>函数节流的核心是，让一个函数不要执行得太频繁，减少一些过快的调用来节流。<br>说完函数节流，再看它的好基友函数去抖（debounce）。思考这样一个场景，对于浏览器窗口，每做一次 resize 操作，发送一个请求，很显然，我们需要监听 resize 事件，但是和 mousemove 一样，每缩小（或者放大）一次浏览器，实际上会触发 N 多次的 resize 事件，用节流？节流只能保证定时触发，我们一次就好，这就要用去抖。简单的说，函数去抖就是对于一定时间段的连续的函数调用，只让其执行一次。<br>throttle 应用场景：<br>函数节流有哪些应用场景？哪些时候我们需要间隔一定时间触发回调来控制函数调用频率？</p><ul><li>DOM 元素的拖拽功能实现（mousemove）</li><li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas 模拟画板功能（mousemove）</li><li>搜索联想（keyup）</li><li>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次<br>debounce 应用场景<br>函数去抖有哪些应用场景？哪些时候对于连续的事件响应我们只需要执行一次回调？</li><li>每次 resize/scroll 触发统计事件</li><li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）</li></ul><h3 id="2-throttle实现"><a href="#2-throttle实现" class="headerlink" title="2. throttle实现"></a>2. throttle实现</h3><p>其实根据不同的要求有不同的throttle实现方式。比如，如果要求没有timer时，设置的和上一次触发的时间间隔是300ms。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time=<span class="number">300</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> prevTime = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>, ...arguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            logging.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        prevTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        timer=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) <span class="keyword">return</span>;</span><br><span class="line">        timer = setTimeout(cb.bind(<span class="keyword">this</span>, ...arguments), <span class="built_in">Math</span>.max(<span class="number">0</span>, time - <span class="built_in">Date</span>.now() + prevTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是上一次触发和这一次触发的触发时间间隔在300ms内，比如是100ms，则setTimeout设置时间为200ms。</p><h3 id="3-debounce实现"><a href="#3-debounce实现" class="headerlink" title="3. debounce实现"></a>3. debounce实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>, ...arguments)</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-throttle和debounce-应用场景&quot;&gt;&lt;a href=&quot;#1-throttle和debounce-应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. throttle和debounce 应用场景&quot;&gt;&lt;/a&gt;1. throttle和d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2018/08/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/26/设计模式/</id>
    <published>2018-08-26T09:56:45.000Z</published>
    <updated>2018-09-01T05:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.instance) &#123;</span><br><span class="line">      <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h3><p>虚拟代理：使用proxySynchronousFile来收集一段时间内的请求，最后一次性发送给服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将请求发送给服务器</span></span><br><span class="line">synchronousFile (id)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始同步文件，id为：'</span>+id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收集请求的代理并一次性发送</span></span><br><span class="line"><span class="keyword">var</span> proxySynchronousFile=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> cache=[];</span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">cache.push(id);</span><br><span class="line"><span class="keyword">if</span>(timer) <span class="keyword">return</span>;</span><br><span class="line">timer=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">synchronousFile(cache.join(<span class="string">','</span>));</span><br><span class="line">clearTimeout(timer);</span><br><span class="line">timer=<span class="literal">null</span>;</span><br><span class="line">cache.length=<span class="number">0</span>;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>缓存代理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createProxyFactory=<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache=&#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args=<span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>);</span><br><span class="line"><span class="keyword">if</span>(args <span class="keyword">in</span> cache)&#123;</span><br><span class="line"><span class="keyword">return</span> cache[args];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cache[args] = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createProxyFactory是个代理工厂，可以为各种计算方法创建缓存代理。</p><h3 id="3-发布订阅模式"><a href="#3-发布订阅模式" class="headerlink" title="3. 发布订阅模式"></a>3. 发布订阅模式</h3><p>Event类似一个中介者的身份，将订阅者和发布者联系起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientList=&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    subscribe(key, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientList[key] = <span class="keyword">this</span>.clientList[key] || [];</span><br><span class="line">        <span class="keyword">this</span>.clientList[key].push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    trigger(key, data) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.clientList[key] || <span class="keyword">this</span>.clientList[key].length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.clientList[key].forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            cb.call(<span class="keyword">this</span>, data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    unsubscribe(key, cb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(key &amp;&amp; cb) &#123;</span><br><span class="line">            <span class="keyword">var</span> ins = <span class="keyword">this</span>.clientList[key].findIndex((<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.is(item, cb);</span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="keyword">if</span>(ins===<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.clientList[key].splice(ins, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clientList[key].length = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4. 组合模式"></a>4. 组合模式</h3><p>组合模式可以让我们使用树形方式创建对象结构，将相同的操作应用在组合对象和单个对象上。从而忽略组合对象和单个对象的差别，从而用一致的方式来处理它们。<br>组合模式要求组合对象和叶对象拥有相同的接口，而且还需要对一组叶对象的操作具有一致性。并且需要叶节点对于组合节点是一对一的关系，如果映射关系复杂，就需要引入中介者模式来管理这些对象。可以运用职责链模式来提高组合性能。</p><h3 id="5-装饰者模式"><a href="#5-装饰者模式" class="headerlink" title="5. 装饰者模式"></a>5. 装饰者模式</h3><p>装饰者模式在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。它是继承关系的一个替代方案，在不改变接口的前提下，增强类的性能。<br>装饰者模式经常会用在框架开发中，我们会希望框架中的函数提供的是一些稳定而方便移植的功能，那些个性化的功能可以在框架之外动态装饰上去。<br>当不考虑向Function的prototype中添加函数时，我们在Function的prototype中添加before和after函数，这两个函数的功能是将原本函数包围一层，返回一个新的函数，这个新函数的作用是保持上下文不变的执行原有函数和先行或后行执行函数。这个先行函数和后行函数就是需要使用装饰器添加的功能，先行函数实在原函数执行前执行，后行函数是在原函数执行后执行。<br>先来定义这两个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before=<span class="function"><span class="keyword">function</span>(<span class="params">beforeFn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> _self=<span class="keyword">this</span>;<span class="comment">//_self保存调用before的函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">return</span> _self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 返回原函数的执行结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after=<span class="function"><span class="keyword">function</span>(<span class="params">afterFn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> _self=<span class="keyword">this</span>;<span class="comment">//_self保存调用before的函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> ret = _self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">return</span> ret; <span class="comment">// 返回原函数的执行结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来举一个具体的例子来展示装饰器的功能，有一个button，点击button需要实现两个功能，一是打开模态框，二是写入日志，将写入日志以装饰器的模式来完成。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log( <span class="string">'打开模态框'</span> );</span></span><br><span class="line"><span class="undefined">    &#125; </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log( <span class="string">' 写入日志: '</span> + <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> )); </span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    showLogin = showLogin.after( log ); <span class="comment">// 在打开模态框后写入吗日志</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin; </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用装饰器模式的场景有面向AOP编程。就是支持日志系统、安全检查、调试、缓存等。<br>在es7中也有装饰器模式，decorator 允许我们在不修改函数内部代码的情况下添加一些额外的行为。在以前的标准中，我们可能会需要通过类似于柯里化（Currying）的方法来实现这个行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorate</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 额外行为</span></span><br><span class="line">       fn.call(<span class="keyword">this</span>, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foobar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">newFoobar = decorate(foobar);</span><br><span class="line">newfoobar(parameters);</span><br></pre></td></tr></table></figure><p>但是，有了decorator，我们可以更加简洁地实现这一行为。与此同时，decorator还允许我们对一个class进行修饰，如很常用的就是添加某些属性、某些属性设为只读特性。按其语法，decorator函数接受三个参数：target, key, descriptor。还记得我们可以通过 Object.defineProperty 定义对象的成员吗：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Class.Prototype, <span class="string">'method'</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>decorator里的参数与defineProperty的参数一致。实现一个readonly的decorator可以简单地使用下面方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    method () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当JS引擎执行到decorator的 @ 标志时，它实际执行的代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor = &#123;</span><br><span class="line">    value: method,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line">descriptor = readonly(Class.prototype, <span class="string">'method'</span>, descriptor) || descriptor;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Class.prototype, <span class="string">'method'</span>, descriptor);</span><br></pre></td></tr></table></figure><p>因此decorator可以作用在类的原型函数上，decorator还可以作用在class上<br>下面来看一下怎样对一个类进行decorate。很简单，我们只要操作 decorate 函数参数中的target即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">className</span>(<span class="params">clsName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.className = clsName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@className(<span class="string">'ui.component'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(UIComponent.className);</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://taobaofed.org/blog/2015/11/16/es7-decorator/" target="_blank" rel="noopener">http://taobaofed.org/blog/2015/11/16/es7-decorator/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-单例模式&quot;&gt;&lt;a href=&quot;#1-单例模式&quot; class=&quot;headerlink&quot; title=&quot;1. 单例模式&quot;&gt;&lt;/a&gt;1. 单例模式&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>localstorage、sessionstorage、indexedDB的特点和应用场景</title>
    <link href="http://yoursite.com/2018/08/26/localstorage%E3%80%81sessionstorage%E3%80%81indexedDB%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/08/26/localstorage、sessionstorage、indexedDB的特点和应用场景/</id>
    <published>2018-08-26T08:29:02.000Z</published>
    <updated>2018-08-26T09:26:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于本地存储空间，在各主流浏览器（包含PC、移动端）竟然惊人的一致，都是 5M 的数量级。当本地存储空间大于5M时，各浏览器都是抛出一个错误 QUOTA_EXCEEDED_ERR 。<br>那么什么样的数据应该保存在本地存储中呢？有以下几个原则：</p><ol><li>只保存重要页面的重要数据<br>典型的，首页首屏<br>对业务庞大的站点，这点尤其重要</li><li>极大提高用户体验的数据<br>比如表单的状态，可以提交之前保存，当用户刷新页面时可以还原<br>静态资源，比如 js 和 css</li><li>一个请求一个 key 值（一个 cgi 一个 key 值）<br>避免请求链接加参数的 key (<a href="http://request-ajax.cgi[params])，这样必然让" target="_blank" rel="noopener">http://request-ajax.cgi[params])，这样必然让</a> key 值趋于冗余从而撑爆空间<h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3></li></ol><ul><li>cookie生成<br>cookie是存在客户端，session存在服务器端。在cookie当用户第一次访问网页时，服务器会给客户端返回一个cookie，在cookie中保存着服务器端session文件的位置信息，用户第一次访问服务器，服务器就会为它创建一个session文件，并将session的标识保存在cookie中发给它。<br>在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。</li><li>cookie访问和设置<br>在 JavaScript 中可以通过 document.cookie 设置字段和进行访问。</li><li>cookie优点</li></ul><p>Cookie的大小为4kb。<br>cookie主要应用在保存用户身份信息。</p><h3 id="2-localstorage"><a href="#2-localstorage" class="headerlink" title="2. localstorage"></a>2. localstorage</h3><ul><li>localStorage介绍：<br>和cookie很类似，但是localStorage的大小有5M；不需要被发送到服务端。还有一个区别localStorage存储的数据是永久性的，其作用域限定在文档源级别（只要URL的协议、端口、主机名三者中有一个不同，就属于不同的文档源）。除此之外，localStorage也受浏览器供应商限制，如果使用chrome访问一个网站，下次用firefox再次访问是获取不到上次存储的数据的。</li><li>localstorage特点：<br>页面数据同步</li><li>好处<br>localStorage 只能做为提升用户体验的手段，而不能成为客户端逻辑的可靠的、唯一的依赖。<br>方便网页的加载，避免取回数据前页面一片空白，如果不需要最新数据也可以减少向服务端请求的次数，从而减少用户等待从服务器获取数据的时间；<br>网络状态不佳时仍可以显示离线数据。</li><li>访问限制<br>只有当前设定localstorage的域下才能访问； 单标签页：两个tab（相同域）之间不能互通； 刷新或新开 tab 是可以访问到的，关闭浏览器重新打开原先tab也可访问。</li><li>localStorage应用：<br>存储一些需要刷新保存并且需要在页面关闭后仍然留下的信息。<br>可以用于保存购物车中的内容；在之前项目中，用于保存上一次的用户浏览标签，并跳转到相应的路径下。</li><li>localstorage注意事项：<br>因为性能问题，不能过于依赖 JSON.stringify。value 尽量使用 string。<br>如果需要多次写入localstorage，尽量一次性写入。<br>localstorage是同步执行，可能会阻塞UI</li></ul><h3 id="3-sessionstorage"><a href="#3-sessionstorage" class="headerlink" title="3. sessionstorage"></a>3. sessionstorage</h3><p>sessionStorage：sessionStorage的有效期仅存在于浏览器的标签页。也就是说如果关闭标签页后，通过sessionStorage存储的数据就都被删除了。sessionStorage的作用域不仅被限制在文档源，还被限定在窗口中，也就是同一标签页中。注意，这里说的窗口是指顶级窗口，如果同一标签页中包含多个<iframe>元素，这两者之间也是可以共享sessionStorage的。<br>sessionStorage的作用于不仅限定在文档源级别，甚至限定在窗口中。sessionStorage的有效期尽存在于浏览器的标签页。</iframe></p><ul><li>访问限制<br>只有当前设定sessionStorage的域下才能访问； 单标签页：两个tab（相同域）之间不能互通； 在新开的tab下或者关闭本tab之后再打开，也不能访问之前写下的sessionStorage； 刷新本tab可以访问。</li><li>应用场景<br>存储一些当前页面刷新需要存储，且不需要在tab关闭时候留下的信息。<br>可以用来检测用户是否是刷新进入的页面，如音乐播放器恢复播放进度条的功能。 非常适合单页应用程序，可以方便在各业务模块进行传值。</li></ul><h3 id="4-cookie和web-storage的区别"><a href="#4-cookie和web-storage的区别" class="headerlink" title="4. cookie和web storage的区别"></a>4. cookie和web storage的区别</h3><p>Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><h3 id="5-IndexDB"><a href="#5-IndexDB" class="headerlink" title="5. IndexDB"></a>5. IndexDB</h3><p>websql 像关系型数据库，使用 sql 语句进行操作。 indexdb 像 nosql，直接使用 js 方法操作数据。</p><ul><li>访问：<br>indexdb与 web storage 一致，均是在创建数据库的域名下才能访问。且不能指定访问域名。</li><li>存储时间：<br>存储时间永久，除非用户清除数据，可以用作长效的存储。</li><li>大小限制：<br>理论上讲，这种存储的方式是没有大小限制的。然而IndexDB的数据库超过50M的时候浏览器会弹出确认。基本上也相当于没有限制了。</li><li>性能测试：<br>indexeddb查询少量数据花费差不多20MS左右。大量数据的情况下，相对耗时会变长一些，但是也就在30MS左右，也是相当给力了，10W数据+，毕竟nosql。</li><li>特点<br>异步。<br>它的数据不是保存在表中，而是保存在对象存储空间中。 创建对象存储空间时，需要定义一个键，然后就可以添加数据。 可以使用游标在对象存储空间中查询特定的对象。 而索引则是为了提高查询速度而基于特定的属性创建的。 说明：indexDB 目前兼容性还不是很好</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于本地存储空间，在各主流浏览器（包含PC、移动端）竟然惊人的一致，都是 5M 的数量级。当本地存储空间大于5M时，各浏览器都是抛出一个错误 QUOTA_EXCEEDED_ERR 。&lt;br&gt;那么什么样的数据应该保存在本地存储中呢？有以下几个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS备忘</title>
    <link href="http://yoursite.com/2018/08/25/CSS%E5%A4%87%E5%BF%98/"/>
    <id>http://yoursite.com/2018/08/25/CSS备忘/</id>
    <published>2018-08-25T02:22:16.000Z</published>
    <updated>2018-08-25T11:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-选择器的特殊性"><a href="#1-选择器的特殊性" class="headerlink" title="1. 选择器的特殊性"></a>1. 选择器的特殊性</h3><p>如果一个元素有两个或多个冲突的属性声明，那么有最高特殊性的声明就会胜出。声明也分为重要声明（就是!important）和非重要声明。这两类声明解决冲突的规则入下：</p><ol><li>对于重要声明就没有特殊性一说</li><li>非重要声明的解决冲突使用特殊性</li><li>重要声明与非重要声明发生冲突时，胜出的总是重要声明<br>非重要声明的特殊性由选择器本身确定。特殊性值表述为4个部分，如0，0，0，0.</li></ol><ul><li>对于内联样式特殊性加1，0，0，0；</li><li>对于ID选择器特殊性加0，1，0，0；</li><li>对于类选择器、伪类选择器、属性选择器特殊性加0，0，1，0；</li><li>对于元素选择器和伪元素选择器特殊性加0，0，0，1；</li><li>对于通配选择器的特殊性加0，0，0，0；（这个和没有特殊性不一样）<br>对于子元素从父元素继承来的值是没有特殊性的，因此通配选择器会覆盖继承来的值。<br>如果特殊性相同的两个规则同时应用到同一个元素，则按照声明的顺序进行排序，一个声明在文档中越后出现，权重越大。导入样式表的出现顺序一般认为出现在主样式表的前面。<br>以及按角色分为创作人员样式、读者样式和用户代理样式。其中用户代理样式的优先级最低。一般而言创作人员样式优先级最高，除了读者样式设置为!important的情况，这种情况就算是创作人员样式设置为!important都是比他弱的。<br>层叠规则如下：<br><img src="css1.png" alt=""></li></ul><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h3><p>css不可继承的属性有：大多数框模型属性（外边距、内边距、背景和边框）。<br>css可继承的属性有：颜色，文字，字体间距行高对齐方式，和列表的样式可以继承<br>所有元素可继承：visibility和cursor。<br>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。<br>终端块状元素可继承：text-indent和text-align。<br>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</p><h3 id="3-选择器的解析方向"><a href="#3-选择器的解析方向" class="headerlink" title="3. 选择器的解析方向"></a>3. 选择器的解析方向</h3><p>从左到右，先拿到目标节点的描述，匹配到可能的节点后，查找父节点。而从右到左解析，先匹配上层元素，再一层层向下匹配，当匹配不到，需要回溯上一层重新匹配。结果显而易见了，众所周知，在 DOM 树中一个元素可能有若干子元素，如果每一个都去判断一下显然性能太差。而一个子元素只有一个父元素，所以找起来非常方便。<br>所以从右向左方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。</p><h3 id="4-盒模型"><a href="#4-盒模型" class="headerlink" title="4. 盒模型"></a>4. 盒模型</h3><p>W3C标准盒模型和IE盒模型<br>水平方向盒模型是由margin-left、border-left、padding-left、content、padding-right、border-right、margin-right组成。<br>W3C标准盒模型width的宽度和高度分别是content的width和height<br>IE标准盒模型width的宽度和高度分别是content+padding+border的width和height<br>使用box-sizing来切换盒模型。Box-sizing:border-box就是IE盒模型，box-sizing:content-box就是W3C盒模型。</p><h3 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h3><p>块级元素：div\p\form\table \header\footer \section\h1-6<br>行内元素：span\i\a\input\button\label\select</p><h3 id="5-颜色"><a href="#5-颜色" class="headerlink" title="5. 颜色"></a>5. 颜色</h3><p>颜色有几种表示方法：</p><ol><li>RGB<br>rgb有三原色，每种颜色的范围是0-255，百分比是0-100%</li><li>16进制<br>将三个介于00-FF的十六进制连起来</li></ol><h3 id="6-长度单位"><a href="#6-长度单位" class="headerlink" title="6. 长度单位"></a>6. 长度单位</h3><p>绝对长度：in、cm、mm、pt、pc<br><img src="css2.png" alt=""><br>相对长度单位：em、ex、rem、px<br>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>em是相对长度单位。相对于当前对象内文本的字体尺寸。元素不同则em的值也不同。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)<br>ex。相对于当前元素所用字体中小写x的高度。如果两段文本，font-size相同但是所用字体不同，则ex的值也可能不同。<br>rem。相对于字体font-size的大小，1rem=font-size</p><h3 id="7-字体"><a href="#7-字体" class="headerlink" title="7. 字体"></a>7. 字体</h3><p>font-family：设置使用的字体类型。<br>font-weight：字体加粗。normal、bold、lighter、100、200…<br>font-size：百分比是相对于父元素的字体大小。font-size单位可以是所有的长度单位。<br>font-style：italic（斜体）、oblique（倾斜）、normal、inherit<br>font的前三个值是font-style，font-weight,font-variant这三个值的顺序随意、后两个值font-size/line-height、font-family则一定要以这个顺序</p><h3 id="8-文本属性"><a href="#8-文本属性" class="headerlink" title="8. 文本属性"></a>8. 文本属性</h3><ul><li>text-indent<br>作用：用于首行缩进,针对块级元素。<br>值：length、百分数、inherit、number<br>百分数：相对于缩进元素父元素的宽度。即如果对一个div设置了这个属性，则百分数是相对于div的父元素。<br>继承：有</li><li>text-align<br>作用：影响元素中文本行相互之间的对齐方式。<br>值：left、center、right、justify、inherit。left、center、right导致文本的左中右对齐；justify是两端对齐。<br>继承：有<br>作用于：块级元素</li><li>line-height<br>作用：文本行基线之间的距离，而不是字体的大小，，确定了将各个元素框的高度增加或减少多少<br>值：normal、百分数、长度<br>normal：字体的1.2倍<br>百分数：相对于元素字体的大小<br>number：是一个缩放因子，用于解决font-size如果是百分比或者em为单位，会相对父元素的font-size计算出line-height然后由子元素继承，子元素从父元素继承line-height时，继承自父元素的line-height和子元素自身的font-size不匹配。使用缩放因子，子元素就继承的是这个因子而不是计算值，因此子元素再用这个因子计算出line-height的值。<br>应用：所有元素<br>块级元素应用：line-height定义了元素中文本基线之间的最小距离。因为是最小，所以文本基线的距离可能会比line-height的值大<br>替换元素应用：<br>继承：有<br>行间距：文本行之间超出字体大小的额外空间。line-height和font-size之差就是行间距<br>文本行、内容区和行内框<br>line-height的值定义行内框的大小；font-size定义内容区的大小；行内框-内容区的部分就是行间距；所有行内框的最高顶部和最低底部就是行框的范围。</li><li>vertical-align<br>应用：行内元素和替换元素<br>值：baseline（默认）、sub、sup、bottom、text-bottom、top、text-top、middle、百分数、数值<br>baseline：一个元素的基线和父元素的基线对齐。如果是图像】输入框这一类的替换元素，则该元素的底部和父元素的基线对齐<br>sub：使一个元素变成下标，该元素的基线（或是替换元素的底部）会低于父元素的基线，低多少由用户代理决定。sup和sub相反<br>bottom：将元素行内框的底部和行框的底部对齐<br>text-bottom：将元素行内框的底端和行内文本框的底部对齐<br>middle：往往（但并不总是）应用于图片，middle将元素行内框的中点与父元素基线上的0.5ex对齐。<br>百分数：将元素的基线（或替换元素的底边）相对于父元素基线升高或降低指定的量。这个百分数是相对于该元素line-height的百分数。<br>总结：可以看到所有垂直对齐的元素都会影响行高。行框的描述是，高度要足以包含最高行内框的顶端和最低行内框的底端。<br>数值：<br>继承：无</li><li>word-spacing<br>作用：增加或减少单词之间的间隔<br>值：normal、inherit、数值<br>应用：所有元素<br>继承：有</li><li>letter-spacing<br>作用：增加或减少字母之间的间隔<br>值：normal、inherit、数值<br>应用：所有元素<br>继承：有</li><li>text-transform<br>作用：处理文本大小写<br>值：uppercase、lowercase、capitalize、none、inherit<br>capitalize：对每个单词首字母大写<br>应用：所有元素<br>继承：有</li><li>text-decoration<br>作用：文本装饰<br>值：none、underline、overline、line-through、blink<br>blink：文本闪烁<br>应用：所有元素<br>继承：无</li><li>text-shadow<br>作用：文本阴影<br>值：三个（color、length[左右偏移]、length[上下偏移]、length[阴影模糊半径]）<br>应用：所有元素<br>继承：无</li><li>white-space<br>作用：影响用户代理对源文档中的空格、换行和tab字符的处理<br>值：normal、nowrap、pre、pre-wrap、pre-line、inherit<br>pre：会保留空格，不换行<br>nowrap：不会保留空格，不换行<br>pre-wrap：会保留空格，换行<br>pre-line：不会保留空格，换行<br>应用：所有元素<br>继承：无</li></ul><h3 id="9-基本视觉格式化"><a href="#9-基本视觉格式化" class="headerlink" title="9. 基本视觉格式化"></a>9. 基本视觉格式化</h3><p>margin-left、width、margin-right可以设置为auto。<br>margin-left和width都为auto则margin-left是0，width尽可能大<br>margin-left、width、margin-right都是auto，则margin-left和margin-right都是0，width尽可能大。<br>margin、width、padding的百分数都是相比于父元素的width。边框没有百分数。<br>不可替换块级元素和可替换块级元素的区别是：前者当width为auto时，宽度是内容的固有宽度。后者width为auto，宽度就是元素的实际宽度，比如一张图片的实际宽度<br>在垂直方向，不可以通过设置margin-top margin-bottom的方式来</p><h3 id="10-居中"><a href="#10-居中" class="headerlink" title="10. 居中"></a>10. 居中</h3><ol><li>水平居中<br>块级元素：<br>设置width，margin-left和margin-right设置为auto。<br>行内元素和块级元素：<br>在父级元素上设置text-align:center<br>设置flex布局，justify-content设置为center</li><li>垂直居中</li></ol><ul><li>行内元素：<br>单行：可以用line-height，让line-height=父元素的高度<br>多行：<br>.father{<br>  display: table-cell;<br>  width: 500px;<br>  vertical-align: middle;<br>  height: 500px;<br>}<br>.child{<br>  white-space: wrap;<br>}</li><li>行内元素和块级元素：<br>可以使用absolute和translate。<br>.father{<br>  position: relative;<br>  height: 600px;<br>}<br>.child{<br>  position: absolute;<br>  top: 50%;<br>  transform: translateY(-50%);<br>}<br>可以使用flex<br>.father{<br>  height: 600px;<br>  display: flex;<br>  align-items: center;<br>}</li></ul><ol><li>垂直水平居中<br>可以使用absolute和translate。<br>可以使用flex</li></ol><h3 id="11-定位"><a href="#11-定位" class="headerlink" title="11. 定位"></a>11. 定位</h3><p>根元素（html）的包含块由用户代理建立<br>非根元素，position是relative或static的元素，其包含块是最近的块级框、表单元格或行内块祖先框<br>非根元素，position是absolute的元素，包含块是最近的position值不为static的祖先元素<br>left和right的百分比相对于包含块的宽度；top和bottom的百分比相对于包含块的高度</p><h3 id="12-float"><a href="#12-float" class="headerlink" title="12. float"></a>12. float</h3><p>浮动元素的包含块就是最近的块级祖先元素</p><h3 id="12-padding和margin"><a href="#12-padding和margin" class="headerlink" title="12. padding和margin"></a>12. padding和margin</h3><p>左右上下padding、左右上下margin的值如果是百分比，都是相对于父元素的宽度来计算的</p><h3 id="13-去除行内块元素的间隙"><a href="#13-去除行内块元素的间隙" class="headerlink" title="13. 去除行内块元素的间隙"></a>13. 去除行内块元素的间隙</h3><ol><li>在父元素上设置font-size为0</li><li>在父元素上设置letter-spacing和word-spacing为-6左右</li></ol><h3 id="14-两个垂直块元素边距塌陷的条件有："><a href="#14-两个垂直块元素边距塌陷的条件有：" class="headerlink" title="14. 两个垂直块元素边距塌陷的条件有："></a>14. 两个垂直块元素边距塌陷的条件有：</h3><ol><li>这两个在同一个BFC中</li><li>这两个没有padding、border、内联元素分离它们</li></ol><h3 id="15-box-shadow"><a href="#15-box-shadow" class="headerlink" title="15. box-shadow"></a>15. box-shadow</h3><p>三个（color、length[左右偏移]、length[上下偏移]、length[阴影模糊半径,值越大阴影越大，越模糊（可选）]、length[阴影半径,值越大阴影越大，不会模糊（可选）]、颜色）</p><h3 id="一个框里横向排列三个块，怎样让这三个块的宽度均为包含块的1-3，尽量说出两种方法"><a href="#一个框里横向排列三个块，怎样让这三个块的宽度均为包含块的1-3，尽量说出两种方法" class="headerlink" title="一个框里横向排列三个块，怎样让这三个块的宽度均为包含块的1/3，尽量说出两种方法"></a>一个框里横向排列三个块，怎样让这三个块的宽度均为包含块的1/3，尽量说出两种方法</h3><ol><li>使用flex</li><li>使用float，让三个元素都float</li><li>使用display: inline-block，并用font-size去除行内块元素的间隔</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-选择器的特殊性&quot;&gt;&lt;a href=&quot;#1-选择器的特殊性&quot; class=&quot;headerlink&quot; title=&quot;1. 选择器的特殊性&quot;&gt;&lt;/a&gt;1. 选择器的特殊性&lt;/h3&gt;&lt;p&gt;如果一个元素有两个或多个冲突的属性声明，那么有最高特殊性的声明就会胜出。声明也分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise、Generator和async的原理</title>
    <link href="http://yoursite.com/2018/08/22/promise%E3%80%81generator%E5%92%8Casync%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/22/promise、generator和async的原理/</id>
    <published>2018-08-22T12:40:49.000Z</published>
    <updated>2018-08-26T14:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-回调的缺陷"><a href="#1-回调的缺陷" class="headerlink" title="1. 回调的缺陷"></a>1. 回调的缺陷</h3><p>想完全的理解Promise，需要从异步的发展开始深究，理解Promise的出现是为了解决什么问题。那么我们从回调开始。<br>回调的缺点是</p><ol><li>代码中表达异步的方式不利于开发人员的理解</li><li>回调最大的问题就是控制反转，如果将回调传入一个第三方的api，那么无法信任这个api的安全性</li><li>可以发明一些特定逻辑来解决这些信任问题，但是会产生更加笨重、更难维护的代码。</li><li>回调没有为我们提供一种机制来核实返回类型检查<br>其中第二点是关于回调编码的信任问题。把一个回调传入api可能出现以下问题：</li></ol><ul><li>调用回调过早</li><li>调用回调过晚</li><li>调用回调次数过多或过少</li><li>未能传递所需的环境和参数</li><li>吞掉可能出现的错误和异常<br>为了更加优雅的处理错误，有些api提供了分离回调：api(…args, success, failure);。以及node中的error-first风格：回调的第一个参数保留用作错误对象，然而使用这种方法也没有解决多次调用的问题，反而还需要我们在error和sucess两种情况都进行判断处理。<br>为了解决由同步异步行为引起的不确定性，提出了永远异步调用回调，这样所有回调都是可预测的异步回调了。</li></ul><h3 id="2-Promise针对回调缺陷的改进"><a href="#2-Promise针对回调缺陷的改进" class="headerlink" title="2. Promise针对回调缺陷的改进"></a>2. Promise针对回调缺陷的改进</h3><p>回调需要被传入api中，由别的api进行控制调用，而更好的方法则是api返回一个类似监听器的对象，由程序控制监听api的执行完成情况和执行结果即成功或失败。对控制反转的恢复实现了更好的关注点分离。其中类似监听器的对象就是Promise的一个模拟。<br>Promise的一个好处是将控制返还给调用代码。<br>Promise通过以下几种方式奠定了自己可信任的基础：</p><ul><li>只提供异步调用</li><li>如果回调出错，Promise永远不会决议，如何捕获错误呢？Promise中有一种称为竞争的高级抽象机制。</li><li>Promise只会接受一次决议，不会因为多次调用决议而出现问题</li><li>通过使用catch或是then的第二个onRejected回调来放置异常被吞掉</li><li>通过Promise.resolve返回一个可信任的Promise<br>因此Promise通过把控制返还给调用代码，并且将控制权放在一个可信任的系统中，使异步编码更清晰。</li></ul><h3 id="4-Promise的局限性"><a href="#4-Promise的局限性" class="headerlink" title="4. Promise的局限性"></a>4. Promise的局限性</h3><p>当Promise的错误处理回调函数报错时无法处理。<br>Promise只有一个完成值或拒绝理由。如果完成值比较复杂，那么需要在每一步进行封装和解封。</p><h3 id="5-Generator和自执行器co的原理"><a href="#5-Generator和自执行器co的原理" class="headerlink" title="5. Generator和自执行器co的原理"></a>5. Generator和自执行器co的原理</h3><p>假设有下面一个读取文件的生成器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到readFile返回一个Promise对象。下面让我们手动来实现一个大概的co执行器:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = gen(); <span class="comment">//生成一个迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">        <span class="keyword">if</span>(result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">        result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            step(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>可以看到这个执行器中，首先生成一个迭代器，然后使用迭代器的next方法开始迭代，先判断当前是否迭代完。如果没有迭代完，通过result.value拿到异步函数的Promise对象，然后在.then中调用step，并将这次Promise的返回值传入step，继续执行异步操作之后的内容。直到迭代完返回最后一次迭代的value。</p><h3 id="6-async原理"><a href="#6-async原理" class="headerlink" title="6. async原理"></a>6. async原理</h3><p>其实一句话async就是Generator的语法糖。上面Generator的例子如果写成async如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。<br>async 函数对 Generator 函数的改进，体现在以下三点。</p><ol><li>内置执行器<br>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li><li>更好的语义<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性<br>co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。<br>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。</p><h3 id="如何捕获异步错误"><a href="#如何捕获异步错误" class="headerlink" title="如何捕获异步错误"></a>如何捕获异步错误</h3><ol><li><p>定义一个函数将try…catch封装起来，然后在向异步函数中传入被封装过的回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatchWrap</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(tryCatchWrapper(test) ,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用window.onerror 监听到了之后统一进行处理</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'window error'</span>, err);</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'async error'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;, 3000);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'sync error'</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-回调的缺陷&quot;&gt;&lt;a href=&quot;#1-回调的缺陷&quot; class=&quot;headerlink&quot; title=&quot;1. 回调的缺陷&quot;&gt;&lt;/a&gt;1. 回调的缺陷&lt;/h3&gt;&lt;p&gt;想完全的理解Promise，需要从异步的发展开始深究，理解Promise的出现是为了解决什么问题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件与事件捕获</title>
    <link href="http://yoursite.com/2018/08/22/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7/"/>
    <id>http://yoursite.com/2018/08/22/事件与事件捕获/</id>
    <published>2018-08-22T07:30:44.000Z</published>
    <updated>2018-08-22T12:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-DOM事件"><a href="#1-DOM事件" class="headerlink" title="1. DOM事件"></a>1. DOM事件</h3><p>《JS高程》上说，触发事件分为三个阶段：事件捕获、到达目标节点、事件冒泡。然而经测试，发现在事件捕获阶段包含到达目标节点。<br>关于DOM事件触发的顺序，分为三个阶段：事件捕获、到达目标阶段、事件冒泡<br>事件捕获:从window=&gt;document=&gt;html=&gt;body=&gt;…=&gt;目标节点的父节点<br>到达目标阶段：如果事件类型是不可冒泡型，则完成当前阶段后事件对象会停止<br>事件冒泡:从目标节点的父节点=&gt;…=&gt;body=&gt;html=&gt;document=&gt;window<br>不会冒泡的事件有：focus、blur、mouseenter、mouseleave</p><h3 id="2-stopPropagation"><a href="#2-stopPropagation" class="headerlink" title="2.stopPropagation"></a>2.stopPropagation</h3><p>event.stopPropagation: 无论在捕获还是冒泡阶段都能停止事件对象。<br>event.stopImmediatePropagation：阻止事件冒泡并且阻止相同事件的其他侦听器被调用。<br>除了这个区别，我在使用chrome浏览器测试时发现，如果在目标对象的捕获阶段进行event.stopPropagation，则还是会冒泡到目标对象的冒泡阶段。<br>如果在目标对象的捕获阶段进行event.stopImmediatePropagation，则不会冒泡到目标对象的冒泡阶段。</p><h3 id="3-mouseover、mouseenter、mousemove、mouseout、mouseleave的执行顺序"><a href="#3-mouseover、mouseenter、mousemove、mouseout、mouseleave的执行顺序" class="headerlink" title="3. mouseover、mouseenter、mousemove、mouseout、mouseleave的执行顺序"></a>3. mouseover、mouseenter、mousemove、mouseout、mouseleave的执行顺序</h3><p>mouseover=&gt;mouseenter=&gt;mousemove=&gt;mouseout=&gt;mouseleave<br>mouseover事件是当鼠标位于一个元素外部，用户将鼠标首次移入另一个元素边界之内时触发。<br>mouseenter事件是鼠标从元素外部移动首次移动到元素之内时触发。<br>mouseout事件是鼠标从一个元素，被用户移入另一个元素时触发。<br>mouseleave事件是位于元素上方的鼠标移动到元素范围之外时触发。<br>mouseout和mouseover事件都会先于mouseenter和mouseleave事件，并且mouseout和mouseover事件都会在这种情况下触发：一个父元素内有一个子元素，将鼠标从父元素移动到子元素时，会触发父元素的mouseout事件和子元素的mouseover事件。</p><h3 id="4-mouseup、mousedown和click的顺序"><a href="#4-mouseup、mousedown和click的顺序" class="headerlink" title="4. mouseup、mousedown和click的顺序"></a>4. mouseup、mousedown和click的顺序</h3><p>mouseup=&gt;mousedown=&gt;click</p><h3 id="5-DOMContentLoaded、load和jquery-onload的执行点"><a href="#5-DOMContentLoaded、load和jquery-onload的执行点" class="headerlink" title="5. DOMContentLoaded、load和jquery.onload的执行点"></a>5. DOMContentLoaded、load和jquery.onload的执行点</h3><p>window的load事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。DOMContentLoaded是在完全加载和解析完HTML文档后执行，无需等待样式表、图片、脚本的加载。</p><h3 id="6-事件委托"><a href="#6-事件委托" class="headerlink" title="6. 事件委托"></a>6. 事件委托</h3><p>事件委托利用了事件冒泡，在父元素上指定一个事件处理程序，管理某一类的所有事件<br>事件委托的好处：我们需要创建和存储在内存中的事件处理函数变少，在父节点上进行事件委托，那么如果删除或添加一个子节点，就不需要再添加或删除事件监听器。在内存中留有过时不用的“空事件处理程序”，也会造成Web应用程序内存与性能问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-DOM事件&quot;&gt;&lt;a href=&quot;#1-DOM事件&quot; class=&quot;headerlink&quot; title=&quot;1. DOM事件&quot;&gt;&lt;/a&gt;1. DOM事件&lt;/h3&gt;&lt;p&gt;《JS高程》上说，触发事件分为三个阶段：事件捕获、到达目标节点、事件冒泡。然而经测试，发现在事件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>各类排序算法</title>
    <link href="http://yoursite.com/2018/08/22/%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/22/各类排序算法/</id>
    <published>2018-08-22T02:24:01.000Z</published>
    <updated>2018-09-03T05:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>冒泡排序是最简单的排序方法，原理就是从后往前遍历，在遍历一次的过程中，如果后面的数比前面的数小，就将小的数放到前面，因此遍历一次就能将当前最小的数冒泡到最前面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=arr.length<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">                arr[j<span class="number">-1</span>]=tmp;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果flag在某次循环中没有更改，则说明已经有序</span></span><br><span class="line">        <span class="keyword">if</span>(flag===<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的平均时间是O(n^2)，最坏情况是O(n^2)，即发生在要排序的数组是逆序情况下，最好情况是O(n)，即发生在元素本来有序的情况下。<br>冒泡排序的稳定性因为每次比较后如果两个相邻元素相等我们并不会将他们交换，所以冒泡不会改变相同元素的下标，所以冒泡排序是一个稳定的排序。<br>冒泡排序适用于数据量较小的场景下。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><ol><li>直接插入排序<br>插入排序，对于一个数组，我们从第二个数字开始，将其认为是新增加的数字，这样第二个数字只需与其左边的第一个数字比较后排好序；在第三个数字，认为前两个已经排好序的数字为手里整理好的牌，那么只需将第三个数字与前两个数字比较即可；以此类推，直到最后一个数字与前面的所有数字比较结束，插入排序完成。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">        <span class="keyword">let</span> key=arr[j];</span><br><span class="line">        <span class="keyword">let</span> i=j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; key&lt;arr[i])&#123;</span><br><span class="line">            arr[i+<span class="number">1</span>]=arr[i]</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序的平均时间是O(n^2)，最坏情况是O(n^2)，即发生在要排序的数组是逆序情况下，最好情况是O(n)，即发生在元素本来有序的情况下。也是稳定排序。<br>适用场景是数据量小时使用。并且大部分已经被排序。</p><ol><li>希尔排序<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2)的第一批算法之一。<br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。<br>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。<br>具体例子参见链接。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> gap = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>); gap &gt;=<span class="number">1</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> j=i-gap;</span><br><span class="line">            <span class="keyword">let</span> key = arr[i]; </span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;key&lt;arr[j])&#123;</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">                j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><ol><li>简单选择排序<br>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>堆排序<br><a href="https://www.cnblogs.com/MOBIN/p/5374217.html" target="_blank" rel="noopener">https://www.cnblogs.com/MOBIN/p/5374217.html</a><br>堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，每个节点都大（小）于它的两个子节点，当每个节点都大于等于它的两个子节点时，就称为大顶堆，也叫堆有序； 当每个节点都小于等于它的两个子节点时，就称为小顶堆。</li></ol><p>算法思想(以大顶堆为例)：<br>1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆<br>2.将根节点与尾节点交换并输出此时的尾节点<br>3.将剩余的n -1个节点重新进行堆有序化<br>4.重复步骤2，步骤3直至构造成一个有序序列<br>具体的步骤参见链接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result=[];</span><br><span class="line">    <span class="keyword">let</span> len = arr.length <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//构造一个大顶堆，树的根节点是数组中的0~Math.floor(arr.length/2)-1位，所以从下到上对每一个根节点进行一个堆有序化的操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        adjustHeap(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将第一个节点与最后一个点交换，这样最大的节点就到了最后一位，然后前面的n-1个节点重新进行堆有序化，继续得到一个大顶堆，然后再重复操作。</span></span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, len--);</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustHeap</span>(<span class="params">arr, i, length</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*i+<span class="number">1</span> &lt;= length)&#123;</span><br><span class="line">        j = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">2</span>*i+<span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">2</span> &lt;= length &amp;&amp; arr[<span class="number">2</span>*i+<span class="number">1</span>] &lt; arr[<span class="number">2</span>*i+<span class="number">2</span>]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(arr, i, <span class="number">2</span>*i+<span class="number">2</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(arr, i, <span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">2</span> &lt;= length &amp;&amp; arr[i] &lt; arr[<span class="number">2</span>*i+<span class="number">2</span>]) &#123;</span><br><span class="line">                j++</span><br><span class="line">                swap(arr, i, <span class="number">2</span>*i+<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之）。</p><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。<br>　　再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。<br>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    split(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">arr, start, end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((start+end)/<span class="number">2</span>);</span><br><span class="line">        split(arr, start, mid);</span><br><span class="line">        split(arr, mid+<span class="number">1</span>, end);</span><br><span class="line">        merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, start, mid, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = start;</span><br><span class="line">    <span class="keyword">let</span> k = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; k&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[k])&#123;</span><br><span class="line">            tmp.push(arr[i++]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp.push(arr[k++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = (i&lt;=mid) ? tmp.concat(arr.slice(i)) : tmp.concat(arr.slice(k));</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        arr[start++] = tmp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的时间复杂度是O(N*logN)，是稳定排序，适用于需要稳定，空间不是很重要的情况下，并且n较大的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1. 冒泡排序&quot;&gt;&lt;/a&gt;1. 冒泡排序&lt;/h3&gt;&lt;p&gt;冒泡排序是最简单的排序方法，原理就是从后往前遍历，在遍历一次的过程中，如果后面的数比前面的数小，就将小的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈一谈模块化的发展</title>
    <link href="http://yoursite.com/2018/08/19/%E8%B0%88%E4%B8%80%E8%B0%88%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <id>http://yoursite.com/2018/08/19/谈一谈模块化的发展/</id>
    <published>2018-08-19T15:58:58.000Z</published>
    <updated>2018-08-27T11:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。<br>模块化的目的：<br>1、代码复杂度随着项目的扩大而增加<br>2、减少模块之间的耦合<br>3、希望减少http请求<br>最原始的js写法，将所有的函数变量都定义在全局变量下，这种写法污染全局空间，很可能会导致变量命名冲突。<br>接着出现模块模式的写法，模块模式使用了立即执行函数，并通过函数参数传递需要的模块变量。模块模式勉强满足了封装的需求。<br>然而只有封装是不够的，还需要加载。html中的js文件加载，难以维护，依赖过多，同时请求也过多。<br>接下来出现了commonJS模块规范，让js跳出了浏览器环境，定义了module 、 exports 、 require 、 global 实现模块的定义和引用。通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入。<br>CommonJS以服务器优先的方式来同步载入模块，假使我们引入三个模块的话，他们会一个个地被载入。<br>它在服务器端用起来很爽，可是在浏览器里就不会那么高效了。<br>CommonJS已经挺不错了，但假使我们想要实现异步加载模块该怎么办？答案就是Asynchronous Module Definition（异步模块定义规范），简称AMD.<br>AMD是并行加载所有依赖的模块, 并完成执行后, 再开始执行其他代码。<br>在一些同时需要AMD和CommonJS功能的项目中，你需要使用另一种规范：Universal Module Definition（通用模块定义规范）。<br>UMD创造了一种同时使用两种规范的方法，并且也支持全局变量定义。所以UMD的模块可以同时在客户端和服务端使用。<br>最后再ES6中定义了模块，使用import和export来导出引入模块。<br>现在出现了webpack模块打包器，使用webpack在打包模块的同时进行优化，通过使用loaders可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。&lt;br&gt;模块化的目的：&lt;br&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CORS</title>
    <link href="http://yoursite.com/2018/08/19/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/08/19/跨域/</id>
    <published>2018-08-19T09:51:20.000Z</published>
    <updated>2018-09-02T07:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a>1. 同源策略</h3><p>同源策略是指协议相同、域名相同、端口相同。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？<br>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h3><p>浏览器将CORS分为两种请求：简单请求和非简单请求<br>对于简单请求，浏览器检测到ajax跨域，会在请求头上添加origin字段，origin字段表示当前请求来自哪个源。如果origin指定的源，在许可范围，服务端返回的响应头中会有：access-control-allow-origin、acess-control-allow-credentials、Access-Control-Expose-Headers。如果origin指定的源，不在许可范围，服务端会正常返回，但是响应头中不会有access-control-allow-origin，从而浏览器抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。<br>对于复杂请求，会先发一个OPTIONS类型的预检请求，会携带origin、Access-Control-Request-Method、Access-Control-Request-Headers请求头。服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。返回的响应头中Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers</p><h3 id="3-iframe-window-name解决跨域问题"><a href="#3-iframe-window-name解决跨域问题" class="headerlink" title="3. iframe+window.name解决跨域问题"></a>3. iframe+window.name解决跨域问题</h3><p>window.name属性的神奇之处在于name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。<br>在A页面，创建一个iframe，iframe的src设置为跨域服务器的地址。然后在iframe onload的时候将iframe的src换成和A页面同一个域名下的proxy页面。然后因为iframe的域名和A是同域，因此就能拿到iframe.contentWindow.name。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript">    iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> state = <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(state === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(iframe.contentWindow.name);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">          iframe.contentWindow.document.write(<span class="string">''</span>);</span></span><br><span class="line"><span class="undefined">          iframe.contentWindow.close();</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.removeChild(iframe);</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(state === <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="undefined">          state = 1;</span></span><br><span class="line"><span class="javascript">          iframe.contentWindow.location = <span class="string">'http://localhost:81/cross-domain/proxy.html'</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    iframe.src = <span class="string">'http://localhost:8080/data.php'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-iframe-location-hash解决跨域问题"><a href="#4-iframe-location-hash解决跨域问题" class="headerlink" title="4. iframe+location.hash解决跨域问题"></a>4. iframe+location.hash解决跨域问题</h3><p>在A页面中创建一个iframe，iframe的src设置为跨域服务器的地址，跨域服务端改变iframe的location并将要传输的数据放在hash中传回。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="comment">// 如果有必要则进行数据处理 $_GET['..']</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// 返回的数据</span></span><br><span class="line">  $data = <span class="string">'&#123;\"name\":\"hanzichi\",\"age\":10&#125;'</span>;</span><br><span class="line">  <span class="keyword">echo</span> </span><br><span class="line">  <span class="string">"</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    window.location = 'http://localhost:81/location-hash/proxy.html' + '#' + \"$data\";</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">  "</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到跨域服务器将iframe的location设置为<a href="http://localhost:81/location-hash/proxy.html，并回传数据。" target="_blank" rel="noopener">http://localhost:81/location-hash/proxy.html，并回传数据。</a><br>然后iframe在onload中获取iframe.contentWindow.location.hash。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">      iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="undefined">      iframe.src = url;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        fn(iframe.contentWindow.location.hash.substring(1));</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.location.hash = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.removeChild(iframe);</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// get data from server</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> url = <span class="string">'http://localhost:8080/data.php'</span>;</span></span><br><span class="line"><span class="javascript">    getData(url, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> jsondata = <span class="built_in">JSON</span>.parse(data);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(jsondata.name + <span class="string">' '</span> + jsondata.age);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-同源策略&quot;&gt;&lt;a href=&quot;#1-同源策略&quot; class=&quot;headerlink&quot; title=&quot;1. 同源策略&quot;&gt;&lt;/a&gt;1. 同源策略&lt;/h3&gt;&lt;p&gt;同源策略是指协议相同、域名相同、端口相同。&lt;br&gt;同源政策的目的，是为了保证用户信息的安全，防止恶意的网
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>页面优化</title>
    <link href="http://yoursite.com/2018/08/19/%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/08/19/页面优化/</id>
    <published>2018-08-19T03:06:41.000Z</published>
    <updated>2018-09-01T03:59:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>文本的先统一讲一讲页面的优化，详讲图片优化、动画优化。</p><h3 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h3><p>从首屏加载时间上来看，10%～20%的最终用户响应时间是花在从Web服务器获取HTML文档，并传送到浏览器中。而剩余的80%～90%的时间都花在了HTML文档所引用的所有组件（图片、脚本、样式表等）。所以优化这部分最重要。<br>对于首屏加载可以做的优化有：</p><ol><li>减少http请求<br>（1）使用CSS Sprites<br>（2）使用内联图片，就是通过使用data:URL模式可以在Web页面中包含图片而无需任何额外的HTTP请求。<br>（3）合并脚本、样式表，减少脚本和样式表的数量就减少HTTP请求。以合并脚本为例，不是要将所有的js都合并到一个文件中，而是需要保持js的模块化<br>减少http请求的好处在哪儿呢？<br>在HTTP1.1版本中有keep-alive的特性，当发送多个http请求，只会建立一次tcp连接。因此发送一次请求相比发送多次请求的优点主要体现在网络延迟上。<br>网络延迟其实是在有keep-alive情况下仍然需要请求合并的主要动力。<br>如果考虑丢包，合并请求更有优势。合并后的文件可以允许队首丢包之后在中间传输过程中补上来，而分开资源的时候，前一个资源未加载完成后面的资源内容是不能加载的，会有更严重的队首阻塞问题，所以丢包率能进一步影响keep-alive下多个小文件的传输。<br>当然合并文件也有缺点。文件合并的越多，合并文件的缓存失效率就越高。</li><li>将静态资源比如：图片、脚本、样式表转移到CDN上。<br>CDN是将源站资源分发至距离用户最近的节点，减少用户请求资源的时间，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载。<br>CDN加速：<br>CDN也会有缓存，当一个请求到达CDN，首先先检测缓存资源是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。</li><li>在服务器上配置使用缓存：expires和cache-control的max-age。<br>当expires和cache-control的max-age没有过期，但是服务器上的资源改变了又应该怎么办呢？最有效的而解决方法就是修改资源链接的文件名。如果时间过期，则发送一个条件GET请求，如果资源没有变则服务器发送一个304的响应，告诉浏览器资源没有改变，并且重新设置expires和cache-control的max-age。</li><li>可以将html、样式表和脚本进行压缩。客户端通过HTTP请求中的Accept-Encodeing来标识对压缩的支持:<br>Accept-Encodeing:gzip, default<br>服务器通过响应中的Content-Encoding:gzip来通知客户端使用哪种压缩方法。<br>压缩通常能将响应的数据量大大减少。<br>压缩的配置取决于服务器的类型和版本。</li></ol><h3 id="2-图片优化"><a href="#2-图片优化" class="headerlink" title="2. 图片优化"></a>2. 图片优化</h3><p>如果将图像原始格式直接存储到文件中将会非常大，比如一个5000<em>5000 24位图，所占文件大小为5000</em>5000*3字节=71.5MB, 其大小非常可观。如果用zip或rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高，因为这些压缩算法没有针对图像数据结构进行特殊处理。<br>于是就有了jpeg,png等格式，同样是图像压缩算法jpeg和png也有不同的适用场景，所以jpeg,png文件之于图像，就相当于zip,rar格式之于普通文件(用zip,rar格式对普通文件进行压缩)。<br>图片一般有三种格式：png、jpeg和bmp。<br>bmp：没有压缩像素格式。<br>jpeg：jpeg是有损压缩格式, 将像素信息用jpeg保存成文件再读取出来，其中某些像素值会有少许变化。jpeg没有透明信息。jpeg比较适合用来存储相机拍出来的照片。<br>png：png是一种无损压缩格式，png可以有透明效果。png比较适合适量图,几何图。<br>jpeg比较适合存储色彩“杂乱”的拍摄图片，png比较适合存储几何特征强的图形类图片。<br>gif：上面提到的bmp,jpeg,png图片都只有一帧，而gif可以保存多帧图像。</p><ol><li>使用CSS Sprites<br>将小图片放在一张图片上进行传输，然后使用background-position定位到需要的图片上。雪碧图的优点是：可以减少http请求。缺点是：如果图片请求失败，雪碧图中的图片页面都无法加载。</li><li>使用css、svg、canvas或iconfont代替图片</li></ol><ul><li>svg：<br>矢量图片，不受像素影响。支持透明，缩放，动画，除了android 2.3的手机，其它场景都支持，是一种比较好的图片代替方案。<br>SVG的结构是 XML，其可访问性（盲文、声音朗读等）、可操作性、可编程性、可被CSS样式化完胜Canvas。另外，其支持 ARIA 属性，使其如虎添翼。<br>SVG对动画的支持较好；其DOM结构可以被其特定语法或者Javascript控制，从而轻松的实现动画<br>SVG功能更完善，适合静态图片展示，高保真文档查看和打印的应用场景。<br>SVG不适合大量元素，但是适合屏幕大的。因为DOM比正常的图形慢，而且如果其结点多而杂，就更慢了。不适合网页游戏等</li><li>canvas：<br>位图，Canvas提供的功能更原始，适合像素处理，动态渲染和大数据量绘制<br>css代替图片：<br>场景：适用于移动端或较高级的浏览器，而且绘制的图案较为简单。<br>原理：css方式可以用来绘制相对简单的团来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。<br>优势：实现简单，可以实现简单的动态效果<br>劣势：也受限于css的兼容性特点，绘制复杂图案困难</li></ul><ol><li>压缩图片<br>优势：减少图片加载流量，效果比较明显  劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持，格式转换要考虑浏览器的兼容性</li></ol><h3 id="3-动画优化"><a href="#3-动画优化" class="headerlink" title="3. 动画优化"></a>3. 动画优化</h3><ol><li>避免强制reflow<br>浏览器是在下一帧、下一次渲染的时候才reflow，并不是JS执行完这一行改变样式的语句之后立即重排，所以你可以在JS语句里写100行改CSS的语句，但是只会在下一帧的时候重排一次。<br>然而强制reflow会导致浏览器立刻reflow，因此要尽量避免强制reflow的操作。强制reflow主要有：clientWidth、offsetWidth、scrollWidth、getBoundingClientRect等。</li><li>将必要的动画提升至合成层，通过开启3D加速或使用will-change属性<br>提升至合成层动画不需要重绘，只需要重新合成即可。这样动画的处理会很高效。<br>will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用 will-change 会导致大量的内存占用。最佳实践是当元素变化之前和之后通过脚本来切换 will-change 的值。</li><li>避免隐式合成<br>尽量让需要进行 CSS 动画的元素的 z-index 保持在页面最上方，避免浏览器创建不必要的合成层（GraphicsLayer），能够很好的提升渲染性能。</li><li>使用css动画<br>css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。而如果使用js动画，浏览器必须计算每一帧的状态；为了保证平滑的动画，我们必须在浏览器主线程计算新状态；把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画； 当主线程的计算任务过多时，会造成动画的延迟、卡顿。</li><li>尽量使用transform 代替 left、top，减少使用耗性能样式<br>现代浏览器在完成以下四种属性的动画时，消耗成本较低：<br>position（位置）: transform: translate(npx, npx)<br>scale（比例缩放）：transform: scale(n)<br>rotation（旋转） ：transform: rotate(ndeg)<br>opacity（透明度）：opacity： 0…1<br>如果可以，尽量只使用上述四种属性去控制动画。</li></ol><h3 id="4-项目优化"><a href="#4-项目优化" class="headerlink" title="4. 项目优化"></a>4. 项目优化</h3><ol><li>DNS预获取 dns-prefetch 提升页面载入速度<br>当我们从该 URL 请求一个资源时，就不再需要等待 DNS 的解析过程。该技术对使用第三方资源特别有用。通过简单的一行代码就可以告知那些兼容的浏览器进行 DNS 预解析，这意味着当浏览器真正请求该域中的某个资源时，DNS 的解析就已经完成了,从而节省了宝贵的时间。<br>另外需要注意的是，浏览器会对a标签的href自动启用DNS Prefetching，所以a标签里包含的域名不需要在head中手动设置link。但是在HTTPS下不起作用，需要meta来强制开启功能。这个限制的原因是防止窃听者根据DNS Prefetching推断显示在HTTPS页面中超链接的主机名。下面这句话作用是强制打开a标签域名解析</li><li>JavaScript 模块打包<br>使用Webpack模块打包，可以保持js的模块化，对于优化主要体现如下：</li></ol><ul><li>optimization.splitChunks<br>将entry文件的公共引用模块提取出来，<br>将node_modules提取到vendors中</li><li>通过externals配置来提取常用库<br>配置后可以告知webapck遇到此类变量名时就可以不用解析和编译至模块的内部文件中，而改用从外部变量中读取，这样能极大的提升编译速度，同时也能更好的利用CDN来实现缓存。</li><li>使用Happypack加速你的代码构建<br>Happypack的出发点就是，让可以并发执行的loader，加快构建。</li><li>uglifyJSPlugin<br>压缩js代码<br>使用webpack，保持模块化的同时，减少资源文件的加载，压缩代码，加快项目构建速度和减少http请求</li></ul><ol><li>按需加载资源<br>图片懒加载</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文本的先统一讲一讲页面的优化，详讲图片优化、动画优化。&lt;/p&gt;
&lt;h3 id=&quot;1-优化&quot;&gt;&lt;a href=&quot;#1-优化&quot; class=&quot;headerlink&quot; title=&quot;1. 优化&quot;&gt;&lt;/a&gt;1. 优化&lt;/h3&gt;&lt;p&gt;从首屏加载时间上来看，10%～20%的最终用户响应
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Webpack4</title>
    <link href="http://yoursite.com/2018/08/17/Webpack4/"/>
    <id>http://yoursite.com/2018/08/17/Webpack4/</id>
    <published>2018-08-17T06:45:43.000Z</published>
    <updated>2018-08-27T14:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>webpack的核心是用于现代JavaScript应用程序的静态模块捆绑器。 当webpack处理您的应用程序时，它会在内部构建一个依赖关系图，它映射您的项目所需的每个模块并生成一个或多个包。</p><h3 id="1-Webpack解析过程"><a href="#1-Webpack解析过程" class="headerlink" title="1. Webpack解析过程"></a>1. Webpack解析过程</h3><p>首先，从入口文件开始，webpack开始解析文件中引用到的模块，这里使用JavaScript parser。JavaScript parser是可以读和理解JavaScript代码的工具，它生成一个更抽象的模型，称为AST（抽象语法树）。AST包含了很多我们代码的信息。接下来我们遍历AST找出当前模块依赖哪些模块，也就是当前模块import了哪些模块。在这一步也会使用当前文件对应的loader来编译当前文件，以便将当前文件包含到最终的bundle中。<br>接下来，我们将提取每个模块的依赖模块，原理大概是：</p><ol><li>定义一个数组queue，将entry文件的相关信息存入queue，相关信息会包括entry的filename和entry的依赖项dependencies等。</li><li>遍历数组queue的每一项，对当前项的dependencies对应路径的文件再进行JavaScript parser，然后将这个文件的相关信息再存入queue中，从而最终遍历完成，构建出一个依赖图。<br>最后，由这个依赖图构建一个bundle文件。简单而言，从入口文件开始，如果有依赖模块，则根据路径拿到该模块export的内容</li></ol><h3 id="2-loader"><a href="#2-loader" class="headerlink" title="2. loader"></a>2. loader</h3><p>webpack通过loader支持用各种语言和预编译器编写的模块，loader向webpack描述如何处理非JavaScript模块并将这些依赖项添加到依赖关系图中。<br>常用的loader有：<br>babel-loader、css-loader、file-loader、less-loader<br>下面主要讲一讲babel的原理：<br>babel类似于一个编译器，将同种语言的高版本规则翻译成低版本规则，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p><blockquote><p>ES6代码输入 ==》 babylon进行解析 ==》 得到AST<br>==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树<br>==》 用babel-generator通过AST树生成ES5代码</p></blockquote><h3 id="3-optimization"><a href="#3-optimization" class="headerlink" title="3. optimization"></a>3. optimization</h3><p>optimization被用来执行一些优化的操作。<br>CommonsChunkPlugin和optimization.splitChunks：webpack4已经移除CommonsChunkPlugin可以用optimization.splitChunks代替当有多个入口文件时，可能每个入口文件都有相同的引用，所以可以优化将相同的引用给取出来，模块之间的公共引用给取出就叫做chunk，splitChunks可以具体配置如何拆分。<br>vendor是针对node_module中的第三方库，将公用的第三方库提出来，放在公共chunk中。</p><h3 id="4-plugin"><a href="#4-plugin" class="headerlink" title="4. plugin"></a>4. plugin</h3><p>plugin被用来执行一些优化bundle、资产管理和环境变量注入的功能。<br>经常会用到的plugin有：UglifyjsWebpackPlugin、ExtractTextWebpackPlugin、HtmlWebpackPlugin、HotModuleReplacementPlugin<br>下面分别介绍一下：</p><ol><li><strong>HtmlWebpackPlugin</strong><br>HtmlWebpackPlugin简化了html文件的创建</li><li><strong>ExtractTextWebpackPlugin</strong><br>ExtractTextWebpackPlugin将入口文件中所有引入css模块的部分，提出到一个单独的css文件中</li><li><strong>UglifyjsWebpackPlugin</strong><br>用来缩小JS的代码量</li><li><strong>HotModuleReplacementPlugin</strong><br>热模块更换（HMR）在应用程序运行时交换，添加或删除模块，无需完全重新加载。热加载的好处如下：</li></ol><ul><li>保留在完全重新加载期间丢失的应用程序状态。</li><li>只需更新已更改的内容，即可节省宝贵的开发时间。</li><li>更快地调整样式 - 几乎可以与浏览器调试器中的样式更改相媲美。<br>下面讨论一下热加载的原理：<br><strong>从应用程序来讲：</strong><br>应用程序要求HMR runtime检查更新。<br>runtime异步的下载更新，并且通知应用程序<br>应用程序让runtime去进行更新<br>runtime程序异步的进行更新<br><strong>从编译器来讲：</strong><br>编译器的更新包括两个方面：</li><li>更新 manifest </li><li>更新chunks<br>编译后需要保持chunks和module的能对应上<br>manifest文件包含了新的编译后的hash和更新的chunks。<br><strong>从模块来讲：</strong><br>应用程序让HMR去进行更新模块，在模块中包含HMR的处理函数，当HMR通知模块更新，模块就进行更新。但是很多时候不强制在模块中写HMR接口，所以当模块没有HMR处理函数，更新就会冒泡，这就意味着，一个小模块的更新会让整个模块树更新。<br><strong>从runtime来讲：</strong><br>runtime可以跟踪父模块和子模块。runtime支持check和apply这两个方法。<br>check方法发送HTTP请求更新manifest。如果请求失败，就没有内容可更新；请求成功，则下载所有需要更新的chunks，所有的模块更新都存储在runtime中。当所有的chunks更新都被下载下来并且准备被应用，runtime的状态切换到ready状态。<br>apply方法将所有待更新的模块标记为无效，无效模块或者其父模块需要有更新处理函数，否则，将其父模块也标记为无效，并继续冒泡，一直冒到某个模块有更新处理函数，如果一直冒到entry文件都没有，则处理失败。<br>之后，所有无效模块都被处理（通过配置处理程序）并卸载。runtime切换回空闲状态，一切都正常继续。<br>上面讲的都是放屁，实现HMR需要开启一个server，然后当文件改变通过websocket或者sse通知浏览器，浏览器获取到改变了之后的内容，再更新到网页中去。</li></ul><h3 id="5-mode"><a href="#5-mode" class="headerlink" title="5. mode"></a>5. mode</h3><p>这是webpack4的新特性，通过设置mode为production或development，可以启用与每个环境相对应的webpack内置优化。 默认值为production。</p><h3 id="6-runtime"><a href="#6-runtime" class="headerlink" title="6. runtime"></a>6. runtime</h3><p>在一个用webpack构建的应用程序中，有三类代码：</p><ul><li>源代码</li><li>第三方库的代码</li><li>用于执行所有模块交互的webpack runtime和manifest<br>下面主要介绍第三类代码。分为runtime和manifest。<br>runtime和manifest是当运行在浏览器时，webpack用来连接模块化应用程序的代码，它包含在模块交互时连接模块所需的加载和解析逻辑。 这包括连接已经加载到浏览器中的模块以及延迟加载尚未加载的模块的逻辑。<br>随着编译器进入，解析并映射出应用程序，manifest会记录所有模块的详细说明，包括模块的位置等。当运行时，runtime在解析并加载模块时，会需要从manifest中查询模块位置。</li></ul><h3 id="7-Webpack4的新特性"><a href="#7-Webpack4的新特性" class="headerlink" title="7. Webpack4的新特性"></a>7. Webpack4的新特性</h3><ol><li>需要设置mode<br>在webpack4中直接指定mode，可以针对不同环境的默认优化配置，比如development模式的NamedModulesPlugin和NamedChunksPlugin。<br>production模式的UglifyJsPlugin、NoEmitOnErrorsPlugin、ModuleConcatenationPlugin</li><li>webpack4删除了CommonsChunkPlugin插件，它使用内置API optimization.splitChunks</li><li>需要安装webpack -cli</li></ol><h3 id="8-development和production环境下配置的不同"><a href="#8-development和production环境下配置的不同" class="headerlink" title="8. development和production环境下配置的不同"></a>8. development和production环境下配置的不同</h3><p><strong>development</strong></p><ul><li>source-map<br>方便展示错误信息来自具体哪个文件，方便调试</li><li>webpack-dev-server<br>提供一个简单的server<br><strong>production</strong></li><li>UglifyjsWebpackPlugin</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;webpack的核心是用于现代JavaScript应用程序的静态模块捆绑器。 当webpack处理您的应用程序时，它会在内部构建一个依赖关系图，它映射您的项目所需的每个模块并生成一个或多个包。&lt;/p&gt;
&lt;h3 id=&quot;1-Webpack解析过程&quot;&gt;&lt;a href=&quot;#1-W
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>输入一个URL</title>
    <link href="http://yoursite.com/2018/08/16/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL/"/>
    <id>http://yoursite.com/2018/08/16/输入一个URL/</id>
    <published>2018-08-16T15:41:11.000Z</published>
    <updated>2018-09-02T07:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>封装HTTP请求</li><li>TCP连接</li><li>IP层</li><li>服务器处理请求并返回响应报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="1-DNS解析"><a href="#1-DNS解析" class="headerlink" title="1. DNS解析"></a>1. DNS解析</h3><p>首先对请求的域名进行DNS解析成一个IP地址。过程如下：<br>（1）将待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。如果本地域名服务器查找到域名，就把对应的IP地址返回。如果本地域名服务器不能查找到域名，则由本地域名服务器接手查询<br>（2）本地域名服务器向根域名服务器的查询通常采用迭代查询。也就是根域名服务器告诉本地域名服务器需要向某个顶级域名服务器请求，然后本地域名服务器去请求顶级域名服务器<br>（3）本地域名服务器去请求顶级域名服务器，顶级域名服务器要么给出所要查询的ip地址，要么告诉本地域名服务器下一步应当向哪个权限域名服务器进行查询<br>（4）最终一步一步的本地域名服务器知道了ip地址，将结果返回给发起查询的主机。<br>（5）为了提高查询效率，在域名服务器中广泛使用了高速缓存。</p><h3 id="2-封装HTTP请求"><a href="#2-封装HTTP请求" class="headerlink" title="2. 封装HTTP请求"></a>2. 封装HTTP请求</h3><p>发送一个HTTP请求，一个HTTP请求包括：状态行、请求头、请求体<br>http请求头有四种类型，分别是通用头部，请求头部，响应头部以及内容头部<br>content-type是属于内容头部<br>前端向后台传输的数据有几种类型：表单、字符串、json<br>通过Content-Type来告诉后台当前请求数据的类型，常见的媒体格式类型如下：<br>text/html ： HTML格式<br>text/plain ：纯文本格式<br>text/xml ： XML格式<br>image/gif ：gif图片格式<br>image/jpeg ：jpg图片格式<br>image/png：png图片格式<br>通过Content-Type来告诉后台前端传输的数据类型，常见的类型如下：<br>application/json ：传递的是一个json对象。<br>application/x-www-form-urlencoded ：发送表单<br>multipart/form-data ：需要在表单中进行文件上传时，就需要使用该格式。<br>HTTP请求头字段：cookie、connection、Content-Type、Host、If-Match、If-Modified-Since、If-None-Match<br>| Header | 解释 | 示例 |<br>|  |  |  |<br>| :—-: | :—–: | :—-: |<br>| Accept | 指定客户端能够接收的内容类型 | Accept: text/plain, text/html,application/json |<br>| Accept-Charset | 浏览器可以接受的字符编码集。 | Accept-Charset: iso-8859-5 |<br>| Accept-Encoding | 指定浏览器可以支持的web服务器返回内容压缩编码类型。 | Accept-Encoding: compress, gzip |<br>| Accept-Language | 浏览器可接受的语言 | Accept-Language: en,zh |<br>| Accept-Ranges | 可以请求网页实体的一个或者多个子范围字段 | Accept-Ranges: bytes |<br>| Cache-Control | 指定请求和响应遵循的缓存机制 | Cache-Control: no-cache |<br>| Upgrade | 向服务器指定某种传输协议以便服务器进行转换（如果支持） | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 |</p><h3 id="3-TCP连接"><a href="#3-TCP连接" class="headerlink" title="3. TCP连接"></a>3. TCP连接</h3><h4 id="3-1-TCP的特性"><a href="#3-1-TCP的特性" class="headerlink" title="3.1 TCP的特性"></a>3.1 TCP的特性</h4><p>TCP 提供一种面向连接的、可靠的字节流服务<br>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP<br>TCP 使用校验和，确认和重传机制来保证可靠传输。<br>校验和是一个端到端的校验和，由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。<br>确认和重传：当发送方发送的数据丢失或延迟，接收方迟迟没有回应确认时，发送方会再发送一遍。<br>TCP使用校验和，但是有时候就是会出现数据错误却通过校验值检验的奇葩情况。因此TCP不一定可靠。有条件的话可以在通信协议中增加自己的校验机制。<br>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复<br>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。<br>慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h4 id="3-2-TCP三次握手"><a href="#3-2-TCP三次握手" class="headerlink" title="3.2 TCP三次握手"></a>3.2 TCP三次握手</h4><p>ACK是确认包，SYN是同步位<br>第一次客户端发送SYN=1，seq=x，发送完毕，客户端进入 SYN_SEND 状态。<br>第二次服务端发送SYN=1，ACK=1，ack=x+1，seq=y，发送完毕，服务端进入 SYN_RCVD 状态。<br>第三次客户端发送ACK=1，seq=x+1,ack=y+1，发送完毕，客户端进入ESTABLISHED状态。<br>进行三次握手的原因是防止已失效的链接2请求报文又传回了服务器，如果客户端发送连接请求给服务端，但是请求延误，客户端认为请求失败，可能又会发起一次新的请求。过了一会儿刚才延误的请求报文发送到了服务器，服务器发送响应包，如果只有两次握手，则此时服务器认为连接建立完成，分配好了资源和客户端通信，但客户端在之前已经认为第一次请求失败，便不会理会服务端发送的响应包。因此可以看出只有两次握手的话，可能会浪费服务器资源。</p><h4 id="3-3-TCP四次挥手"><a href="#3-3-TCP四次挥手" class="headerlink" title="3.3 TCP四次挥手"></a>3.3 TCP四次挥手</h4><p>FIN是连接终止位<br>第一次客户端发送FIN=1，seq=u，客户端进入FIN-WAIT-1状态<br>第二次服务端发送ACK=1，seq=v，ack=u+1，服务端进入CLOSE_WAIT状态。此时客户端到服务端的连接释放了，此时TCP处于半关闭的状态。也就是客户端不会发送数据给服务端了。<br>第三次服务端发送FIN=1，ACK=1，seq=w，ack=u+1，客户端进入FIN_WAIT_2阶段。<br>第四次客户端发送ACK=1，seq=u+1,ack=w+1,客户端进入TIME_WAIT状态，经过TIME_WAIT设置的等待时间2MSL后，客户端才进入CLOSED状态。服务端收到后进入CLOSE状态</p><h4 id="3-4-UDP"><a href="#3-4-UDP" class="headerlink" title="3.4 UDP"></a>3.4 UDP</h4><p>UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：<br>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。<br>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。<br>UDP 支持多播和广播。</p><h3 id="4-IP层"><a href="#4-IP层" class="headerlink" title="4. IP层"></a>4. IP层</h3><p>建立起TCP连接后，请求也被传送到客户端主机的网络层。网络层实现的最重要的功能是路由选择，简单地说，就是怎么把这一个IP数据报从客户端主机出发，通过网络中的若干个路由器，到达目的主机。<br>路由选择机制的基础是在每一台主机和路由器里都存储着一张路由表。路由表的每一项包含了目的主机IP地址、下一跳路由器（或主机）的IP地址。</p><h3 id="5-服务器处理请求并返回HTTP报文"><a href="#5-服务器处理请求并返回HTTP报文" class="headerlink" title="5. 服务器处理请求并返回HTTP报文"></a>5. 服务器处理请求并返回HTTP报文</h3><p>目标主机收到了请求后，自底向上地对该请求进行处理。链路层把数据报传给网络层，网路层将TCP数据段通过对应的Socket传给应用程序。应用程序处理请求后产生一个应答的HTTP报文，又经过了一层层的封装、一跳跳的传输到达了源主机。</p><h3 id="6-浏览器解析渲染页面"><a href="#6-浏览器解析渲染页面" class="headerlink" title="6. 浏览器解析渲染页面"></a>6. 浏览器解析渲染页面</h3><p>首先需要了解到浏览器是多进程，包括Browser进程（1个）、GPU进程（1个）、Render进程（多个）。<br>Browser进程：UI线程（创建tab页面，用户操作选择tab页）、IO线程、File线程、数据库线程<br>Render进程：主要的那个进程，每个tab一个。负责执行JS和页面渲染。包含3个线程：Compositor Thread、Tile Worker、Main thread，后文会介绍这三个线程。<br>GPU进程：是和GPU打交道的进程，负责将Renderer进程中绘制好的位图作为纹理上传至GPU，并调用GPU的相关方法把纹理draw到屏幕上。<br>打开浏览器Browser进程启动，调用Browser进程创建一个Tab，用户输入url回车后，将请求结果传递给Render进程，Render进程将结果交给main线程，main线程解析并开始解析渲染网页。<br><img src="render1.png" alt=""></p><h4 id="6-1-生成render-tree"><a href="#6-1-生成render-tree" class="headerlink" title="6.1 生成render tree"></a>6.1 生成render tree</h4><p>首先将html解析成DOM树，并且处理avaScript给元素设置的样式而已。Recalculate Style会计算Render树（渲染树）,然后从根节点开始进行页面渲染，将CSS附加到DOM上的过程。<br>将CSS解析成CSS对象模型（CSSOM），对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则，DOM树和CSSOM两者结合生成render tree。在解析过程中如果遇到js标签就会下载解析执行。</p><h4 id="6-2-layout阶段"><a href="#6-2-layout阶段" class="headerlink" title="6.2 layout阶段"></a>6.2 layout阶段</h4><p>render tree结束之后进入layout阶段。在上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。</p><h4 id="6-3-paint阶段"><a href="#6-3-paint阶段" class="headerlink" title="6.3 paint阶段"></a>6.3 paint阶段</h4><ol><li>Render Object<br>layout阶段之后是paint阶段。paint阶段有一个Render Object的概念，Render Object和DOM节点一一对应。Render Object上实现了将其对应的DOM节点绘制进位图的方法，负责绘制这个DOM节点的可见内容如背景、边框、文字内容等等。同时Render Object也是存放在一个树形结构中的。<br>位图：浏览器可以用位图来记录他想在某个区域绘制的内容。使用一个二维数组，数组中的元素记录这个图片中的每一个像素的具体颜色。然后进行绘制。</li><li>Render Layer<br>但仅仅只有Render Object还是不够的，因为浏览器还存在层叠上下文，就是元素间的相互覆盖关系。因此还有一个Render Layer的概念。当然Render Layer的出现并不是简单因为层叠上下文等，比如opacity小于1、比如存在mask等等需要先绘制好内容再对绘制出来的内容做一些统一处理的css效果。<br>总之就是有层叠、半透明等等情况的元素（具体哪些情况请参考无线性能优化：Composite）就会从Render Object提升为Render Layer。不提升为Render Layer的Render Object从属于其父级元素中最近的那个Render Layer。当然根元素HTML自己要提升为Render Layer。<br>因此现在Render Object树就变成了Render Layer树，每个Render Layer又包含了属于自己layer的Render Object。<br>Render Layer 树决定了网页绘制的层次顺序，而从属于 Render Layer 的 Render Object 决定了这个 Render Layer 的内容，所有的 Render Layer 和 Render Object 一起就决定了网页在屏幕上最终呈现出来的内容。</li><li>Graphics Layers(又称Compositing Layer)和Graphics Context<br>但是事情还没有结束还有Graphics Layers和Graphics Context。<br>上面的过程可以搞定绘制过程。但是浏览器里面经常有动画、video、canvas、3d的css等东西。这意味着页面在有这些元素时，页面显示会经常变动，也就意味着位图会经常变动。每秒60帧的动效里，每次变动都重绘整个位图是很恐怖的性能开销。<br>因此浏览器为了优化这一过程。引出了Graphics Layers(又称Compositing Layer)和Graphics Context，前者就是我们常说的合成层(Compositing Layer)。<br>Render Layer提升为Graphics Layer的情况：</li></ol><ul><li>3D 或透视变换(perspective、transform、translate3d、translateZ) CSS 属性</li><li>使用加速视频解码的 元素</li><li>拥有 3D (WebGL) 上下文或加速的 2D 上下文的 元素</li><li>混合插件(如 Flash)</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</li><li>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）</li><li>拥有加速 CSS 过滤器的元素</li><li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul><p>3D transform、will-change设置为 opacity、transform等 以及 包含opacity、transform的CSS过渡和动画 这3个经常遇到的提升合成层的情况，更多的参见<a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/04/25/performance-composite/</a><br>每个合成层Graphics Layer 都拥有一个 Graphics Context，Graphics Context 会为该Layer开辟一段位图，也就意味着每个Graphics Layer都拥有一个位图。Graphics Layer负责将自己的Render Layer及其子代所包含的Render Object绘制到位图里。然后将位图作为纹理交给GPU。</p><h4 id="6-4-composite阶段"><a href="#6-4-composite阶段" class="headerlink" title="6.4 composite阶段"></a>6.4 composite阶段</h4><p>现在GPU需要对多层纹理进行合成(composite)，而且GPU对于这个过程是底层硬件加速的，性能很好。最终，纹理合成为一幅内容最终draw到屏幕上。<br>所以在元素存在transform、opacity等属性的css animation或者css transition时，动画处理会很高效，这些属性在动画中不需要重绘，只需要重新合成即可。</p><p>如果是使用js修改DOM元素的样式，那么先计算样式，然后layout(重排) -&gt; paint(重绘) -&gt; composite(合成)</p><h3 id="7-Renderer进程的三个线程"><a href="#7-Renderer进程的三个线程" class="headerlink" title="7. Renderer进程的三个线程"></a>7. Renderer进程的三个线程</h3><ul><li>Compositor Thread<br>这个线程既负责接收浏览器传来的垂直同步信号(Vsync，水平同步表示画出一行屏幕线，垂直同步就表示从屏幕顶部到底部的绘制已经完成，指示着前一帧的结束，和新一帧的开始)， 也负责接收OS传来的用户交互，比如滚动、输入、点击、鼠标移动等等。<br>如果可能，Compositor Thread会直接负责处理这些输入，然后转换为对layer的位移和处理，并将新的帧直接commit到GPU Thread，从而直接输出新的页面。否则，比如你在滚动、输入事件等等上注册了回调，又或者当前页面中有动画等情况，那么这个时候Compositor Thread便会唤醒Main Thread，让后者去执行JS、完成重绘、重排等过程，产出新的纹理，然后Compositor Thread再进行相关纹理的commit至GPU Thread，完成输出。</li><li>Main Thread<br>chrome devtools的Timeline里Main那一栏显示的内容就是Main Thread完成的相关任务：某段JS的执行、Recalculate、 Layout Tree、Paint、Composite Layers等等。是浏览器执行我们都知道和喜爱的任务的地方：JavaScript，样式，布局和绘画。</li><li>Compositor Tile Worker(s)<br>可能有一个或多个线程，比如PC端的chrome是2个或4个，安卓和safari为1个或2个不等。是由Compositor Thread创建的，专门用来处理tile的Rasterization（前文说过的光栅化）。<br><img src="render2.png" alt=""></li></ul><h3 id="8-重排-Layout、强制重排-Force-Layout"><a href="#8-重排-Layout、强制重排-Force-Layout" class="headerlink" title="8. 重排 Layout、强制重排 Force Layout"></a>8. 重排 Layout、强制重排 Force Layout</h3><p>在正常情况下，修改了一个影响元素布局信息的CSS样式，比如width、height、left、top等（transform除外），那么浏览器会将当前的Layout标记为dirty，这会使得浏览器在下一帧执行上述11个步骤的时候执行Layout。因为元素的位置信息变了，将可能会导致整个网页其他元素的位置情况都发生改变，所以需要执行Layout全局重新计算每个元素的位置。<br>需要注意到，浏览器是在下一帧、下一次渲染的时候才重排。并不是JS执行完这一行改变样式的语句之后立即重排，所以你可以在JS语句里写100行改CSS的语句，但是只会在下一帧的时候重排一次。<br>如果你在当前Layout被标记为dirty的情况下，访问了offsetTop、scrollHeight等属性，那么，浏览器会立即重新Layout，计算出此时元素正确的位置信息，以保证你在JS里获取到的offsetTop、scrollHeight等是正确的。<br>会触发重排的属性和方法:<br>比如clientWidth、offsetWidth、scrollWidth、getBoundingClientRect等<br><img src="render3.png" alt=""></p><h3 id="9-进程和线程"><a href="#9-进程和线程" class="headerlink" title="9. 进程和线程"></a>9. 进程和线程</h3><ul><li>进程和线程的本质<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.<br>线程是进程的一个实体,是CPU调度和分派的基本单位, 它是比进程更小的能独立运行的基本单位.</li><li>资源管理方式<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。而线程只是一个进程中的不同执行路径，它可与同属一个进程的其他的线程共享进程所拥有的资源，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉</li><li>进程和线程的切换<br>线程上下文切换和进程上下文切换一个最主要的区别是线程的切换使用的内存空间依然是相同的；但是进程切换是不同的，所以进程切换时，耗费资源较大。</li></ul><p>参考：<br><a href="https://juejin.im/entry/59f010fdf265da4315231caa" target="_blank" rel="noopener">https://juejin.im/entry/59f010fdf265da4315231caa</a><br><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/" target="_blank" rel="noopener">http://taobaofed.org/blog/2016/04/25/performance-composite/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总体来说分为以下几个过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS解析&lt;/li&gt;
&lt;li&gt;封装HTTP请求&lt;/li&gt;
&lt;li&gt;TCP连接&lt;/li&gt;
&lt;li&gt;IP层&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回响应报文&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面&lt;/li&gt;
&lt;li&gt;连接结束&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React理解</title>
    <link href="http://yoursite.com/2018/08/15/React%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/15/React理解/</id>
    <published>2018-08-15T14:57:00.000Z</published>
    <updated>2018-09-03T06:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、React-Element"><a href="#1、React-Element" class="headerlink" title="1、React Element"></a>1、React Element</h3><p>React Element是React的virtual DOM，本质上就是一个普通的对象，相较于浏览器的DOM更加轻量，它是Component的组成部分，是构建React应用的最小单元。<br>React Element通常由render函数返回的JSX创建，但其本质上只是React.createElement(component, props, …children)的语法糖。<br>React Element有类型之分，比如JSX的标签名就决定了React Element的类型，不同的JSX标签，就是不同类型的React Element。<br>React Element有内容（children）和属性（attribute），但是一旦React Element被创建之后，是无法改变其内容或属性的。即，React Element都是immutable不可变的。<br>更新界面的唯一办法是创建一个新的React Element，会由React DOM对比（diff）新旧React Element之后，只把改变了的部分更新到浏览器DOM上。</p><h3 id="2、React-Components"><a href="#2、React-Components" class="headerlink" title="2、React Components"></a>2、React Components</h3><p>React的主要特征就是由Components组成。Components可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。<br><strong>所有的React组件必须像纯函数那样使用它们的props</strong>，就是不能修改props，只能使用props。<br>满足以下两点称为纯函数：</p><ul><li>返回的值仅依赖于传入的参数，而不依赖于内部或外部的其它状态</li><li>纯函数运行没有副作用（例如本地静态变量或非局部变量的变异，或执行I / O操作）</li></ul><h4 id="2-1-Functional-amp-amp-Class-Component"><a href="#2-1-Functional-amp-amp-Class-Component" class="headerlink" title="2.1 Functional &amp;&amp; Class Component"></a>2.1 Functional &amp;&amp; Class Component</h4><p>Functional Component 函数定义的组件需要是一个函数，接收单一的props对象作为参数，然后返回一个React Element。<br>Class Component 使用ES6语法定义的组件，必须继承自React.Component（或PureComponent），实现render函数并返回React Element。Class Component可以有自己的state，用来实现局部状态（或封装）。</p><h4 id="2-2-PureComponent"><a href="#2-2-PureComponent" class="headerlink" title="2.2 PureComponent"></a>2.2 PureComponent</h4><p>PureComponent改变了生命周期方法shouldComponentUpdate，并且它会自动检查组件是否需要重新渲染。这时，只有PureComponent检测到state或者props发生变化时，PureComponent才会调用render方法。<br>PureComponent对state和props的变化都是浅比较，浅比较的意思是对state或props中每个属性之前和之后的值使用Object.is来进行比较。可以看出Object.is可以对基本数据类型:null,undefined,number,string,boolean做出非常精确的比较，但是对于引用数据类型是没办法直接比较的。<br>所以PureComponent的使用场景是：</p><ul><li>props和state的对象中的属性值都是简单类型</li><li>确定深层数据结构改变时使用forceUpdate</li><li>使用immutable对象<br>React.PureComponent 的 shouldComponentUpdate() 会跳过整个组件子树的 prop 更新，也就是如果父PureComponent不更新，子组件也不可能更新；父PureComponent更新，子组件才更新。因此使用时请确保所有子组件同样是“纯”的。</li></ul><h3 id="3、-组件生命周期"><a href="#3、-组件生命周期" class="headerlink" title="3、 组件生命周期"></a>3、 组件生命周期</h3><ol><li>首次装载组件时，按顺序执行：getDefaultProps、getInitialState、componentWillMount、render和componentDidMount；</li><li>在重新装载组件时，此时按顺序执行 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps；</li><li>当再次渲染组件时，组件接受到更新状态，此时按顺序执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate。</li><li>当卸载组件时，执行 componentWillUnmount；<br>如下图所示：<br><img src="react1.png" alt=""><br>React 通过三种状态：MOUNTING、RECEIVE_PROPS、UNMOUNTING，管理整个生命周期的执行顺序。这三个状态对应三种方法，分别为：mountComponent、updateComponent、unmountComponent。<br>状态一：MOUNTING<br>mountComponent负责管理生命周期中的getInitialState、componentWillMount、render和componentDidMount。<br>由于getDefaultProps是通过Constructor进行管理，因此也是整个生命周期中最先开始执行，而mountComponent只能望洋兴叹，无法调用到getDefaultProps。这就解释了为何getDefaultProps只执行1次的原因。<br>由于通过ReactCompositeComponentBase返回的是一个虚拟节点，因此需要利用instantiateReactComponent去得到实例，再使用mountComponent拿到结果作为当前自定义元素的结果。关于这部分将虚拟节点转换成DOM元素的过程还是有必要再深挖的。<br>首先通过mountComponent装载组件，此时，将状态设置为MOUNTING，利用getInitialState获取初始化state，初始化更新队列。<br>若存在componentWillMount，则执行；如果此时在componentWillMount中调用setState，是不会触发reRender，而是进行state合并。<br>到此时，已经完成MOUNTING的工作，更新状态为NULL，同时state也将执行更新操作，此刻在render中可以获取更新后的this.state数据。<br>其实，mountComponent本质上是通过递归渲染内容的，由于递归的特性，父组件的componentWillMount一定在其子组件的componentWillMount之前调用，而父组件的componentDidMount肯定在其子组件的componentDidMount之后调用。<br>当渲染完成之后，若存在componentDidMount则触发。这就解释了componentWillMount-render-componentDidMount三者之间的执行顺序。<br>如下图所示：<br><img src="react2.png" alt=""><br>状态二：RECEIVE_PROPS<br>updateComponent负责管理生命周期中的componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate。<br>首先通过updateComponent更新组件，如果前后元素不一致说明需要进行组件更新，此时将状态设置为RECEIVING_PROPS。<br>若存在componentWillReceiveProps，则执行；如果此时在componentWillReceiveProps中调用setState，是不会触发reRender，而是进行state合并。<br>到此时，已经完成RECEIVING_PROPS工作，更新状态为NULL，同时state也将执行更新操作，此刻this.state可以获取到更新后的数据。<br>调用shouldComponentUpdate判断是否需要进行组件更新，如果存在componentWillUpdate，则执行。<br>updateComponent本质上也是通过递归渲染内容的，由于递归的特性，父组件的componentWillUpdate一定在其子组件的componentWillUpdate之前调用，而父组件的componentDidUpdate肯定在其子组件componentDidUpdate之后调用。<br>当渲染完成之后，若存在componentDidUpdate，则触发，这就解释了componentWillReceiveProps-componentWillUpdate-render-componentDidUpdate它们之间的执行顺序。<br>如下图所示：<br><img src="react3.png" alt=""><br>状态三：UNMOUNTING<br>unmountComponent负责管理生命周期中的componentWillUnmount。<br>首先将状态设置为UNMOUNTING，若存在componentWillUnmount，则执行；如果此时在componentWillUnmount中调用setState，是不会触发reRender。更新状态为NULL，完成组件卸载操作。</li></ol><h3 id="2-setState的更新机制"><a href="#2-setState的更新机制" class="headerlink" title="2 setState的更新机制"></a>2 setState的更新机制</h3><p>setState在React合成事件和react的生命周期函数中执行是异步的，而在一些异步（setTimeout、ajax请求）和原生DOM事件中是同步的。在React17中可能会全部处理为异步。<br>在setState之后进行了如下的流程：<br>调用enqueueSetState方法，这个方法获取当前组件的internalInstance，将setState中需要更新的state参数push进internalInstance._pendingStateQueue中，然后将internalInstance交给enqueueUpdate处理。<br>调用enqueueUpdate这个方法，在这个方法中有一个isBatchingUpdates的状态，这个状态标识是否处于创建、更新阶段。</p><ol><li>如果不处于创建、更新阶段（isBatchingUpdates为false），则执行batchedUpdates开启批量更新，在batchedUpdates中做了两件事：</li></ol><ul><li>将isBatchingUpdates设为true</li><li>用事务transaction.perform执行更新事务<br>这两件事后就处于创建、更新阶段。</li></ul><ol><li>如果处于创建、更新阶段，就不会立刻去更新组件，而是先把当前的组件放在dirtyComponent里。所以不是每一次的setState都会更新组件，这就解释了我们常常听说的：setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新。</li></ol><h3 id="3-批量更新"><a href="#3-批量更新" class="headerlink" title="3 批量更新"></a>3 批量更新</h3><p>第一种情况, React 在首次渲染组件的时候会调用batchedUpdates, 然后开始渲染组件。那么为什么要在这个时候启动一次batch呢? 不是因为要批量插入, 因为插入过程是递归的, 而是因为组件在渲染的过程中, 会依顺序调用各种生命周期函数, 开发者很可能在生命周期函数中(如componentWillMount或者componentDidMount)调用setState. 因此, 开启一次batch就是要存储更新(放入dirtyComponents), 然后在事务结束时批量更新. 这样以来, 在初始渲染流程中, 任何setState都会生效, 用户看到的始终是最新的状态。<br>第二种情况, 如果你在HTML元素上或者组件上绑定了事件, 那么你有可能在事件的监听函数中调用setState, 因此, 同样为了存储更新(放入dirtyComponents), 需要启动批量更新策略. 在回调函数被调用之前, React事件系统中的dispatchEvent函数负责事件的分发, 在dispatchEvent中启动了事务, 开启了一次batch, 随后调用了回调函数. 这样一来, 在事件的监听函数中调用的setState就会生效.也就是说, 任何可能调用 setState 的地方, 在调用之前, React 都会启动批量更新策略以提前应对可能的setState。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// We're not in an event handler, so these are flushed separately.</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">a</span>: <span class="literal">true</span>&#125;); <span class="comment">// Re-renders with &#123;a: true, b: false &#125;</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">b</span>: <span class="literal">true</span>&#125;); <span class="comment">// Re-renders with &#123;a: true, b: true &#125;</span></span><br><span class="line">  <span class="keyword">this</span>.props.setParentState(); <span class="comment">// Re-renders the parent</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2、React虚拟节点和diff算法"><a href="#2、React虚拟节点和diff算法" class="headerlink" title="2、React虚拟节点和diff算法"></a>2、React虚拟节点和diff算法</h3><p>在不使用现代框架的早期阶段，当页面上数据状态变更后，需要操作对应的DOM元素，页面上监听的事件越多，回调中的DOM操作也越多。手动进行DOM的操作，有两个缺陷：<br>1、操作DOM的复杂性，使代码结构不清晰<br>2、人为操作DOM，可能性能不回达到最佳<br>既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了MVVM模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图。<br>MVVM可以很好的降低我们维护状态-&gt;视图的复杂程度（大大减少代码中的视图更新逻辑）。<br>然而对于react的VirtualDOM而言，即使一个小小的状态变更都要重新构造整棵DOM。只是在react的实现中，加了一些特别的步骤来避免整棵DOM树变更。<br>一个DOM元素的属性非常多，处理DOM不可能会比JS对象处理起来快。VirtualDOM使用JS对象来表示一个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    id: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对应的HTML写法是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以上面所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。<br>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。<br>diff算法返回的是最优更新DOM的方式。<br>然而，使用Virtual DOM不一定在性能上强于直接操作DOM：<br>因为使用diff算法，需要先比较两棵Virtual DOM树，得出需要变化的部分，最后再去修改DOM。这个过程可能不比直接操作DOM要快。<br>但是使用virtual dom最大的好处是：</p><ul><li>抽象了视图层的操作方法，使用用户可以不用直接操作DOM；</li><li>同时在大量操作DOM时，一定比大量操作Virtual DOM效率低。<br>传统的diff算法，算法复杂度高达 O(n^3)，改进后的算法复杂度为O(n)<br>diff算法优化基于三点前提：</li><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li><li>两个不同类型的元素将产生不同的树。</li><li>通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。<br>基于以上三个前提假设，React 分别对 tree diff、component diff 以及 element diff 进行算法优化</li></ul><ol><li><p>tree diff<br>根据前提1，React diff算法将树进行分层，两棵树只会对同一层次的节点进行比较。<br>既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<br>当存在跨层级的移动操作呢？此时也是按层比较，不会进行元素层级间的移动，而会新增或是删除节点。这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。</p></li><li><p>component diff</p></li></ol><ul><li><p>针对不同类型的元素<br>React会销毁该元素及其所有的子元素，并重新构建新的元素及其所有的子元素；<br>DOM元素：直接销毁并重建；<br>Component元素：销毁前，该Component实例会收到componentWillUnmount()；重建时，新Component实例会收到componentWillMount() 和 componentDidMount()，这会导致该Component的state丢失。</p></li><li><p>针对相同类型的元素<br>DOM元素：例如div、h1等，React会比较两者的属性，仅更新变化的属性，并递归其子元素；<br>Component元素：会保留该Component的实例，并在该实例上依次调用componentWillReceiveProps() 和 componentWillUpdate() 方法，该Component的state会保留。在组件元素的render方法被调用的时候，diff算法会继续以该Component为根元素进行递归处理；</p></li></ul><ol><li>element diff<br>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。<br>当同一层上节点一样，但是节点顺序不同，更新时对每一个节点都需要进行插入新节点和删除旧节点的操作，导致操作繁琐冗余。因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。<br>针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！<br>有key：为了提高效率并保证稳定性，可以给所有的children加“key”。该key值需要在同一兄弟元素之间应该是独一无二的，这样就能快速地通过该key值做对比，本质上是一种hash的思想。</li></ol><h4 id="3-React-数据是如何驱动视图的"><a href="#3-React-数据是如何驱动视图的" class="headerlink" title="3. React 数据是如何驱动视图的"></a>3. React 数据是如何驱动视图的</h4><p>MVVM的viewmodel层将数据与视图进行绑定，操作数据等同于操作视图，数据修改后视图自动更新。<br>当state或者是props发生变化后，将该组件标记为dirty，然后生成一个新的VDOM 树，对比新旧VDOM树，使用diff算法进行更新操作。</p><h4 id="4-废弃的react生命周期原因及新生命周期如何适配旧的生命周期"><a href="#4-废弃的react生命周期原因及新生命周期如何适配旧的生命周期" class="headerlink" title="4. 废弃的react生命周期原因及新生命周期如何适配旧的生命周期"></a>4. 废弃的react生命周期原因及新生命周期如何适配旧的生命周期</h4><p>componentWillMount、componentWillReceiveProps、componentWillUpdate是即将在17版本中被标记为unsafe的生命周期函数。这里的“不安全”不是指安全性，而是传达使用这些生命周期的代码更有可能在React的未来版本中出现错误，特别是在启用异步渲染时。</p><ol><li>componentWillMount<br><strong>使用constructor和componentDidMount来覆盖</strong></li></ol><ul><li>如果要在componentWillMount中放入setState改变状态，可以将这部分代码放入constructor中。</li><li>如果要在componentWillMount中进行异步操作，可以将这部分代码写在componentDidMount中。</li><li>如果想在componentWillMount中订阅事件，可能会发生内存泄漏，因为如果server rendering或异步rendering出错，componentWillUnmount将不会触发，因此就无法在componentWillUnmount中进行取消订阅，导致内存泄漏。应该将componentWillMount中的订阅事件放入componentDidMount中，这样只有在server rendering或异步rendering顺利执行后才会调用componentDidMount，就不会发生内存泄漏。</li></ul><ol><li>componentWillReceiveProps<br><strong>总结来说当有关根据props更新state就将这部分逻辑存放在getDerivedStateFromProps中，如果和异步操作有关（如数据更新）就使用componentDidUpdate。</strong><br>因为componentWillReceiveProps和componentWillUpdate可能会在正式更新之前调用好几次，所以要避免将有副作用的操作放在这个生命周期函数中执行，而应该将这些放入componentDidUpdate方法中，因为componentDidUpdate确保只执行一次。<br>componentWillReceiveProps方法用于根据props更新state，但它经常被错误地用于确实存在问题的方式。 因此该方法将被弃用。<br>响应props以更新state的推荐方法是使用新的静态getDerivedStateFromProps生命周期。getDerivedStateFromProps使用在实例化组件之后以及re-render组件之前，它可以返回一个更新state的对象，或者返回null以指示新的props不需要任何state更新。</li><li>componentWillUpdate<br><strong>使用getSnapshotBeforeUpdate和componentDidUpdate来覆盖。</strong><br>有时候componentWillUpdate需要用来比如重新渲染期间手动保留滚动位置时，但是因为异步渲染，所以“渲染”阶段生命周期（如componentWillUpdate和render）和“commit”阶段生命周期（如componentDidUpdate）之间可能存在延迟。 如果用户在此期间执行类似调整窗口大小的操作，则从componentWillUpdate读取的scrollHeight值将过时。此问题的解决方案是使用新的“提交”阶段生命周期getSnapshotBeforeUpdate。 在进行突变之前（例如在更新DOM之前）立即调用该方法。 它可以返回一个React的值作为参数传递给componentDidUpdate，它在突变后立即被调用。<br>很多时候人们会误用componentWillUpdate是担心componentDidUpdate触发时，更新其他组件的状态“为时已晚”。但react确保任何setState在componentDidMount和componentDidUpdate调用时，会在用户看到UI之前立刻刷新。如果在componentWillUpdate中对state变化进行事件绑定，componentWillUpdate可能会发生多次，导致进行多次事件绑定，因此可以将这部分内容放在componentDidUpdate中进行。</li></ol><h4 id="5-react和vue"><a href="#5-react和vue" class="headerlink" title="5. react和vue"></a>5. react和vue</h4><p>在vue中createElement方法用来创建一个虚拟节点。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。<br></p><ul><li>JSX vs Template<br>对于一些开发者而言，模板更容易理解；并且相比JSX，模板可以更好的把功能和布局分割开来；并且比起模板，渲染函数更易于调试和测试。</li><li>数据层<br>React组件内部通过state来维护组件状态的变化，这也是state唯一的作用。<br>React里的state只能用setState方法改变。使用setState可以合并需要修改的state，避免多次触发reRender。<br>Vue中的数据是可变的（mutated）</li><li>如何实现批量更新<br>react使用setState，vue使用nextTick<br>Vue会把一轮事件循环(即一次task)中所有触发的watcher去重后添加到一个队列里，然后将这个队列交由Vue.nextTick()，即将这个队列添加到microtask中，这样在本次task结束后，按照规则就会取出所有的microtask执行它们，实现DOM的更新。<br>就是说如果方法是通过React调用的比如生命周期函数，React的事件处理等，那么会进行批量更新，自己调用的方法，比如setTimeout，xhr等则是连续更新。当批量更新时，react将组件需要更新的状态放入dirtyComponents队列中。在react中有事务（transaction）的概念，事务就是在真正执行method之前加一些预处理和之后加一些尾处理。react将mounting放入method中，然后在mounting结束后的尾处理中，进行批量更新。<br>看到批量更新vue和react的区别：<br>vue：<br>依赖浏览器Api与事件处理队列<br>不可控(我们无法通过编码改变它)<br>react:<br>纯JS实现，不依赖浏览器Api<br>可控性强，可手动调用(因为可编码)<br>是否异步需要看具体场景，易出错(需要对源码有了解)</li><li>生命周期<br>生命周期不一样</li><li>组件间的数据通信<br>vue：<br>子=&gt;父通信:通过父组件给子组件传递的回调函数，和子组件的自定义事件通信<br>react：<br>子=&gt;父通信:通过父组件给子组件传递的回调函数<br>共同：<br>父=&gt;子通信:props<br>兄弟组件之间的通信：寻找其共同的父组件，使用数据和相关方法“提升”到父组件内部，并向下传给两个子组件。其中一个子组件取得数据，另一个子组件取得了改变数据的方法。<br>全局通信：可以定义一个全局的eventEmitter，一个地方发送消息，另一个地方监听并接收消息，很容易想到的就是发布订阅模式了。</li><li>事件<br>vue中的事件分为两种一种DOM绑定事件还有一种是自定义事件，自定义事件用于子组件向父组件传递数据，子组件使用$emit触发一个自定义事件，父组件使用v-on监听这个自定义事件。<br>react中的事件是合成事件。在DOM中事件处理函数是一个字符串，而在react的JSX语法中是一个函数。在react中不能使用return false表明阻止默认行为，而必须明确使用preventDefault，在React中定义了合成事件，不需要考虑浏览器的兼容性。使用es6的class语法来定义一个组件时，事件处理器会成为类的一个方法。<br>DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。<br>合成事件有几个特性：<br>1、合成事件对象是共享的，只有一个，这是出于性能因素考虑。在当前事件回调完成之后，会初始化事件对象属性的内容，以便下一次重用。<br>2、合成事件是基于事件委托实现的。直接在DOM树的document上监听原生事件，然后合成对应的事件，根据target分发到对应的React Element上去。同时还实现了event poll，就是事件池，这样可以复用合成的事件对象。</li></ul><h4 id="6-新特性和改进"><a href="#6-新特性和改进" class="headerlink" title="6. 新特性和改进"></a>6. 新特性和改进</h4><p>New render return types: fragments and strings; (支持返回数组组件)<br>Better error handling （更好的错误处理）<br>Portals （新特性）<br>Better server-side rendering （更好的服务端渲染）<br>Support for custom DOM attributes （支持自定义 DOM 属性）<br>Reduced file size （体积更小）<br>New core architecture （新的 Fiber 架构）</p><p>参考文章：<br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a><br><a href="https://zhuanlan.zhihu.com/p/20312691" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20312691</a><br><a href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973" target="_blank" rel="noopener">https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973</a><br><a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710" target="_blank" rel="noopener">https://github.com/facebook/react/issues/11527#issuecomment-360199710</a><br><a href="https://zhuanlan.zhihu.com/p/20328570" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20328570</a><br><a href="https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/blob/master/stack/book/Part-1.md" target="_blank" rel="noopener">https://github.com/Bogdan-Lyashenko/Under-the-hood-ReactJS/blob/master/stack/book/Part-1.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、React-Element&quot;&gt;&lt;a href=&quot;#1、React-Element&quot; class=&quot;headerlink&quot; title=&quot;1、React Element&quot;&gt;&lt;/a&gt;1、React Element&lt;/h3&gt;&lt;p&gt;React Element是Reac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP杂说</title>
    <link href="http://yoursite.com/2018/08/15/HTTP%E6%9D%82%E8%AF%B4/"/>
    <id>http://yoursite.com/2018/08/15/HTTP杂说/</id>
    <published>2018-08-15T06:14:46.000Z</published>
    <updated>2018-09-04T02:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、GET和POST"><a href="#1、GET和POST" class="headerlink" title="1、GET和POST"></a>1、GET和POST</h3><p>GET方法是安全方法，安全是指因为GET方法只是执行获取资源的动作，而POST方法被用于请求服务器接受请求中的实体，作为请求资源的一个新的从属物，所以可能会执行不安全动作。<br>GET方法有幂等性，幂等的意思是相同的请求请求结果一样，所以GET是幂等性<br>如果请求消息包含If-Modified-Since，If-Unmodified-Since，If-Match，If-None-Match或者 If-Range头域， GET的语义将<br>变成“条件(conditionall) GET”。一个条件GET方法会请求满足条件头域的实体。条件 GET 方法的目的是为了减少不必要的网络使用，<br>这通过允许利用缓存里仍然保鲜的实体而不用多次请求或传输客户端已经拥有的实体来实现的。<br>POST里的响应是不可缓存的。</p><h3 id="2、HTTP状态码"><a href="#2、HTTP状态码" class="headerlink" title="2、HTTP状态码"></a>2、HTTP状态码</h3><ul><li><strong>1**</strong> 信息，服务器收到请求，需要请求者继续执行操作</li><li><strong>2**</strong> 成功，操作被成功接收并处理</li><li><strong>3**</strong> 重定向，需要进一步的操作以完成请求</li><li><strong>4**</strong> 客户端错误，请求包含语法错误或无法完成请求</li><li><strong>5**</strong> 服务器错误，服务器在处理请求的过程中发生了错误</li></ul><ol><li><p>100(Continue)<br>HTTP1.1中新加入100响应码，目的在于允许客户端判定服务器是否愿意接受客户端发来的消息主体（基于请求头，Expect:<br>100-continue），如果服务端愿意接受，返回100（Continue），不愿意接受返回417（Expectation Failed），表示客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。</p></li><li><p>200(OK)<br>请求成功。请求所希望的响应头或数据体将随此响应返回<br>206(Partial Content)</p></li><li><p>3XX<br>下面主要介绍3开头的和重定向有关的状态码。客户端发送请求，服务端返回一个3开头的状态码，那么客户端会请求服务端返回的新URL。<br>有很多重定向，可以分为三类：<br>永久重定向、暂时重定向和特殊重定向。<br>永久重定向的是301和308，暂时重定向是302、303和307，特殊重定向是300和304。</p></li></ol><ul><li>301(Moved Permanently)<br>永久移动。<br>请求资源被赋予一个新的永久URI，并且任何将来对此资源的引用都会利用这个新的URI。<br>如果客户端接收了一个来自非GET或HEAD请求方法的301响应， 那么就不能自动的向新URI发送重复请求，除非得到用户的确认。<br>使用场景：想换个域名，旧的域名不用啦，这样用户访问旧域名时用301就重定向到新的域名。</li><li>308(Permanent Redirect)</li><li>302(Found)<br>临时移动。<br>请求的资源暂时地存放在一个不同的URI下。<br>如果客户端发出非GET请求后，收到服务端的302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。<br>但是，很多浏览器都把302当作303处理了，它们获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。<br>使用场景：有时系统进行升级，需要临时更换地址。</li><li>303(See Other)<br>见其他。<br>请求的响应被放在一个不同的URI下，并且应该用GET方法获得那个资源。<br>如果客户端发出POST或PUT请求后，收到服务端的303状态码，那么浏览器获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。<br>使用场景：防止POST或PUT请求的二次触发</li><li>307(Temporary Redirect)<br>临时重定向。<br>如果客户端发出非GET请求，那么规范要求其他的请求方法必须等客户确认才能跳转。<br>请求方法和请求体都不会改变。<br>307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。</li><li>300(Multiple Choice)<br>多项选择。<br>是一种手工重定向：响应的消息主体中包含了一个可能的重定向链接的列表，用户可以从中进行选择。</li><li>304(Not Modified)<br>没有修改。<br>表示缓存值依然有效。</li></ul><h3 id="3、HTTP请求报文"><a href="#3、HTTP请求报文" class="headerlink" title="3、HTTP请求报文"></a>3、HTTP请求报文</h3><p>HTTP请求报文包括：起始行、请求头和请求体</p><h3 id="4、HTTP版本"><a href="#4、HTTP版本" class="headerlink" title="4、HTTP版本"></a>4、HTTP版本</h3><h4 id="4-1-HTTP1-1相比HTTP1-0"><a href="#4-1-HTTP1-1相比HTTP1-0" class="headerlink" title="4.1 HTTP1.1相比HTTP1.0"></a>4.1 HTTP1.1相比HTTP1.0</h4><ol><li><p>请求方法<br>HTTP1.0中只有三个请求方法：GET、POST、HEAD<br>HTTP1.1中增加了PUT、DELETE、OPTIONS、TRACE、CONNECT</p></li><li><p>长连接<br>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li><li><p>新增100响应码<br>HTTP1.1中新加入100响应码，目的在于允许客户端判定服务器是否愿意接受客户端发来的消息主体（基于请求头，Expect: 100-continue），如果服务端愿意接受，返回100（Continue），不愿意接受返回417（Expectation Failed），表示客户端错误，意味着服务器无法满足 Expect 请求消息头中的期望条件。</p></li><li><p>新添Host头<br>HTTP1.1中添加Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p>缓存<br>HTTP1.0中的缓存使用Pragma和Expires来规范，Pragma通过no-cache来禁用缓存，Expires来规定缓存的过期时间。<br>HTTP1.1中使用cache-control来规定缓存的过期时间，或是禁用缓存，如果缓存过期，则进入第二步与服务端进行再验证使用if-modified-since、if-none-match来进行再验证。</p></li></ol><h4 id="4-2-HTTP2-0相比HTTP1-1"><a href="#4-2-HTTP2-0相比HTTP1-1" class="headerlink" title="4.2 HTTP2.0相比HTTP1.1"></a>4.2 HTTP2.0相比HTTP1.1</h4><ol><li><p>请求数量<br>HTTP1.1协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。<br>而HTTP2中多路复用的特性允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。能实现多路复用是因为新增二进制分帧层，消息分帧后可以乱序发送，然后再根据每个帧头部的流标识符重新组装</p></li><li><p>请求头压缩<br>在HTTP1.x中，头部元数据都是以纯文本的形式发送的，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自<br>cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p>服务器推送<br>服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。<br>比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一<br>轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、GET和POST&quot;&gt;&lt;a href=&quot;#1、GET和POST&quot; class=&quot;headerlink&quot; title=&quot;1、GET和POST&quot;&gt;&lt;/a&gt;1、GET和POST&lt;/h3&gt;&lt;p&gt;GET方法是安全方法，安全是指因为GET方法只是执行获取资源的动作，而POS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise理解进阶篇</title>
    <link href="http://yoursite.com/2018/08/13/Promise%E7%90%86%E8%A7%A3%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>http://yoursite.com/2018/08/13/Promise理解进阶篇/</id>
    <published>2018-08-13T01:52:57.000Z</published>
    <updated>2018-08-23T09:52:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Promise状态变化"><a href="#1、Promise状态变化" class="headerlink" title="1、Promise状态变化"></a>1、Promise状态变化</h3><p>首先看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleUp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line">    .then(increment)</span><br><span class="line">    .then(doubleUp)</span><br><span class="line">    .then(output)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise chain中出现异常的时候会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这个例子中我们先看这一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>意思是决议promise的状态，在promise决议之后，会立刻异步调用两个处理函数中的一个，比如是fulfilled状态，则将then的onFulfilled回调函数放入microTask队列，如果是reject状态，则将调用onRejected回调函数放入microTask队列。<br>increment函数有一个参数，这个参数是由Promise.resolve(1)传入的。进入increment函数后，可以看到return value+1，然后increment函数到此为止，其实没这么简单，return的值会由Promise.resolve(return的返回值); 进行相应的包装处理，不管回调函数返回或者不返回，then都会返回一个新建的promise对象，当回调函数有return返回值时生成一个promise，[[PromiseStatus]]是”resolved”，[[PromiseValue]]是return的返回值。当回调函数没有return时，生成的promise，[[PromiseStatus]]是”resolved”，[[PromiseValue]]是undefined。<br>resolve的中文是决议，决议的结果可能是完成也可能是拒绝。比如可以向resolve中传递一个Promise.reject的返回值，那么决议的结果就是拒绝。reject不像resolve会将传入的值展开，如果向reject传入一个promise/thenable值，它就会原封不动的将这个值设置为拒绝理由。</p><h3 id="2、catch和then-onRejected-的区别"><a href="#2、catch和then-onRejected-的区别" class="headerlink" title="2、catch和then(onRejected)的区别"></a>2、catch和then(onRejected)的区别</h3><p>try…catch很好但是无法用于异步的错误捕获。node中的error-first风格可以用于异步的错误处理，但是无法很好的组合，需要写很多if判断。promise没有采用error-first风格，而是用来分离回调风格，一个回调用于完成情况，一个回调用于拒绝情况。<br>那么catch和then(onRejected)这两种捕获异常的方法，咱们用哪一种呢？<br>首先要考虑的是兼容问题。在IE8以下，使用的是ES3规范，在ECMAScript 3中保留字是不能作为对象的属性名使用的，因此不能将catch作为属性来使用。而现在的浏览器都是基于ECMAScript 5的，而在ECMAScript 5中保留字都属于IdentifierName，也可以作为属性名使用了。在es3中实在想用，可以使用中括号标记法（bracket notation）的话，则可以将非合法标识符作为对象的属性名使用。或者我们不单纯的使用catch，而是使用then也是可以避免这个问题的。<br>还有一个区别是，then中的onRejected是不能捕获到onFulfilled中抛出的错误，而catch可以。</p><h3 id="3、使用reject而不是throw"><a href="#3、使用reject而不是throw" class="headerlink" title="3、使用reject而不是throw"></a>3、使用reject而不是throw</h3><p>在promise中并不需要通过throw来抛出一个错误，完全可以用reject来代替。<br>Promise的构造函数，以及被then调用执行的函数基本上都可以认为是在 try…catch 代码块中执行的，所以在这些代码中即使使用throw，程序本身也不会因为异常而终止。<br>如果在Promise中使用throw语句的话，会被 try…catch 住，最终promise对象也变为Rejected状态。<br>如果使用throw我们很难区分到底是程序抛出异常，还是人为抛出，在浏览器的调试功能中有一个在程序发生异常的时，自动break调试的功能，如果我们人为抛出一个错，浏览器开启这个功能时也会自动break调试，从而影响浏览器提供此功能的正常使用。<br>如果想在then中进行reject，怎么办呢？<br>当然是定义一个promise，并返回，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> onRejected = <span class="built_in">console</span>.error.bind(<span class="built_in">console</span>);</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"this promise is rejected"</span>));</span><br><span class="line">&#125;).catch(onRejected);</span><br></pre></td></tr></table></figure><h3 id="4、异步错误处理"><a href="#4、异步错误处理" class="headerlink" title="4、异步错误处理"></a>4、异步错误处理</h3><p>既然上面两节提到了错误处理，这一节我们来研究关于异步的错误处理。<br>使用try…catch只能进行同步的错误处理</p><h3 id="5、Promise-all和Promise-race"><a href="#5、Promise-all和Promise-race" class="headerlink" title="5、Promise.all和Promise.race"></a>5、Promise.all和Promise.race</h3><p>Promise.all接收一个promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用.then方法。<br>比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([request.comment(), request.people()]);</span><br></pre></td></tr></table></figure></p><p>request.comment()和request.people()会同时执行，这两个promise的结果会按照顺序返回，即在下一个then的onFulfilled回调函数中接受的参数首先是一个数组，然后这个数组的顺序和Promise.all参数数组的顺序一致，所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 按照[comment, people]的顺序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>传递给Promise.all的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。<br>Promise.all在接收到的所有的对象promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，与之相对的是Promise.race只要有一个promise对象进入FulFilled或者Rejected状态的话，就会继续进行后面的处理。Promise.race在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</p><h3 id="6、Promise顺序执行"><a href="#6、Promise顺序执行" class="headerlink" title="6、Promise顺序执行"></a>6、Promise顺序执行</h3><p>Promise.all方法，传入元素为Promise的数组，all方法开始执行时，所有的Promise同时执行，不分先后，当数组中的每一个Promise状态都变成resolve或reject时，这个方法才算执行完。<br>Promise.all可以提供同时执行，但是无法提供顺序执行。<br>下面就以请求url为例，来实现Promise的顺序执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> Promsie(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeous(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeous(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeous(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// tasks中的不是Promise的数组，而是方法</span></span><br><span class="line">    <span class="keyword">var</span> tasks = [ajax1, ajax, ajax3];</span><br><span class="line">    sequenceTasks(tasks).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(results);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的关键就是定义 sequenceTasks 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">var</span> resultSave = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = tasks[i];</span><br><span class="line">        promise = promise.then(task).then(resultSave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个顺序执行就基本实现了，如果觉得在实现上不好看，可以用 Array.prototype.reduce 来改进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">var</span> resultSave = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(task).then(resultSave);</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-promise相比于普通回调的性能"><a href="#7-promise相比于普通回调的性能" class="headerlink" title="7. promise相比于普通回调的性能"></a>7. promise相比于普通回调的性能</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Promise状态变化&quot;&gt;&lt;a href=&quot;#1、Promise状态变化&quot; class=&quot;headerlink&quot; title=&quot;1、Promise状态变化&quot;&gt;&lt;/a&gt;1、Promise状态变化&lt;/h3&gt;&lt;p&gt;首先看下面代码：&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="http://yoursite.com/2018/02/07/HTTP%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/07/HTTP缓存/</id>
    <published>2018-02-07T02:12:33.000Z</published>
    <updated>2018-02-26T13:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习HTTP缓存，使用缓存是网站优化的重要步骤。本文是对《HTTP权威指南》第七章缓存的一些摘要和总结。</p><p>在商业应用中，使用缓存服务器来提高性能降低对原始服务器的要求。对一条HTTP GET报文的基本缓存处理过程包括7个步骤 ：</p><p>(1)  接收——缓存从网络中读取抵达的请求报文。<br>(2)  解析——缓存对报文进行解析，提取出 URL 和各种首部。<br>(3)  查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地)。<br>(4)  新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。<br>(5)  创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。<br>(6)  发送——缓存通过网络将响应发回给客户端。<br>(7)  日志——缓存可选地创建一个日志文件条目来描述这个事务。</p><p>这个过程如下图所示：</p><p><img src="http1.png" alt=""></p><p>其中对于新鲜度检测这一步，HTTP协议有两个机制：文档过期和服务器再验证来保持缓存中副本的新鲜度。</p><h3 id="1、文档过期"><a href="#1、文档过期" class="headerlink" title="1、文档过期"></a>1、文档过期</h3><p>通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。</p><p>Cache-Control首部和Expires首部告诉客户端到了某个时间点（比照客户端时间点）后本地缓存就过期了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示返回200（强缓存），一旦资源命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。Chrome下的现象是200 OK (from disk cache) 或者 200 OK (from memory cache).</p><p>但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果文档被修改过，就要获取一份新鲜(带有新的过期日期)的副本。 </p><p>服务器用HTTP/1.0+的Expires首部或HTTP/1.1的<code>Cache-Control: max-age</code>响应首部来指定过期日期，同时还会带有响应主体。Expires首部和<code>Cache-Control: max-age</code>首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。 </p><p>Cache-Control在浏览器缓存中是金字塔顶尖的规则，它会覆盖一切与之相悖的规则。因此当Expires与之相悖时，就会忽略Expires。</p><h3 id="2、服务器再验证"><a href="#2、服务器再验证" class="headerlink" title="2、服务器再验证"></a>2、服务器再验证</h3><p>如果仅仅是Cache-Control首部和Expires首部规定的时间点过期了，那并不意味着它和原始服务器上目前正处于活跃状态的文档有实际区别。</p><p>这只是意味着到了要核对的时间了。这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。 </p><p>客户端检测到数据过期后，会向服务器发送一个get请求。在请求中一般会携带If-Modified-Since或If-None-Match请求头。</p><p>先说If-Modified-Since。如果在指定日期之后资源发生了变化，GET请求就会成功执行返回200响应。携带新首部的新文档会被返回给缓<br>存，新首部除了其他信息之外，还包含了一个新的过期日期。 如果自指定日期后，文档没被修改过，会向客户端返回一个304 Not Modified 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，Content-Type 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。 </p><p>再说If-None-Match。有些情况下仅使用最后修改日期进行再验证是不够的。 比如：</p><p>(1)  有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。<br>(2)  再比如有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。<br>(3)  有些服务器无法准确地判定其页面的最后修改日期。<br>(4)  有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。 </p><p>在这些情况下HTTP允许用户对被称为实体标签(ETag)的“版本标识符” 进行比较。实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。</p><p>当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用 If-None-Match 条件首部收到一条200已缓存的成功响应，返回新的内容以及相应的新 Etag。当实体标签没有被修改，就会返回304未修改响应。</p><p>如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有实体标签条件首部ETag，那么只有这两个条件都满足时，才能返回 304 Not Modified 响应。</p><p>HTTP规范从未指定生成ETag的方法。生成ETag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。</p><h3 id="3、关于Cache-Control"><a href="#3、关于Cache-Control" class="headerlink" title="3、关于Cache-Control"></a>3、关于Cache-Control</h3><p>服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以: </p><p>附加一个Cache-Control:no-store首部到响应中去;</p><p>附加一个Cache-Control:no-cache首部到响应中去;</p><p>附加一个Cache-Control:must-revalidate首部到响应中去; </p><p>附加一个Cache-Control:max-age首部到响应中去;</p><p>附加一个Expires日期首部到响应中去;</p><p>不附加过期信息，让缓存确定自己的过期日期。</p><p>标识为 no-store 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。 </p><p>标识为 no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。 我的理解是no-cache是表示max-age=0即立马过期。</p><p><code>Cache-Control: max-age</code>首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数 。</p><h3 id="4、关于Expires响应首部"><a href="#4、关于Expires响应首部" class="headerlink" title="4、关于Expires响应首部"></a>4、关于Expires响应首部</h3><p>不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。</p><h3 id="5、当响应中没有Cache-Control-max-age首部，也没有-Expires-首部时"><a href="#5、当响应中没有Cache-Control-max-age首部，也没有-Expires-首部时" class="headerlink" title="5、当响应中没有Cache-Control: max-age首部，也没有 Expires 首部时"></a>5、当响应中没有<code>Cache-Control: max-age</code>首部，也没有 Expires 首部时</h3><p>如果响应中没有<code>Cache-Control: max-age</code>首部，也没有 Expires 首部，那么使用LM-Factor 算法 的试探性过期算法，用当前时间Date与文档的最后修改时间之差，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。</p><h3 id="6、用户操作行为与缓存"><a href="#6、用户操作行为与缓存" class="headerlink" title="6、用户操作行为与缓存"></a>6、用户操作行为与缓存</h3><p>用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按F5刷新等，这些行为会对缓存有什么影响呢？</p><p><img src="http2.png" alt=""></p><p>通过上表我们可以看到，当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；而当用户使用Ctrl+F5进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习HTTP缓存，使用缓存是网站优化的重要步骤。本文是对《HTTP权威指南》第七章缓存的一些摘要和总结。&lt;/p&gt;
&lt;p&gt;在商业应用中，使用缓存服务器来提高性能降低对原始服务器的要求。对一条HTTP GET报文的基本缓存处理过程包括7个步骤 ：&lt;/p&gt;
&lt;p&gt;(1)  
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM中外部资源的解析与优化</title>
    <link href="http://yoursite.com/2018/01/28/DOM%E4%B8%AD%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/28/DOM中外部资源的解析与优化/</id>
    <published>2018-01-28T14:57:39.000Z</published>
    <updated>2018-02-26T13:30:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>DOM中外部资源的解析与优化</p><h3 id="浏览器的渲染简介"><a href="#浏览器的渲染简介" class="headerlink" title="浏览器的渲染简介"></a>浏览器的渲染简介</h3><p>首先下载html、js、css。接着浏览器首先会将html转换成一种他们能够理解的格式DOM，CSS 样式被映射到 CSSOM 上（css对象模型），这两者结合生成render tree。</p><p>解析过程中遇到js标签就会下载解析执行。</p><p>render tree结束之后进入layout阶段。</p><p>layout是指计算每个DOM元素最终在屏幕上显示的大小和位置。遍历顺序为从左至右，从上到下，由于web页面元素布局是相对的，所以任意元素的位置发生变化，都会引起其他元素位置的变化，这就是reflow。</p><p>渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来的过程称为paint。当元素改变时并且这种改变不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为repaint。</p><p>reflow 的成本比 repaint 的成本高得多的多。一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow 。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是延慢加载和耗电的。</p><h3 id="DOM中外部资源的解析和优化"><a href="#DOM中外部资源的解析和优化" class="headerlink" title="DOM中外部资源的解析和优化"></a>DOM中外部资源的解析和优化</h3><p>看到一篇很好的文章，<a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="noopener">Building the DOM faster: speculative parsing, async, defer and preload</a>。下文是我对这篇文章在原文的基础上加入了自己一些的理解。</p><h4 id="js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析"><a href="#js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析" class="headerlink" title="js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析"></a>js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析</h4><p>在过去为了执行一个脚本，HTML的解析必须暂停。只有在JavaScript引擎执行完代码之后它才会重新开始解析。如果HTML的解析不暂停，脚本可以改变DOM结构，或者脚本可能会需要获取某个DOM节点，如果是在DOM还在构建时获取，可能会返回意外的结果。所以JS阻塞页面的原因是它可以修改DOM节点。</p><p>而css会阻塞js脚本的解析，因为js可能会需要样式信息。</p><p>因此总结一下：如果在文档中外部样式表放置在脚本之前，DOM 对象和 CSSOM 对象的构建可以互相干扰。 当解析器获取到一个 script 标签，DOM 将无法继续构建直到 JavaScript 执行完毕，而 JavaScript 在 CSS 下载完，解析完，并且 CSSOM 可以使用的时候，才能执行。</p><p><img src="DOM_1.png" alt=""></p><p>虽然css不阻塞DOM的构建，但它会阻塞DOM的渲染。直到DOM和CSSOM都准备好之前，浏览器什么都不会显示。</p><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>在以前当解析器遇到一个脚本就意味着如果是引入脚本，先要下载，然后再解析，如图所示。</p><p><img src="DOM_2.png" alt=""></p><p>脚本下载的时间也阻塞HTML的解析，这样非常耗时，那么有没有一种方法能够让脚本下载异步进行呢？</p><p>这种在同步的脚本执行的时候保持文件下载的方法在不同的浏览器有不同的名字，Chrome 和 Safari 称它为 “预扫描器” 而 Firefox 称它为预解析器。</p><p>它的概念是：虽然在执行脚本时构建 DOM 是不安全的，但是你仍然可以解析 HTML 来查看其它需要检索的资源。找到的文件会被添加到一个列表里并开始在后台并行地下载。当脚本执行完毕之后，这些文件很可能已经下载完成了。</p><p>所以上面那张图在有了预解析器后会变成这样：</p><p><img src="DOM_3.png" alt=""></p><p>以这种方法触发的下载请求称之为“预测”，因为很有可能脚本还是会改变HTML结构（还记得document.write吗？），导致了预测的浪费。虽然这是有可能的，但是却不常见，所以这就是为什么预解析仍然能够带来很大的性能提升。</p><p>可以预加载的东西在浏览器之间有所不同，所有的主要的浏览器都会预加载：脚本、外部CSS、来自img标签的图片。</p><p>在预解析HTML页面时，浏览器不会执行内联的JS代码块，这意味着它不会发现任何的脚本注入资源，也意味着，如果当我们需要一些不重要的资源晚一点被加载的时候，就可以使用JS来加载这些资源，从而避免预解析。</p><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><p>虽然通过预解析可以减少加载资源的时间，但是脚本的解析会阻塞页面解析这依然是个问题。其实并不是所有的脚本都一样重要，对于那些不那么重要的脚本可以采用异步加载。defer和async属性就是提供给开发者一个方式来告诉浏览器哪些脚本需要异步加载。这两个属性都告诉浏览器，它可以一边加载脚本一边解析HTML，并在HTML解析完后再执行脚本，这样脚本的加载和执行就不会阻塞页面解析。</p><p>Defer和asycn之间的不同就是它们开始执行脚本的时机不同。</p><p>Defer会使js脚本的执行在HTML解析完全结束之后开始，在DOMContentLoaded 事件被触发之前执行。它保证脚本会按照它在HTML中出现的顺序执行，并且不会阻塞解析。（当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。）</p><p><img src="DOM_4.png" alt=""></p><p>而设置了async的脚本会在它们加载完后的第一时间执行。这意味着有可能（并且很有可能）设置了async的脚本不会按照它们在HTML中出现的顺序执行。这也意味着他们可能会中断DOM的构建。不过设置了async的脚本的加载有着较低的优先级。他们通常在所有其他脚本加载之后才加载，而不阻塞DOM构建。然而，如果一个指定async的脚本很快就完成了下载，那么它的执行会阻塞DOM构建以及所有在之后才完成下载的同步脚本。</p><p><img src="DOM_5.png" alt=""></p><p>async和defer属性只对外部脚本起作用，如果没有src属性它们会被忽略。</p><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>作为作者，你知道哪些资源对你的页面渲染来说是最重要的。它们其中一些经常深藏在CSS或者是脚本当中，甚至浏览器需要花上很长一段时间才会发现他们。对于那些重要的资源，你现在可以使用<code>&lt;link rel=&quot;preload&quot;&gt;</code>来告诉浏览器你需要尽快地加载它们。</p><p>你只需要写上:<code>&lt;link rel=&quot;preload&quot; href=&quot;very_important.js&quot; as=&quot;script&quot;&gt;</code>，这样你几乎可以链接到任何东西上，并且as属性告诉浏览器要下载的是什么。一些可能的值是：style、script、image、font、audio、video</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM中外部资源的解析与优化&lt;/p&gt;
&lt;h3 id=&quot;浏览器的渲染简介&quot;&gt;&lt;a href=&quot;#浏览器的渲染简介&quot; class=&quot;headerlink&quot; title=&quot;浏览器的渲染简介&quot;&gt;&lt;/a&gt;浏览器的渲染简介&lt;/h3&gt;&lt;p&gt;首先下载html、js、css。接着浏览器首先会
      
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Promise理解</title>
    <link href="http://yoursite.com/2018/01/06/Promise/"/>
    <id>http://yoursite.com/2018/01/06/Promise/</id>
    <published>2018-01-06T13:12:13.000Z</published>
    <updated>2018-02-26T13:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Promise</code>是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，<code>Promise</code>并不是从JavaScript中发祥的概念。</p><h3 id="创建一个promise对象"><a href="#创建一个promise对象" class="headerlink" title="创建一个promise对象"></a>创建一个promise对象</h3><p>要想创建一个<code>Promise</code>对象、可以使用new来调用<code>Promise</code>的构造器来进行实例化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 异步处理</span></span><br><span class="line">    <span class="comment">// 处理结束后、调用resolve 或 reject</span></span><br><span class="line">        fs.readFile(filename, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, (err, contents) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            resolve(contents)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中new了一个Promise对象，在这个构造函数中传入的参数是一个执行器，当触发这个执行器的异步操作时，并不会阻塞，而是继续向下执行，直到完成promise对象的创建。然后将这个创建的promise对象return，此时这个promise的状态为pending。</p><p>当执行器中的异步操作完成，就会将回调函数放入任务队列中，等到执行该任务时，调用resolve会将promise对象变为resolve（Fulfilled）状态,调用reject会将promise对象变为Rejected状态，此时用then方法来设置resolve后的回调函数， catch 方法来设置发生错误时的回调函数，并将回调函数加入到任务队列末尾：<code>promise.then(onFulfilled, onRejected)</code>。</p><p>在resolve(成功)时，onFulfilled 会被调用；reject(失败)时，onRejected 会被调用。resolve和reject会将参数传给onFulfilled和onRejected。onFulfilled、onRejected 两个都为可选参数。</p><h3 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h3><p>静态方法<code>Promise.resolve(value)</code> 可以认为是<code>new Promise()</code>方法的快捷方式。比如<code>Promise.resolve(42)</code>; 可以认为是以下代码的语法糖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。</p><p>方法 <code>Promise.resolve(value)</code>; 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在使用<code>Promise.resolve(value)</code> 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 .then 里面指定的方法就是同步调用的呢？实际上， .then 中指定的方法调用是异步进行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner promise"</span>); <span class="comment">// 1</span></span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer promise"</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="promise-chain-中传递参数"><a href="#promise-chain-中传递参数" class="headerlink" title="promise chain 中传递参数"></a>promise chain 中传递参数</h3><p>前面例子中的Task都是相互独立的，只是被简单调用而已。这时候如果Task A想给Task B传递一个参数该怎么办呢？答案非常简单，那就是在Task A中return的返回值，会在Task B执行时传给它。</p><p>我们还是先来看一个具体例子吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleUp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line">    .then(increment)</span><br><span class="line">    .then(doubleUp)</span><br><span class="line">    .then(output)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise chain中出现异常的时候会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>每个方法中<code>return</code>的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。</p><p><code>return</code>的值会由<code>Promise.resolve(return的返回值)</code>; 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终then的结果都是返回一个新创建的<code>promise</code>对象。也就是说，<code>Promise.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>promise</code>对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，&lt;code&gt;Promise&lt;/code&gt;并不是从JavaScript中发祥的概念。&lt;/p&gt;
&lt;h3 id=&quot;创建一个promise对象&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
