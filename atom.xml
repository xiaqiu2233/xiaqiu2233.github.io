<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fyt的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-15T09:44:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fyt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP杂说</title>
    <link href="http://yoursite.com/2018/08/15/HTTP%E6%9D%82%E8%AF%B4/"/>
    <id>http://yoursite.com/2018/08/15/HTTP杂说/</id>
    <published>2018-08-15T06:14:46.000Z</published>
    <updated>2018-08-15T09:44:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Get和Post"><a href="#1、Get和Post" class="headerlink" title="1、Get和Post"></a>1、Get和Post</h3><p>Get方法是安全方法，安全是指因为get方法只是执行获取资源的动作，而post方法被用于请求服务器接受请求中的实体，作为请求资源的一个新的从属物，所以可能会执行不安全动作。<br>Get方法有幂等性，幂等的意思是相同的请求请求结果一样，所以get是幂等性<br>如果请求消息包含If-Modified-Since，If-Unmodified-Since，If-Match，If-None-Match或者 If-Range头域， GET的语义将变成“条件(conditionall) GET”。一个条件GET方法会请求满足条件头域的实体。条件 GET 方法的目的是为了减少不必要的网络使用，这通过允许利用缓存里仍然保鲜的实体而不用多次请求或传输客户端已经拥有的实体来实现的。<br>GET是获取被请求URI指定的信息<br>POST方法。<br>POST里的响应是不可缓存的</p><h3 id="2、-HTTP状态码"><a href="#2、-HTTP状态码" class="headerlink" title="2、 HTTP状态码"></a>2、 HTTP状态码</h3><ul><li><strong>1**</strong> 信息，服务器收到请求，需要请求者继续执行操作</li><li><strong>2**</strong> 成功，操作被成功接收并处理</li><li><strong>3**</strong> 重定向，需要进一步的操作以完成请求</li><li><strong>4**</strong> 客户端错误，请求包含语法错误或无法完成请求</li><li><strong>5**</strong> 服务器错误，服务器在处理请求的过程中发生了错误</li></ul><h4 id="2-1-状态码"><a href="#2-1-状态码" class="headerlink" title="2.1 状态码"></a>2.1 状态码</h4><ul><li><p>100(Continue)<br>HTTP1.1中新加入100响应码，目的在于允许客户端判定服务器是否愿意接受客户端发来的消息主体（基于请求头，Expect:<br>100-continue），如果服务端愿意接受，返回100（Continue），不愿意接受返回417（Expectation Failed），表示客户端错误，意<br>味着服务器无法满足 Expect 请求消息头中的期望条件。</p></li><li><p>200(OK)<br>请求成功。请求所希望的响应头或数据体将随此响应返回</p></li><li><p>206(Partial Content)</p></li></ul><h4 id="2-2-和重定向相关的状态码"><a href="#2-2-和重定向相关的状态码" class="headerlink" title="2.2 和重定向相关的状态码"></a>2.2 和重定向相关的状态码</h4><p>下面主要介绍3开头的和重定向有关的状态码。客户端发送请求，服务端返回一个3开头的状态码，那么客户端会请求服务端返回的新URL。<br>有很多重定向，可以分为三类：<br>永久重定向、暂时重定向和特殊重定向。</p><ol><li>永久重定向的是301和308</li></ol><ul><li>301(Moved Permanently)<br>永久移动。<br>请求资源被赋予一个新的永久URI，并且任何将来对此资源的引用都会利用这个新的URI。<br>如果客户端接收了一个来自非GET或HEAD请求方法的301响应， 那么就不能自动的向新URI发送重复请求，除非得到用户的确认。<br>使用场景：网站整顿</li><li>308(Permanent Redirect)</li></ul><ol><li>暂时重定向是302、303和307</li></ol><ul><li>302(Found)<br>临时移动。<br>请求的资源暂时地存放在一个不同的URI下。<br>如果客户端发出非GET请求后，收到服务端的302状态码，那么就不能自动的向新URI发送重复请求，除非得到用户的确认。<br>但是，很多浏览器都把302当作303处理了，它们获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。<br>使用场景：Web页面因为特殊原因暂时无法获得</li><li>303(See Other)<br>见其他。<br>请求的响应被放在一个不同的URI下，并且应该用GET方法获得那个资源。<br>如果客户端发出POST或PUT请求后，收到服务端的303状态码，那么浏览器获取到HTTP响应报文头部的Location字段信息，并发起一个GET请求。<br>使用场景：防止POST或PUT请求的二次触发</li><li>307(Temporary Redirect)<br>临时重定向。<br>如果客户端发出非GET请求，那么规范要求其他的请求方法必须等客户确认才能跳转。<br>请求方法和请求体都不会改变。<br>307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。</li></ul><ol><li>特殊重定向</li></ol><ul><li><p>300(Multiple Choice)<br>多项选择。<br>是一种手工重定向：响应的消息主体中包含了一个可能的重定向链接的列表，用户可以从中进行选择。</p></li><li><p>304(Not Modified)<br>没有修改。<br>表示缓存值依然有效。</p></li></ul><h3 id="3、HTTP请求报文"><a href="#3、HTTP请求报文" class="headerlink" title="3、HTTP请求报文"></a>3、HTTP请求报文</h3><p>HTTP请求报文包括：起始行、请求头和请求体</p><h3 id="4、HTTP版本"><a href="#4、HTTP版本" class="headerlink" title="4、HTTP版本"></a>4、HTTP版本</h3><p>HTTP1.0中只有三个请求方法：GET、POST、HEAD<br>HTTP1.1中增加了PUT、DELETE、OPTION、TRACE、CONNECT<br>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响<br>应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要<br>创建连接的缺点。<br>HTTP1.1中新加入100响应码，目的在于允许客户端判定服务器是否愿意接受客户端发来的消息主体（基于请求头，Expect:<br>100-continue），如果服务端愿意接受，返回100（Continue），不愿意接受返回417（Expectation Failed），表示客户端错误，意<br>味着服务器无法满足 Expect 请求消息头中的期望条件。<br>HTTP1.1中添加Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名<br>（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共<br>享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad<br>Request）。<br>HTTP1.0中的缓存使用Pragma和Expires来规范，Pragma通过no-cache来禁用缓存，Expires来规定缓存的过期时间<br>HTTP1.1中使用cache-control来规定缓存的过期时间，或是禁用缓存，如果缓存过期，则进入第二步与服务端进行再验证使用<br>if-modified-since、if-none-match来进行再验证。<br>HTTP2.0相比HTTP1.1<br>HTTP1.1: 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。<br>HTTP2:多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。能实现多路复用是因为新增二进制分帧层，消息分帧后可以<br>乱序发送，然后再根据每个帧头部的流标识符重新组装<br>头部压缩：在HTTP1.x中，头部元数据都是以纯文本的形式发送的，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自<br>cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。<br>服务器推送<br>服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。<br>比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一<br>轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Get和Post&quot;&gt;&lt;a href=&quot;#1、Get和Post&quot; class=&quot;headerlink&quot; title=&quot;1、Get和Post&quot;&gt;&lt;/a&gt;1、Get和Post&lt;/h3&gt;&lt;p&gt;Get方法是安全方法，安全是指因为get方法只是执行获取资源的动作，而pos
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise理解进阶篇</title>
    <link href="http://yoursite.com/2018/08/13/Promise%E7%90%86%E8%A7%A3%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <id>http://yoursite.com/2018/08/13/Promise理解进阶篇/</id>
    <published>2018-08-13T01:52:57.000Z</published>
    <updated>2018-08-15T06:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Promise状态变化"><a href="#1、Promise状态变化" class="headerlink" title="1、Promise状态变化"></a>1、Promise状态变化</h3><p>首先看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleUp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line">    .then(increment)</span><br><span class="line">    .then(doubleUp)</span><br><span class="line">    .then(output)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise chain中出现异常的时候会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这个例子中我们先看这一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>意思是将 promise 的对象状态置为resolve，这个状态变化是个同步过程，在promise的状态确定后，如果是resolve状态，则将then的onFulfilled回调函数放入microTask队列，如果是reject状态，则将调用onRejected回调函数放入microTask队列。<br>increment函数有一个参数，这个参数是由Promise.resolve(1)传入的。进入increment函数后，可以看到return value+1，然后increment函数到此为止，其实没这么简单，return的值会由Promise.resolve(return的返回值); 进行相应的包装处理，不管回调函数返回或者不返回，then都会返回一个新建的promise对象，当回调函数有return返回值时生成一个promise，[[PromiseStatus]]是”resolved”，[[PromiseValue]]是return的返回值。当回调函数没有return时，生成的promise，[[PromiseStatus]]是”resolved”，[[PromiseValue]]是undefined。<br>使用promise我感觉有一个很大的好处就是错误处理，在一个链式调用中，只需要在最后catch状态为onRejected的promise进行错误处理，而在回调中每个回调都需要有错误处理，很难统一进行处理</p><h3 id="2、catch和then-onRejected-的区别"><a href="#2、catch和then-onRejected-的区别" class="headerlink" title="2、catch和then(onRejected)的区别"></a>2、catch和then(onRejected)的区别</h3><p>这两种捕获异常的方法，咱们用哪一种呢？<br>首先要考虑的是兼容问题。在IE8以下，使用的是ES3规范，在ECMAScript 3中保留字是不能作为对象的属性名使用的，因此不能将catch作为属性来使用。而现在的浏览器都是基于ECMAScript 5的，而在ECMAScript 5中保留字都属于IdentifierName，也可以作为属性名使用了。在es3中实在想用，可以使用中括号标记法（bracket notation）的话，则可以将非合法标识符作为对象的属性名使用。或者我们不单纯的使用catch，而是使用then也是可以避免这个问题的。<br>还有一个区别是，then中的onRejected是不能捕获到onFulfilled中抛出的错误，而catch可以。</p><h3 id="3、使用reject而不是throw"><a href="#3、使用reject而不是throw" class="headerlink" title="3、使用reject而不是throw"></a>3、使用reject而不是throw</h3><p>在promise中并不需要通过throw来抛出一个错误，完全可以用reject来代替。<br>Promise的构造函数，以及被then调用执行的函数基本上都可以认为是在 try…catch 代码块中执行的，所以在这些代码中即使使用throw，程序本身也不会因为异常而终止。<br>如果在Promise中使用throw语句的话，会被 try…catch 住，最终promise对象也变为Rejected状态。<br>如果使用throw我们很难区分到底是程序抛出异常，还是人为抛出，在浏览器的调试功能中有一个在程序发生异常的时，自动break调试的功能，如果我们人为抛出一个错，浏览器开启这个功能时也会自动break调试，从而影响浏览器提供此功能的正常使用。<br>如果想在then中进行reject，怎么办呢？<br>当然是定义一个promise，并返回，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> onRejected = <span class="built_in">console</span>.error.bind(<span class="built_in">console</span>);</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"this promise is rejected"</span>));</span><br><span class="line">&#125;).catch(onRejected);</span><br></pre></td></tr></table></figure><h3 id="4、Promise-all和Promise-race"><a href="#4、Promise-all和Promise-race" class="headerlink" title="4、Promise.all和Promise.race"></a>4、Promise.all和Promise.race</h3><p>Promise.all接收一个promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用.then方法。<br>比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([request.comment(), request.people()]);</span><br></pre></td></tr></table></figure></p><p>request.comment()和request.people()会同时执行，这两个promise的结果会按照顺序返回，即在下一个then的onFulfilled回调函数中接受的参数首先是一个数组，然后这个数组的顺序和Promise.all参数数组的顺序一致，所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main().then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 按照[comment, people]的顺序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>传递给Promise.all的promise并不是一个个的顺序执行的，而是同时开始、并行执行的。<br>Promise.all在接收到的所有的对象promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，与之相对的是Promise.race只要有一个promise对象进入FulFilled或者Rejected状态的话，就会继续进行后面的处理。Promise.race在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</p><h3 id="5、Promise顺序执行"><a href="#5、Promise顺序执行" class="headerlink" title="5、Promise顺序执行"></a>5、Promise顺序执行</h3><p>Promise.all方法，传入元素为Promise的数组，all方法开始执行时，所有的Promise同时执行，不分先后，当数组中的每一个Promise状态都变成resolve或reject时，这个方法才算执行完。<br>Promise.all可以提供同时执行，但是无法提供顺序执行。<br>下面就以请求url为例，来实现Promise的顺序执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> Promsie(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeous(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeous(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeous(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// tasks中的不是Promise的数组，而是方法</span></span><br><span class="line">    <span class="keyword">var</span> tasks = [ajax1, ajax, ajax3];</span><br><span class="line">    sequenceTasks(tasks).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(results);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的关键就是定义 sequenceTasks 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">var</span> resultSave = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">        <span class="keyword">let</span> task = tasks[i];</span><br><span class="line">        promise = promise.then(task).then(resultSave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个顺序执行就基本实现了，如果觉得在实现上不好看，可以用 Array.prototype.reduce 来改进</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">var</span> resultSave = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(task).then(resultSave);</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Promise状态变化&quot;&gt;&lt;a href=&quot;#1、Promise状态变化&quot; class=&quot;headerlink&quot; title=&quot;1、Promise状态变化&quot;&gt;&lt;/a&gt;1、Promise状态变化&lt;/h3&gt;&lt;p&gt;首先看下面代码：&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="http://yoursite.com/2018/02/07/HTTP%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/07/HTTP缓存/</id>
    <published>2018-02-07T02:12:33.000Z</published>
    <updated>2018-02-26T13:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习HTTP缓存，使用缓存是网站优化的重要步骤。本文是对《HTTP权威指南》第七章缓存的一些摘要和总结。</p><p>在商业应用中，使用缓存服务器来提高性能降低对原始服务器的要求。对一条HTTP GET报文的基本缓存处理过程包括7个步骤 ：</p><p>(1)  接收——缓存从网络中读取抵达的请求报文。<br>(2)  解析——缓存对报文进行解析，提取出 URL 和各种首部。<br>(3)  查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本(并将其保存在本地)。<br>(4)  新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。<br>(5)  创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。<br>(6)  发送——缓存通过网络将响应发回给客户端。<br>(7)  日志——缓存可选地创建一个日志文件条目来描述这个事务。</p><p>这个过程如下图所示：</p><p><img src="http1.png" alt=""></p><p>其中对于新鲜度检测这一步，HTTP协议有两个机制：文档过期和服务器再验证来保持缓存中副本的新鲜度。</p><h3 id="1、文档过期"><a href="#1、文档过期" class="headerlink" title="1、文档过期"></a>1、文档过期</h3><p>通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。</p><p>Cache-Control首部和Expires首部告诉客户端到了某个时间点（比照客户端时间点）后本地缓存就过期了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示返回200（强缓存），一旦资源命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。Chrome下的现象是200 OK (from disk cache) 或者 200 OK (from memory cache).</p><p>但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果文档被修改过，就要获取一份新鲜(带有新的过期日期)的副本。 </p><p>服务器用HTTP/1.0+的Expires首部或HTTP/1.1的<code>Cache-Control: max-age</code>响应首部来指定过期日期，同时还会带有响应主体。Expires首部和<code>Cache-Control: max-age</code>首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。 </p><p>Cache-Control在浏览器缓存中是金字塔顶尖的规则，它会覆盖一切与之相悖的规则。因此当Expires与之相悖时，就会忽略Expires。</p><h3 id="2、服务器再验证"><a href="#2、服务器再验证" class="headerlink" title="2、服务器再验证"></a>2、服务器再验证</h3><p>如果仅仅是Cache-Control首部和Expires首部规定的时间点过期了，那并不意味着它和原始服务器上目前正处于活跃状态的文档有实际区别。</p><p>这只是意味着到了要核对的时间了。这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。 </p><p>客户端检测到数据过期后，会向服务器发送一个get请求。在请求中一般会携带If-Modified-Since或If-None-Match请求头。</p><p>先说If-Modified-Since。如果在指定日期之后资源发生了变化，GET请求就会成功执行返回200响应。携带新首部的新文档会被返回给缓<br>存，新首部除了其他信息之外，还包含了一个新的过期日期。 如果自指定日期后，文档没被修改过，会向客户端返回一个304 Not Modified 响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，Content-Type 首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。 </p><p>再说If-None-Match。有些情况下仅使用最后修改日期进行再验证是不够的。 比如：</p><p>(1)  有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。<br>(2)  再比如有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。<br>(3)  有些服务器无法准确地判定其页面的最后修改日期。<br>(4)  有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。 </p><p>在这些情况下HTTP允许用户对被称为实体标签(ETag)的“版本标识符” 进行比较。实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。</p><p>当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用 If-None-Match 条件首部收到一条200已缓存的成功响应，返回新的内容以及相应的新 Etag。当实体标签没有被修改，就会返回304未修改响应。</p><p>如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有实体标签条件首部ETag，那么只有这两个条件都满足时，才能返回 304 Not Modified 响应。</p><p>HTTP规范从未指定生成ETag的方法。生成ETag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。</p><h3 id="3、关于Cache-Control"><a href="#3、关于Cache-Control" class="headerlink" title="3、关于Cache-Control"></a>3、关于Cache-Control</h3><p>服务器可以通过 HTTP 定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序，服务器可以: </p><p>附加一个Cache-Control:no-store首部到响应中去;</p><p>附加一个Cache-Control:no-cache首部到响应中去;</p><p>附加一个Cache-Control:must-revalidate首部到响应中去; </p><p>附加一个Cache-Control:max-age首部到响应中去;</p><p>附加一个Expires日期首部到响应中去;</p><p>不附加过期信息，让缓存确定自己的过期日期。</p><p>标识为 no-store 的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。 </p><p>标识为 no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。 我的理解是no-cache是表示max-age=0即立马过期。</p><p><code>Cache-Control: max-age</code>首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数 。</p><h3 id="4、关于Expires响应首部"><a href="#4、关于Expires响应首部" class="headerlink" title="4、关于Expires响应首部"></a>4、关于Expires响应首部</h3><p>不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。HTTP 设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。</p><h3 id="5、当响应中没有Cache-Control-max-age首部，也没有-Expires-首部时"><a href="#5、当响应中没有Cache-Control-max-age首部，也没有-Expires-首部时" class="headerlink" title="5、当响应中没有Cache-Control: max-age首部，也没有 Expires 首部时"></a>5、当响应中没有<code>Cache-Control: max-age</code>首部，也没有 Expires 首部时</h3><p>如果响应中没有<code>Cache-Control: max-age</code>首部，也没有 Expires 首部，那么使用LM-Factor 算法 的试探性过期算法，用当前时间Date与文档的最后修改时间之差，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。</p><h3 id="6、用户操作行为与缓存"><a href="#6、用户操作行为与缓存" class="headerlink" title="6、用户操作行为与缓存"></a>6、用户操作行为与缓存</h3><p>用户在使用浏览器的时候，会有各种操作，比如输入地址后回车，按F5刷新等，这些行为会对缓存有什么影响呢？</p><p><img src="http2.png" alt=""></p><p>通过上表我们可以看到，当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；而当用户使用Ctrl+F5进行强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习HTTP缓存，使用缓存是网站优化的重要步骤。本文是对《HTTP权威指南》第七章缓存的一些摘要和总结。&lt;/p&gt;
&lt;p&gt;在商业应用中，使用缓存服务器来提高性能降低对原始服务器的要求。对一条HTTP GET报文的基本缓存处理过程包括7个步骤 ：&lt;/p&gt;
&lt;p&gt;(1)  
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DOM中外部资源的解析与优化</title>
    <link href="http://yoursite.com/2018/01/28/DOM%E4%B8%AD%E5%A4%96%E9%83%A8%E8%B5%84%E6%BA%90%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/28/DOM中外部资源的解析与优化/</id>
    <published>2018-01-28T14:57:39.000Z</published>
    <updated>2018-02-26T13:30:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>DOM中外部资源的解析与优化</p><h3 id="浏览器的渲染简介"><a href="#浏览器的渲染简介" class="headerlink" title="浏览器的渲染简介"></a>浏览器的渲染简介</h3><p>首先下载html、js、css。接着浏览器首先会将html转换成一种他们能够理解的格式DOM，CSS 样式被映射到 CSSOM 上（css对象模型），这两者结合生成render tree。</p><p>解析过程中遇到js标签就会下载解析执行。</p><p>render tree结束之后进入layout阶段。</p><p>layout是指计算每个DOM元素最终在屏幕上显示的大小和位置。遍历顺序为从左至右，从上到下，由于web页面元素布局是相对的，所以任意元素的位置发生变化，都会引起其他元素位置的变化，这就是reflow。</p><p>渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来的过程称为paint。当元素改变时并且这种改变不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为repaint。</p><p>reflow 的成本比 repaint 的成本高得多的多。一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow 。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是延慢加载和耗电的。</p><h3 id="DOM中外部资源的解析和优化"><a href="#DOM中外部资源的解析和优化" class="headerlink" title="DOM中外部资源的解析和优化"></a>DOM中外部资源的解析和优化</h3><p>看到一篇很好的文章，<a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="noopener">Building the DOM faster: speculative parsing, async, defer and preload</a>。下文是我对这篇文章在原文的基础上加入了自己一些的理解。</p><h4 id="js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析"><a href="#js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析" class="headerlink" title="js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析"></a>js脚本会阻塞HTML的解析，而css会阻塞js脚本的解析</h4><p>在过去为了执行一个脚本，HTML的解析必须暂停。只有在JavaScript引擎执行完代码之后它才会重新开始解析。如果HTML的解析不暂停，脚本可以改变DOM结构，或者脚本可能会需要获取某个DOM节点，如果是在DOM还在构建时获取，可能会返回意外的结果。所以JS阻塞页面的原因是它可以修改DOM节点。</p><p>而css会阻塞js脚本的解析，因为js可能会需要样式信息。</p><p>因此总结一下：如果在文档中外部样式表放置在脚本之前，DOM 对象和 CSSOM 对象的构建可以互相干扰。 当解析器获取到一个 script 标签，DOM 将无法继续构建直到 JavaScript 执行完毕，而 JavaScript 在 CSS 下载完，解析完，并且 CSSOM 可以使用的时候，才能执行。</p><p><img src="DOM_1.png" alt=""></p><p>虽然css不阻塞DOM的构建，但它会阻塞DOM的渲染。直到DOM和CSSOM都准备好之前，浏览器什么都不会显示。</p><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>在以前当解析器遇到一个脚本就意味着如果是引入脚本，先要下载，然后再解析，如图所示。</p><p><img src="DOM_2.png" alt=""></p><p>脚本下载的时间也阻塞HTML的解析，这样非常耗时，那么有没有一种方法能够让脚本下载异步进行呢？</p><p>这种在同步的脚本执行的时候保持文件下载的方法在不同的浏览器有不同的名字，Chrome 和 Safari 称它为 “预扫描器” 而 Firefox 称它为预解析器。</p><p>它的概念是：虽然在执行脚本时构建 DOM 是不安全的，但是你仍然可以解析 HTML 来查看其它需要检索的资源。找到的文件会被添加到一个列表里并开始在后台并行地下载。当脚本执行完毕之后，这些文件很可能已经下载完成了。</p><p>所以上面那张图在有了预解析器后会变成这样：</p><p><img src="DOM_3.png" alt=""></p><p>以这种方法触发的下载请求称之为“预测”，因为很有可能脚本还是会改变HTML结构（还记得document.write吗？），导致了预测的浪费。虽然这是有可能的，但是却不常见，所以这就是为什么预解析仍然能够带来很大的性能提升。</p><p>可以预加载的东西在浏览器之间有所不同，所有的主要的浏览器都会预加载：脚本、外部CSS、来自img标签的图片。</p><p>在预解析HTML页面时，浏览器不会执行内联的JS代码块，这意味着它不会发现任何的脚本注入资源，也意味着，如果当我们需要一些不重要的资源晚一点被加载的时候，就可以使用JS来加载这些资源，从而避免预解析。</p><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><p>虽然通过预解析可以减少加载资源的时间，但是脚本的解析会阻塞页面解析这依然是个问题。其实并不是所有的脚本都一样重要，对于那些不那么重要的脚本可以采用异步加载。defer和async属性就是提供给开发者一个方式来告诉浏览器哪些脚本需要异步加载。这两个属性都告诉浏览器，它可以一边加载脚本一边解析HTML，并在HTML解析完后再执行脚本，这样脚本的加载和执行就不会阻塞页面解析。</p><p>Defer和asycn之间的不同就是它们开始执行脚本的时机不同。</p><p>Defer会使js脚本的执行在HTML解析完全结束之后开始，在DOMContentLoaded 事件被触发之前执行。它保证脚本会按照它在HTML中出现的顺序执行，并且不会阻塞解析。（当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。）</p><p><img src="DOM_4.png" alt=""></p><p>而设置了async的脚本会在它们加载完后的第一时间执行。这意味着有可能（并且很有可能）设置了async的脚本不会按照它们在HTML中出现的顺序执行。这也意味着他们可能会中断DOM的构建。不过设置了async的脚本的加载有着较低的优先级。他们通常在所有其他脚本加载之后才加载，而不阻塞DOM构建。然而，如果一个指定async的脚本很快就完成了下载，那么它的执行会阻塞DOM构建以及所有在之后才完成下载的同步脚本。</p><p><img src="DOM_5.png" alt=""></p><p>async和defer属性只对外部脚本起作用，如果没有src属性它们会被忽略。</p><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>作为作者，你知道哪些资源对你的页面渲染来说是最重要的。它们其中一些经常深藏在CSS或者是脚本当中，甚至浏览器需要花上很长一段时间才会发现他们。对于那些重要的资源，你现在可以使用<code>&lt;link rel=&quot;preload&quot;&gt;</code>来告诉浏览器你需要尽快地加载它们。</p><p>你只需要写上:<code>&lt;link rel=&quot;preload&quot; href=&quot;very_important.js&quot; as=&quot;script&quot;&gt;</code>，这样你几乎可以链接到任何东西上，并且as属性告诉浏览器要下载的是什么。一些可能的值是：style、script、image、font、audio、video</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM中外部资源的解析与优化&lt;/p&gt;
&lt;h3 id=&quot;浏览器的渲染简介&quot;&gt;&lt;a href=&quot;#浏览器的渲染简介&quot; class=&quot;headerlink&quot; title=&quot;浏览器的渲染简介&quot;&gt;&lt;/a&gt;浏览器的渲染简介&lt;/h3&gt;&lt;p&gt;首先下载html、js、css。接着浏览器首先会
      
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Promise理解</title>
    <link href="http://yoursite.com/2018/01/06/Promise/"/>
    <id>http://yoursite.com/2018/01/06/Promise/</id>
    <published>2018-01-06T13:12:13.000Z</published>
    <updated>2018-02-26T13:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Promise</code>是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，<code>Promise</code>并不是从JavaScript中发祥的概念。</p><h3 id="创建一个promise对象"><a href="#创建一个promise对象" class="headerlink" title="创建一个promise对象"></a>创建一个promise对象</h3><p>要想创建一个<code>Promise</code>对象、可以使用new来调用<code>Promise</code>的构造器来进行实例化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 异步处理</span></span><br><span class="line">    <span class="comment">// 处理结束后、调用resolve 或 reject</span></span><br><span class="line">        fs.readFile(filename, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, (err, contents) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            resolve(contents)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中new了一个Promise对象，在这个构造函数中传入的参数是一个执行器，当触发这个执行器的异步操作时，并不会阻塞，而是继续向下执行，直到完成promise对象的创建。然后将这个创建的promise对象return，此时这个promise的状态为pending。</p><p>当执行器中的异步操作完成，就会将回调函数放入任务队列中，等到执行该任务时，调用resolve会将promise对象变为resolve（Fulfilled）状态,调用reject会将promise对象变为Rejected状态，此时用then方法来设置resolve后的回调函数， catch 方法来设置发生错误时的回调函数，并将回调函数加入到任务队列末尾：<code>promise.then(onFulfilled, onRejected)</code>。</p><p>在resolve(成功)时，onFulfilled 会被调用；reject(失败)时，onRejected 会被调用。resolve和reject会将参数传给onFulfilled和onRejected。onFulfilled、onRejected 两个都为可选参数。</p><h3 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h3><p>静态方法<code>Promise.resolve(value)</code> 可以认为是<code>new Promise()</code>方法的快捷方式。比如<code>Promise.resolve(42)</code>; 可以认为是以下代码的语法糖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这段代码中的 resolve(42); 会让这个promise对象立即进入确定（即resolved）状态，并将 42 传递给后面then里所指定的 onFulfilled 函数。</p><p>方法 <code>Promise.resolve(value)</code>; 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在使用<code>Promise.resolve(value)</code> 等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得 .then 里面指定的方法就是同步调用的呢？实际上， .then 中指定的方法调用是异步进行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner promise"</span>); <span class="comment">// 1</span></span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer promise"</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="promise-chain-中传递参数"><a href="#promise-chain-中传递参数" class="headerlink" title="promise chain 中传递参数"></a>promise chain 中传递参数</h3><p>前面例子中的Task都是相互独立的，只是被简单调用而已。这时候如果Task A想给Task B传递一个参数该怎么办呢？答案非常简单，那就是在Task A中return的返回值，会在Task B执行时传给它。</p><p>我们还是先来看一个具体例子吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleUp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line">    .then(increment)</span><br><span class="line">    .then(doubleUp)</span><br><span class="line">    .then(output)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise chain中出现异常的时候会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>每个方法中<code>return</code>的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。</p><p><code>return</code>的值会由<code>Promise.resolve(return的返回值)</code>; 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终then的结果都是返回一个新创建的<code>promise</code>对象。也就是说，<code>Promise.then</code>不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个<code>promise</code>对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是抽象异步处理对象以及对其进行各种操作的组件。 其详细内容在接下来我们还会进行介绍，&lt;code&gt;Promise&lt;/code&gt;并不是从JavaScript中发祥的概念。&lt;/p&gt;
&lt;h3 id=&quot;创建一个promise对象&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>bind函数</title>
    <link href="http://yoursite.com/2017/12/28/bind%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/12/28/bind函数/</id>
    <published>2017-12-28T14:34:08.000Z</published>
    <updated>2018-02-26T15:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>存在一种情况比如你想要调用某个对象中的方法，并且该方法中会调用这个对象的某个属性，如果直接调用比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 返回 81</span></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">// 返回 9, 在这种情况下，"this"指向全局作用域</span></span><br></pre></td></tr></table></figure><p>可以看到retrieveX中this指向全局，因此如果需要这个this指向module则需要使用bind函数将module.getX的this变成module。bind函数可以实现创建一个新函数，并且制定这个新函数的this值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="comment">// 创建一个新函数，将"this"绑定到module对象</span></span><br><span class="line"><span class="comment">// 新手可能会被全局的x变量和module里的属性x所迷惑</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line">boundGetX(); <span class="comment">// 返回 81</span></span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>bind的第一个参数是要指定的this对象，其它都是需要传入的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind(thisArg[, arg1[, arg2[, …]]])</span><br></pre></td></tr></table></figure><p>当绑定函数被调用时，thisArg参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>为了解释“当使用new 操作符调用绑定函数时，该参数无效”这句话，咱们先来归纳一下当使用new操作符来调用函数时，会执行的操作：</p><ol><li>创建（或构造）一个全新的对象。</li><li>这个新对象会执行[[Prototype]]连接</li><li>这个新对象会绑定到函数调用的this</li><li>如果这个函数没有返回其它对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol><p>因为使用new会将新对象绑定到函数调用的this，所以指定的this将不起作用，所以这个参数将无效。</p><p>bind函数返回由指定的this值和初始化参数改造的原函数拷贝。</p><p>bind 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。</p><h3 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123; <span class="comment">//oThis是thisArg</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123; <span class="comment">//this是调用bind的函数</span></span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), <span class="comment">//aArgs是[arg1,arg2,….]</span></span><br><span class="line">        fToBind = <span class="keyword">this</span>, <span class="comment">//this是调用bind的函数(可以想象为slice)</span></span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// bind函数返回一个函数所以fBound</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span>: oThis,</span><br><span class="line">                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));<span class="comment">// 获取调用时用户向fBound传递的参数.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;存在一种情况比如你想要调用某个对象中的方法，并且该方法中会调用这个对象的某个属性，如果直接调用比如：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>CSS中的BFC</title>
    <link href="http://yoursite.com/2017/12/08/CSS%E4%B8%AD%E7%9A%84BFC/"/>
    <id>http://yoursite.com/2017/12/08/CSS中的BFC/</id>
    <published>2017-12-08T02:56:24.000Z</published>
    <updated>2018-02-26T13:32:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>BFC是块级格式化上下文。它是由于块级元素设置了某些属性而形成的一个独立的区域。在这个区域中，它里面的布局不会影响到外面元素的布局，反之也一样。 </p><h3 id="创建一个BFC"><a href="#创建一个BFC" class="headerlink" title="创建一个BFC"></a>创建一个BFC</h3><p>只需要满足下面条件之一就能创建一个BFC</p><ol><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ol><h3 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h3><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol><h3 id="BFC的用处"><a href="#BFC的用处" class="headerlink" title="BFC的用处"></a>BFC的用处</h3><h4 id="使用BFC来防止外边距折叠"><a href="#使用BFC来防止外边距折叠" class="headerlink" title="使用BFC来防止外边距折叠"></a>使用BFC来防止外边距折叠</h4><p>属于同一个BFC的两个相邻的BOX的margin上下方向会重叠，如果不想让两个Box的margin重叠则可以将这两个Box放在不同的BFC中。</p><h4 id="使用BFC来包含浮动"><a href="#使用BFC来包含浮动" class="headerlink" title="使用BFC来包含浮动"></a>使用BFC来包含浮动</h4><p>在BFC的布局规则中的第六条：</p><blockquote><p>计算BFC的高度时，浮动元素也参与计算。</p></blockquote><p>所以可以将父元素变成一个BFC从而来清除浮动：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .par &#123;</span></span><br><span class="line"><span class="undefined">        border: 5px solid #fcc;</span></span><br><span class="line"><span class="undefined">        width: 300px;</span></span><br><span class="line"><span class="undefined">        overflow:hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"> </span></span><br><span class="line"><span class="undefined">    .child &#123;</span></span><br><span class="line"><span class="undefined">        border: 5px solid #f66;</span></span><br><span class="line"><span class="undefined">        width:100px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        float: left;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"par"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者最常见的方法就是写一个clearfix的类：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom:1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用BFC来防止文字环绕"><a href="#使用BFC来防止文字环绕" class="headerlink" title="使用BFC来防止文字环绕"></a>使用BFC来防止文字环绕</h4><p>有时候一个浮动div周围的文字环绕着它，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floated"</span>&gt;</span>Floated div<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在某些案例中这并不是可取的，我们想要的是外观跟下图中的右图一样的。</p><p><img src="BFC.png" alt=""></p><p>为了解决这个问题，我们可以使用外边距，只要给p设置大于div宽度的margin-left就可以，但是我们也可以使用一个BFC来解决。</p><p>在BFC的布局规则中的第一条：BFC的区域不会与float box重叠。因此我们可以将p元素设置成一个BFC：给p元素添加一个overflow: hidden来实现。</p><h3 id="在多列布局中使用BFC"><a href="#在多列布局中使用BFC" class="headerlink" title="在多列布局中使用BFC"></a>在多列布局中使用BFC</h3><p>可以用多种方式解决多列布局，比如圣杯、双飞翼还可以用BFC。比如代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="undefined">        float: left;</span></span><br><span class="line"><span class="undefined">        height: 200px;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        margin-right: 20px;</span></span><br><span class="line"><span class="undefined">        background-color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="undefined">        width: 200px;</span></span><br><span class="line"><span class="undefined">        height: 200px;</span></span><br><span class="line"><span class="undefined">        float: right;</span></span><br><span class="line"><span class="undefined">        margin-left: 20px;</span></span><br><span class="line"><span class="undefined">        background-color: blue;</span></span><br><span class="line"><span class="undefined">    &#125;   </span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="undefined">        height: 200px;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">        background-color: green;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为BFC的区域不会与float box重叠，所以将类为main的元素设置为BFC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BFC是块级格式化上下文。它是由于块级元素设置了某些属性而形成的一个独立的区域。在这个区域中，它里面的布局不会影响到外面元素的布局，反之也一样。 &lt;/p&gt;
&lt;h3 id=&quot;创建一个BFC&quot;&gt;&lt;a href=&quot;#创建一个BFC&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="http://yoursite.com/2017/11/20/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2017/11/20/全排列/</id>
    <published>2017-11-20T08:19:32.000Z</published>
    <updated>2018-01-31T15:59:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>全排列</strong>就是将给定序列的所有排列方式找出。</p><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><h4 id="有重复"><a href="#有重复" class="headerlink" title="有重复"></a>有重复</h4><p>如下这种方式使用递归，将整组数中的所有的数分别与第一个数交换swap(start,i);，这样就总是在处理后n-1个全排列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span>(<span class="params">list,start,end</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">      swap(list,start,i);</span><br><span class="line">      perm(list,start+<span class="number">1</span>,end);</span><br><span class="line">      swap(list,start,i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">list,i,j</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp=list[i];</span><br><span class="line">  list[i]=list[j];</span><br><span class="line">  list[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">perm(list,<span class="number">0</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="去重复"><a href="#去重复" class="headerlink" title="去重复"></a>去重复</h4><p>那么在这种递归的方法中，如何去掉重复的全排列呢。</p><p>先举个例子：1，2，2</p><ol><li><p>在这个数组中将第一个数与第二个数交换得到2，1，2，将第一个与第三个交换得到2，2，1</p></li><li><p>然后将2，1，2中的第二个与第三个交换2，2，1，额，，，发生了重复，咱们需要转换思路了。</p></li><li><p>重新梳理。将第一个数与第二个数交换得到2，1，2，然后发现第二个数与第三个数相同，于是第一个数不再与第三个数交换。</p></li><li><p>再考虑2，1，2，将第二个数与第三个数交换得到2，2，1.此时全排列完成。</p></li></ol><p>这样我们也得到了在全排列中去掉重复项的规则：去重的全排列就是从第一个数字起，每个数分别与它后面非重复出现的数字交换。用编程的话描述就是第i个数与第j个数交换时，要求[i,j]中没有与第j个数相等的数。</p><p>新添加了一个isSwap函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span>(<span class="params">list,start,end</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isSwap(list, start, i))&#123;</span><br><span class="line">        swap(list,start,i);</span><br><span class="line">        perm(list,start+<span class="number">1</span>,end);</span><br><span class="line">        swap(list,start,i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSwap</span>(<span class="params">list, start,end</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list[i]===list[end])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">list,i,j</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp=list[i];</span><br><span class="line">  list[i]=list[j];</span><br><span class="line">  list[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">perm(list,<span class="number">0</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="字典排序法"><a href="#字典排序法" class="headerlink" title="字典排序法"></a>字典排序法</h3><p>全排列的另外一种方法是<strong>字典排序法</strong>。</p><ol><li><p>字典排序法，就是在数组中，从后往前找，找到第一个非递增数比如1，2，4，3中2就是从前往后第一个非递增数。</p></li><li><p>然后再次从后往前找，找到第一个大于2的数，在这里就是3，交换2和3，数组变成1，3，4，2。</p></li><li><p>最后再逆置3后面的数即1，3，2，4</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">  list.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(list);</span><br><span class="line">  <span class="keyword">while</span>(perm(list))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line"><span class="comment">//从后往前找，找到第一个非递增数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=list.length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list[i]&lt;list[i+<span class="number">1</span>])&#123;</span><br><span class="line">      index=i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === <span class="number">0</span>) &#123; <span class="comment">//若没找到，说明当前序列已经是最大字典序了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//从后往前找，找到第一个大于index位置上的数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=list.length<span class="number">-1</span>;i&gt;=index;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(list[i]&gt;list[index])&#123;</span><br><span class="line">      swap(list, i, index);</span><br><span class="line">      reverse(list, index+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">list,i,j</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp=list[i];</span><br><span class="line">  list[i]=list[j];</span><br><span class="line">  list[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">list, start</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> end = list.length<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">    swap(list,start,end);</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;全排列&lt;/strong&gt;就是将给定序列的所有排列方式找出。&lt;/p&gt;
&lt;h3 id=&quot;递归解法&quot;&gt;&lt;a href=&quot;#递归解法&quot; class=&quot;headerlink&quot; title=&quot;递归解法&quot;&gt;&lt;/a&gt;递归解法&lt;/h3&gt;&lt;h4 id=&quot;有重复&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2017/11/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/11/04/快速排序/</id>
    <published>2017-11-04T13:32:46.000Z</published>
    <updated>2018-02-26T13:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序的时间复杂度为O(N*logN)。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>在快速排序中需要有一个Partition函数，这个方法是在数组中选择一个数字，然后把数组中的数字分为两个部分，比选择的数字小的函数移到数组的左边，比选择的数字大的数字移到数组的右边。这个函数的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">list, length, start, end</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((start + end)/<span class="number">2</span>);</span><br><span class="line">  swap(list, mid , end);</span><br><span class="line">  <span class="keyword">var</span> small = start - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list[i] &lt; list[end])&#123;</span><br><span class="line">      small++;</span><br><span class="line">      <span class="keyword">if</span>(small !== i)&#123;</span><br><span class="line">        swap(list, i, small);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  small++;</span><br><span class="line">  swap(list, small, end);</span><br><span class="line">  <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">list,i,j</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp=list[i];</span><br><span class="line">  list[i]=list[j];</span><br><span class="line">  list[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h3><p>我来解释一下这个函数。</p><p>在数组中选取中间的数，然后从前到后遍历，如果某个数比选定的数小，则交换位置。</p><p>一个很重要的变量是small，这个变量是用来统计比list<a href="即选定的数，不过最开始被交换到end位置">end</a>小的数，当list[i]&lt;list[end]，small加一，然后将所有比list[end]小的数，全都交换到前面去。</p><p>最后small的位置存放的是选定的数，在这个数前面的数全是小于它，后面的全部大于它。接下需要的就是使用一个递归函数，对选定数之前的数组和选定数之后的数组再进行排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">list, length, start, end</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(start === end)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> index = partition(list, length, start, end);</span><br><span class="line">  <span class="keyword">if</span> (index &gt; start)&#123;</span><br><span class="line">    quickSort(list, length, start, index - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; end)&#123;</span><br><span class="line">    quickSort(list, length, index + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="partition方法应用"><a href="#partition方法应用" class="headerlink" title="partition方法应用"></a>partition方法应用</h3><p>在快速排序中的partition方法能用到的地方很多，比如，在剑指offer的面试题29中：数组中出现次数超过一半的数字。也用到了partition。</p><h4 id="剑指offer29题"><a href="#剑指offer29题" class="headerlink" title="剑指offer29题"></a>剑指offer29题</h4><p>这道题可以先对数组做一次partition，判断返回的数是否正好在n/2位置，则这个数就是我们要找的数；如果返回的数在大于n/2，则中位数在这个数的左边；如果返回的数在小于n/2，则中位数在这个数的右边。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moreThanHalfNum</span>(<span class="params">list, length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> end = list.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((start + end)/<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> index = partition(list, length, start, end);</span><br><span class="line">  <span class="keyword">while</span>(index !== mid)&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; mid) &#123;</span><br><span class="line">      end = index - <span class="number">1</span>;</span><br><span class="line">      index = partition(list, length, start, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = index + <span class="number">1</span>;</span><br><span class="line">      index = partition(list, length, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = list[mid];</span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剑指offer30题"><a href="#剑指offer30题" class="headerlink" title="剑指offer30题"></a>剑指offer30题</h4><p>再比如在剑指offer的面试题30：最小的k个数，也用到了partition。因为在partition中，将小于选定数的数都放在选定数的前面，大于选定数的数都放在选定数的后面，因此这道题要找出最小的k个数，只需要找到partition的返回值index===k-1即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeastNumbers</span>(<span class="params">list,k</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> end = list.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> result=[];</span><br><span class="line">  <span class="keyword">var</span> index = partition(list, length, start, end);</span><br><span class="line">  <span class="keyword">while</span>(index !== k - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>)&#123;</span><br><span class="line">      end = index - <span class="number">1</span>;</span><br><span class="line">      index = partition(list, length, start, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = index + <span class="number">1</span>;</span><br><span class="line">      index = partition(list, length, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">    result.push(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快速排序的时间复杂度为O(N*logN)。&lt;/p&gt;
&lt;h3 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算法思路&quot;&gt;&lt;/a&gt;算法思路&lt;/h3&gt;&lt;p&gt;在快速排序中需要有一个Partition函数，这个方法是在数组中选
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 transition</title>
    <link href="http://yoursite.com/2017/10/27/transition/"/>
    <id>http://yoursite.com/2017/10/27/transition/</id>
    <published>2017-10-27T12:42:21.000Z</published>
    <updated>2018-02-26T15:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>transition是过渡的意思，可想而知transition属性让元素的一个或一些属性值随着时间的推移从旧状态向新动态过渡。</p><h3 id="1、transition的子属性"><a href="#1、transition的子属性" class="headerlink" title="1、transition的子属性"></a>1、transition的子属性</h3><p>transition有一些子属性来定义元素属性的过渡细节。<br>transition-property属性指定应用了过渡的CSS属性，并不是所有属性都能过渡，在第二节中会详细介绍。除了指定单个属性，还可以设为all。<br>transition-duration属性指定了过渡过程的时长。<br>transition-timing-function属性描述如何计算在过渡过程中使用的中间值。它允许在其持续时间内改变速度。这些效应通常称为缓和函数，有linear，ease，ease-in，ease-out，ease-in-out，cubic-bezier(n,n,n,n)，steps。其实它们都是贝赛尔曲线。如下图所示。</p><p><img src="5-1.png" alt=""></p><p>看贝赛尔曲线就知道了，linear是匀速过渡，ease是先快再慢的节奏，ease-in是加速冲刺的节奏，ease-out是减速到停止的节奏，ease-in-out是先加速后减速的节奏。<br>transition-delay属性定义过渡经过一段延迟时间后开始。<br>对于缩写的transition可以包含上面的四项：</p><p><code>&lt;single-transition&gt; = [ none | &lt;single-transition-property&gt; ] || &lt;time&gt; || &lt;single-transition-timing-function&gt; || &lt;time&gt;</code></p><p>||代表各部分至少出现一个，可以不按顺序；[ ]强调优先级，即transition-property要放在第一位。有两个time第一个设置的time代表transition-duration，第二个设置的time代表transition-delay。</p><h3 id="2、可以transition的属性"><a href="#2、可以transition的属性" class="headerlink" title="2、可以transition的属性"></a>2、可以transition的属性</h3><p>在transition中，transition-property指定CSS过渡属性。并不是所有属性都能过渡的，只有能数字量化的CSS属性才能过渡。哪些属于能数字量化的CSS属性呢？例如：<br>颜色系：color，background-color，border-color，outline-color等<br>数字系：实在太多了，如width，height，top，right，bottom，left，zoom，opacity，line-height，background-position，word-spacing，font-weight，vertical-align，outline-outset，z-index等。<br>01系：如visibility（0表示隐藏，1表示显示）。</p><p><a href="https://www.w3.org/TR/css3-transitions/#animatable-css" target="_blank" rel="noopener">W3C</a>上有可过渡属性一览表Properties from CSS。通常只要能设数字（包括百分比）的属性都能过渡。</p><h3 id="3、transition触发"><a href="#3、transition触发" class="headerlink" title="3、transition触发"></a>3、transition触发</h3><p>那么transition是何时触发的？transition用于定义一个元素在两个状态之间的过渡：css伪类比如:hover、:active可以标识两个状态，在元素上定义transition属性和transition-property指定的属性，然后在元素:hover上改变transition-property指定属性的状态;或者动态的使用js来改变该元素应用了过渡的属性；还有例如@media媒体查询，根据设备大小，横屏竖屏切换时触发。<br>比如mdn上的一个例子，使用:hover来触发过渡：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0000FF</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, </span><br><span class="line">        background-color <span class="number">2s</span>, -webkit-transform <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">transition</span>:width <span class="number">2s</span>, height <span class="number">2s</span>, background-color <span class="number">2s</span>, transform <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FFCCCC</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">rotate</span>(180deg);</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者改成使用js改变元素属性，html代码和上面一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0000FF</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>, background-color <span class="number">2s</span>, -webkit-transform <span class="number">2s</span>, display <span class="number">2s</span>;</span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">2s</span>, height <span class="number">2s</span>, background-color <span class="number">2s</span>, transform <span class="number">2s</span>, display <span class="number">2s</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"box"</span>)[<span class="number">0</span>];</span><br><span class="line">    setTimeout(transition, <span class="number">2000</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        box.style.backgroundColor = <span class="string">"#FFCCCC"</span>;</span><br><span class="line">        box.style.width = <span class="string">"200px"</span>;</span><br><span class="line">        box.style.height = <span class="string">"200px"</span>;</span><br><span class="line">        box.style.transform = <span class="string">"rotate(180deg)"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="4、transitionend事件"><a href="#4、transitionend事件" class="headerlink" title="4、transitionend事件"></a>4、transitionend事件</h3><p>当过渡结束会触发transitionend事件。但如果一个transition在完成之前就被移除（定义transition属性的元素被删除，比如transition的过渡属性display从block到none），那么transitionend事件不会被触发。<br>比如对上面第二个例子进行改进，监听transitionend事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"box"</span>)[<span class="number">0</span>];</span><br><span class="line">    setTimeout(transition, <span class="number">2000</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        box.style.backgroundColor = <span class="string">"#FFCCCC"</span>;</span><br><span class="line">        box.style.width = <span class="string">"200px"</span>;</span><br><span class="line">        box.style.height = <span class="string">"200px"</span>;</span><br><span class="line">        box.style.transform = <span class="string">"rotate(180deg)"</span>;</span><br><span class="line">        box.style.display = <span class="string">"none"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    box.addEventListener(<span class="string">"transitionend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'transitionend'</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>会发现，对display属性进行由block到none的过渡就不会触发transitionend事件。<br>当删除display过渡属性，保留背景颜色、宽、高和transform这四个过渡属性，就会触发transitionend事件四次。<br>如果过渡属性指定的是padding，即同时过渡padding-left\top\right\bottom这四个属性，transitionend事件会触发四次。因此例如padding，margin，border之类的属性，用transitionend事件会有多次捕获的情况发生。</p><h3 id="5、auto过渡"><a href="#5、auto过渡" class="headerlink" title="5、auto过渡"></a>5、auto过渡</h3><p>通常我们属性过渡时，都是定值到定值的过渡，例如width:100px过渡到200px。但要过渡到width:auto就不行了。就算你指定transition:<br>width 1s;会发现不会有1秒的过渡效果，而是会瞬间完成过渡。<br>可以将width瞬间置为auto，使用window.getComputedStyle()获得当前width的数值，然后将width置回100px。再用事件触发改变width。<br>可以看到过渡过程，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> box = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"box"</span>)[<span class="number">0</span>];</span><br><span class="line">    box.style.width = <span class="string">"auto"</span>;</span><br><span class="line">    <span class="keyword">let</span> auto_width = <span class="built_in">window</span>.getComputedStyle(box, <span class="literal">null</span>).getPropertyValue(<span class="string">"width"</span>);</span><br><span class="line">    box.style.width = <span class="string">"200px"</span>;</span><br><span class="line">    setTimeout(transition, <span class="number">2000</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        box.style.width = auto_width;</span><br><span class="line">    &#125;;</span><br><span class="line">    box.addEventListener(<span class="string">"transitionend"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'transitionend'</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://www.jianshu.com/p/56f8ddafc63f" target="_blank" rel="noopener">CSS3 transition介绍</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions" target="_blank" rel="noopener">CSS3 transition MDN</a><br><a href="https://www.w3.org/TR/css3-transitions/" target="_blank" rel="noopener">CSS3 transition W3C</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;transition是过渡的意思，可想而知transition属性让元素的一个或一些属性值随着时间的推移从旧状态向新动态过渡。&lt;/p&gt;
&lt;h3 id=&quot;1、transition的子属性&quot;&gt;&lt;a href=&quot;#1、transition的子属性&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除二叉搜索树的节点</title>
    <link href="http://yoursite.com/2017/10/11/%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2017/10/11/删除二叉搜索树的节点/</id>
    <published>2017-10-11T07:43:54.000Z</published>
    <updated>2018-02-26T15:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一下删除二叉搜索树节点的迭代和递归方法。</p><h3 id="1、二叉搜索树"><a href="#1、二叉搜索树" class="headerlink" title="1、二叉搜索树"></a>1、二叉搜索树</h3><p>二叉搜索树的重要性质：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉搜索树；</p><h3 id="2、删除二叉搜索树的节点"><a href="#2、删除二叉搜索树的节点" class="headerlink" title="2、删除二叉搜索树的节点"></a>2、删除二叉搜索树的节点</h3><p>删除二叉搜索树的节点有三种情况。<br>（1）删除节点没有子节点；<br>（2）删除节点只有一个子节点；<br>（3）删除节点有两个子节点。<br>如下是一棵二叉搜索树：</p><p><img src="4-1.png" alt=""></p><p>第一种情况，比如删除节点4，只要把当前节点4直接删除即可。<br>第二种情况，比如删除节点5，只要把节点5的左子树挂到节点5的父节点上。<br>第三种情况，比如删除节点3，我们要在节点3的右子树中找到大于3的最小节点，在这儿是节点4。然后用找到的最小节点4赋值给节点3，最后再删掉节点4即可。<br>下面使用迭代和递归两种方法来解决问题。</p><h4 id="2-1、迭代"><a href="#2-1、迭代" class="headerlink" title="2.1、迭代"></a>2.1、迭代</h4><p>deleteNode函数主要找到删除节点的位置。其中node是要删除的节点，pre是删除节点的父节点。<br>del函数是删除节点函数。分为三种情况：<br>（1）要删除的节点没有子节点时，就返回null；<br>（2）要删除的该节点只有左子树或只有右子树时，就返回要删除节点的左子树或右子树；<br>（3）要删除节点有两个子节点时，就要将删除节点右子树中的最小值赋值给要删除节点，然后删去最小节点。这里还有两种情况要讨论，这部分代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pre = node;</span><br><span class="line"><span class="keyword">let</span> cur = node.right;</span><br><span class="line"><span class="keyword">while</span>(cur.left)&#123;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = cur.left;</span><br><span class="line">&#125;</span><br><span class="line">node.val = cur.val;</span><br><span class="line"><span class="built_in">console</span>.log(pre.left);</span><br><span class="line">pre === node ? pre.right = cur.right : pre.left = cur.right;</span><br></pre></td></tr></table></figure><p>这段代码中cur是找到的最小节点，node是要删除节点，pre是最小节点的父节点。因为最后要删去cur所以，还是需要记录它的父节点pre。<br>如果是删除下图中的根节点6，此时pre===node。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre===node)&#123;</span><br><span class="line">    pre.right=cur.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="4-2.png" alt=""></p><p>如果是删除下图中的节点3，那么pre是节点5。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pre !== node)&#123;</span><br><span class="line">    pre.left = cur.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="4-3.png" alt=""></p><p>完整代码和注释如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">root, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node=root;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//找到要删除节点node</span></span><br><span class="line">    <span class="keyword">while</span>(node!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.val===key)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=node;</span><br><span class="line">        <span class="keyword">if</span>(node.val&gt;key)&#123;</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node=node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到删除节点的情况</span></span><br><span class="line">    <span class="keyword">if</span>(node===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pre是当前节点的父节点，这个是删除头结点的情况</span></span><br><span class="line">    <span class="keyword">if</span>(pre===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> del(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除pre的左节点或者右节点</span></span><br><span class="line">    <span class="keyword">if</span>(pre.left&amp;&amp;pre.left.val===key)&#123;</span><br><span class="line">        pre.left=del(node);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pre.right&amp;&amp;pre.right.val===key)&#123;</span><br><span class="line">        pre.right=del(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当要删除的该节点没有左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(node.left===<span class="literal">null</span>&amp;&amp;node.right===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当要删除的该节点只有左子树或只有右子树</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left || !node.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> (node.left) ? node.left : node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右子树都有</span></span><br><span class="line">    <span class="keyword">let</span> pre=node;</span><br><span class="line">    <span class="keyword">let</span> cur=node.right;</span><br><span class="line">    <span class="keyword">while</span>(cur.left)&#123;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    node.val=cur.val;</span><br><span class="line">    <span class="built_in">console</span>.log(pre.left);</span><br><span class="line">    pre===node?pre.right=cur.right:pre.left=cur.right;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、递归"><a href="#2-2、递归" class="headerlink" title="2.2、递归"></a>2.2、递归</h4><p>先判断根节点是否为空；<br>然后开始寻找二叉搜索树中key的位置，如果当前节点的值比key大则去找当前节点的左子树，小则找右子树，直到找到与key值相同的节点；<br>接着判断节点子树的个数，分为节点至多只有一个子树，和有两个子树这两种情况；<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">root, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">        root.left=deleteNode(root.left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">        root.right = deleteNode(root.right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到key的位置root，当root至多只有一个子树</span></span><br><span class="line">        <span class="keyword">if</span>(!root.left||!root.right)&#123;</span><br><span class="line">            root=root.left?root.left:root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> cur=root.right;</span><br><span class="line">            <span class="keyword">while</span>(cur.left)&#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root.val=cur.val;</span><br><span class="line">            root.right=deleteNode(root.right,cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结了一下删除二叉搜索树节点的迭代和递归方法。&lt;/p&gt;
&lt;h3 id=&quot;1、二叉搜索树&quot;&gt;&lt;a href=&quot;#1、二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;1、二叉搜索树&quot;&gt;&lt;/a&gt;1、二叉搜索树&lt;/h3&gt;&lt;p&gt;二叉搜索树的重要性质：&lt;br&gt;（1）若
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的广度和深度优先遍历（先序、中序、后序）</title>
    <link href="http://yoursite.com/2017/10/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2017/10/04/二叉树的广度和深度优先遍历（先序、中序、后序）/</id>
    <published>2017-10-04T07:45:11.000Z</published>
    <updated>2018-02-26T15:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了一下二叉树的广度优先遍历、深度优先遍历的递归和非递归实现方式。</p><p>二叉树的遍历方式：</p><p>1、广度优先<br>按照树的深度，一层一层的访问树的节点</p><p>2、深度优先：<br>　　1)先序遍历：先访问根节点，再依次访问左子树和右子树<br>　　2)中序遍历：先访问左子树，再访问根节点吗，最后访问右子树<br>　　3)后序遍历：先访问左子树，再访问右子树，最后访问根节点</p><h3 id="1、广度优先遍历"><a href="#1、广度优先遍历" class="headerlink" title="1、广度优先遍历"></a>1、广度优先遍历</h3><p><img src="3-1.png" alt=""></p><p>图1是一个二叉树，使用广度优先遍历的顺序应该是1、2、3、4、5、6。<br>思路是定义一个队列，先将root节点push进去作为初始值，并计算当前层所包含的节点数，root层就为1，将root从列表最前面弹出，然后访问root的left和right，将访问到的节点存入列表中。此时root层遍历结束，列表中存储的是下一层的所有节点，计算当前层所包含的节点数，然后从列表中依次弹出当前层的每个节点，并且访问每个节点的left和right节点，再存入列表中。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BFS = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a=[];</span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a.push(root);</span><br><span class="line">    <span class="keyword">let</span> count;</span><br><span class="line">    <span class="keyword">while</span>(a.length!==<span class="number">0</span>)&#123;</span><br><span class="line">        count=a.length;</span><br><span class="line">        <span class="keyword">while</span>(count)&#123;</span><br><span class="line">            tmp=a.shift();</span><br><span class="line">            <span class="keyword">if</span>(tmp.left!==<span class="literal">null</span>)&#123;a.push(tmp.left);&#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.right!==<span class="literal">null</span>)&#123;a.push(tmp.right);&#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、深度优先遍历"><a href="#2、深度优先遍历" class="headerlink" title="2、深度优先遍历"></a>2、深度优先遍历</h3><p>深度优先遍历分为先序遍历、中序遍历和后序遍历。下面每种遍历方式都会使用递归和迭代两种方法。</p><h4 id="2-1-先序遍历"><a href="#2-1-先序遍历" class="headerlink" title="2.1 先序遍历"></a>2.1 先序遍历</h4><p>图1的二叉树使用深度优先遍历的结果是1、2、4、5、3、6。<br>迭代的思路是定义一个栈，先将root节点push进去作为初始值，检测栈是否为空，不为空，则弹出最上面的元素将其输出，然后如果该元素有左右节点则，先将右节点入栈，再将左节点入栈。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DFS= <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">if</span>(root!==<span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(root)</span><br><span class="line">        <span class="keyword">while</span>(stack.length!==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> top = stack.pop();</span><br><span class="line">            <span class="built_in">console</span>.log(top.val);</span><br><span class="line">            <span class="keyword">if</span>(top.right!==<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top.left!==<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DFS = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!==<span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(root.val);</span><br><span class="line">        DFS (root.left);</span><br><span class="line">        DFS (root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h4><p>图1的二叉树使用中序遍历的结果是4、2、5、1、3、6。<br>迭代的思路是定义一个栈，先将当前节点的所有左侧子结点压入栈。然后再访问该节点和它的右子树。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DFS = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!==<span class="literal">null</span>)&#123;</span><br><span class="line">        DFS (root.left);</span><br><span class="line">        <span class="built_in">console</span>.log(root.val);</span><br><span class="line">        DFS (root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h4><p>图1的二叉树使用后序遍历的结果是4、5、2、6、3、1。<br>迭代思路是定义一个栈，先将当前节点的所有左侧子结点压入栈，现在要保证在访问当前节点的右子结点之后才能访问当前节点。所以每次从栈中拿出左侧节点时，都需要判断该节点的右子树是否存在或右子树是否被访问过，这里使用了一个preNode来记录刚被访问过的节点，这样就可以实现只有当前节点的右子结点访问完成，才能访问当前节点。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DFS = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[];</span><br><span class="line">    <span class="keyword">let</span> node=root;</span><br><span class="line">    <span class="keyword">let</span> preNode=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(node!==<span class="literal">null</span>||stack.length!==<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="comment">//所有左侧子结点压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(node!==<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.length!==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = stack[stack.length<span class="number">-1</span>].right;</span><br><span class="line">            <span class="comment">// 一个根节点被访问的前提是：无右子树或右子树已被访问过</span></span><br><span class="line">            <span class="keyword">if</span>(tmp===<span class="literal">null</span>||tmp===preNode)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                <span class="built_in">console</span>.log(node.val);</span><br><span class="line">                <span class="comment">// 记录刚被访问过的节点</span></span><br><span class="line">                preNode=node;</span><br><span class="line">                node=<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 处理右子树</span></span><br><span class="line">                node=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DFS = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!==<span class="literal">null</span>)&#123;</span><br><span class="line">        DFS (root.left);</span><br><span class="line">        DFS (root.right);</span><br><span class="line">        <span class="built_in">console</span>.log(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结了一下二叉树的广度优先遍历、深度优先遍历的递归和非递归实现方式。&lt;/p&gt;
&lt;p&gt;二叉树的遍历方式：&lt;/p&gt;
&lt;p&gt;1、广度优先&lt;br&gt;按照树的深度，一层一层的访问树的节点&lt;/p&gt;
&lt;p&gt;2、深度优先：&lt;br&gt;　　1)先序遍历：先访问根节点，再依次访问左子树和右子树&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css布局</title>
    <link href="http://yoursite.com/2017/09/24/css%E5%B8%83%E5%B1%80%E4%B9%8B%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%92%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2017/09/24/css布局之双飞翼和圣杯布局/</id>
    <published>2017-09-24T06:23:18.000Z</published>
    <updated>2018-02-27T03:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、float-amp-clear"><a href="#1、float-amp-clear" class="headerlink" title="1、float&amp;clear"></a>1、float&amp;clear</h3><p>clear属性一般是在清除浮动元素中设置，下面以clear：left为例。<br>当浮动元素先于清除浮动元素，且清除浮动元素设置为clear：left，则浮动元素不允许在清除浮动元素的左侧出现，所以清除浮动元素必须移到浮动元素的下面。(清除浮动元素可能是浮动元素也可能不是)</p><h3 id="2、双飞翼布局-amp-圣杯布局"><a href="#2、双飞翼布局-amp-圣杯布局" class="headerlink" title="2、双飞翼布局&amp;圣杯布局"></a>2、双飞翼布局&amp;圣杯布局</h3><p>圣杯布局的来历是2006年发在a list part上的这篇文章：In Search of the Holy Grail · An A List Apart Article。圣杯是西方表达“渴求之物”的意思，不是一种对页面的形象表达。双飞翼据考源自淘宝UED，应该是一种页面的形象的表达。<br>圣杯布局和双飞翼布局解决的问题是一样的，就是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。<br>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。<br>不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：<br>双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。<br>圣杯布局，为了中间div内容不被遮挡，在外部container设置左右padding，再对左右栏进行相对定位，拉到两边。<br>感觉比圣杯布局思路更直接和简洁一点。简单说起来就是”双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了“。来源：<a href="https://www.zhihu.com/question/21504052/answer/50053054" target="_blank" rel="noopener">知乎</a></p><h3 id="3、双飞翼布局"><a href="#3、双飞翼布局" class="headerlink" title="3、双飞翼布局"></a>3、双飞翼布局</h3><p>html代码如下，可以看到中间div要在放在文档流前面以优先渲染，而且为了中间div内容不被遮挡，在中间div内创建一个子div用于存放内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-wrap"</span>&gt;</span></span><br><span class="line">            我是主列，出来吧！</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>我是子列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>我是附加列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span> <span class="attr">id</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双飞翼 */</span></span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F08383</span>; <span class="comment">/*粉色*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> <span class="selector-class">.main-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">90px</span>;  <span class="comment">/*与col-sub产生10像素距离*/</span></span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">90px</span>; <span class="comment">/*与col-extra产生10像素距离*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#a9a9a9</span>; <span class="comment">/*灰色*/</span></span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">80px</span>; </span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(38, 170, 12);<span class="comment">/*绿色*/</span></span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">80px</span>; </span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(231, 188, 47);<span class="comment">/*黄色*/</span></span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">80px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到三栏全部float，中间宽度100%，两边通过margin-left负值移动到指定位置，左栏设置margin-left:-100%将其移动到中间栏的最左位置，右栏通过margin-left:-80px移动自身宽度的位置到中间栏的最右位置。<br>如果将代码中#center .main-wrap注释掉，则结果如图所示：</p><p><img src="cssbuju1.png" alt=""></p><p>此时中间div被左边div挡住，所以添加子div的目的是设置margin-left和margin-right使其与左右栏保持距离。<br>最终结果如图所示：</p><p><img src="cssbuju2.png" alt=""></p><h3 id="4、圣杯布局"><a href="#4、圣杯布局" class="headerlink" title="4、圣杯布局"></a>4、圣杯布局</h3><p>html代码如下，可以看到与双飞翼的差别在于没有在中间div设置子div元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        我是主列，出来吧！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>我是左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>我是右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span> <span class="attr">id</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>:<span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>:<span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F08383</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">float</span>:left; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">80px</span>; </span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(38, 170, 12);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">float</span>:left; </span><br><span class="line">    <span class="attribute">width</span>:<span class="number">80px</span>; </span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">right</span>:-<span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(231, 188, 47);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在解决”中间栏div内容不被遮挡“问题上，圣杯使用的是在container上设置左右padding，此时左右栏会和中间栏一起被拉回来，所以就对left使用相对定位 left:-80px 同理，right也要相对定位还原 right:-80px。</p><p><img src="cssbuju3.png" alt=""></p><h3 id="4、普通的三栏布局"><a href="#4、普通的三栏布局" class="headerlink" title="4、普通的三栏布局"></a>4、普通的三栏布局</h3><p>这里所讲的三栏布局是两边定宽，中间自适应的三栏布局，中间栏不需要在放在文档流前面的情况，这种情况很简单，代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(38, 170, 12);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(231, 188, 47);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F08383</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、使用float-BFC实现三栏布局"><a href="#5、使用float-BFC实现三栏布局" class="headerlink" title="5、使用float+BFC实现三栏布局"></a>5、使用float+BFC实现三栏布局</h3><p>在BFC中有一个特性：</p><blockquote><p>BFC的区域不会与float box重叠。</p></blockquote><p>利用这个特性，不需要左右定宽，也能实现三栏布局，代码如下所示，可以看到center中设置了<code>overflow: hidden;</code>，使center成为了一个BFC容器。</p><p>详细的原理张鑫旭在<a href="http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/" target="_blank" rel="noopener">CSS深入理解流体特性和BFC特性下多栏自适应布局</a>中有深刻的讨论。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(38, 170, 12);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(231, 188, 47);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>:<span class="number">30px</span>; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F08383</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、float-amp-clear&quot;&gt;&lt;a href=&quot;#1、float-amp-clear&quot; class=&quot;headerlink&quot; title=&quot;1、float&amp;amp;clear&quot;&gt;&lt;/a&gt;1、float&amp;amp;clear&lt;/h3&gt;&lt;p&gt;clear属性一般是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UI组件之浮出层</title>
    <link href="http://yoursite.com/2017/09/21/UI%E7%BB%84%E4%BB%B6%E4%B9%8B%E6%B5%AE%E5%87%BA%E5%B1%82/"/>
    <id>http://yoursite.com/2017/09/21/UI组件之浮出层/</id>
    <published>2017-09-21T14:25:59.000Z</published>
    <updated>2018-01-31T15:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>UI组件之浮出层</p><p>这是2017年百度前端学院的一道题，要求做出一个如图所示的浮出层。</p><p><img src="UI1.png" alt=""></p><p>以下是浮出层的html代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span>&gt;</span>&amp;times;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"modal-title"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"resizable-handle e-resize"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"resizable-handle n-resize"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"resizable-handle w-resize"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"resizable-handle s-resize"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对外提供了一些可以用来定制浮出层的选项。选项表如下：</p><table><thead><tr><th style="text-align:center">选项名称</th><th style="text-align:center">选项默认值</th><th style="text-align:center">选项描述</th></tr></thead><tbody><tr><td style="text-align:center">size</td><td style="text-align:center">size:{ width: ‘600px’, height: ‘138px’}</td><td style="text-align:center">允许自定义浮出层的宽高。</td></tr><tr><td style="text-align:center">resizeable</td><td style="text-align:center">resizeable: true</td><td style="text-align:center">允许通过拖拽浮出层的一边来改变大小</td></tr><tr><td style="text-align:center">dragable</td><td style="text-align:center">dragable: true</td><td style="text-align:center">允许通过拖拽来改变浮出层的位置</td></tr><tr><td style="text-align:center">keyboard</td><td style="text-align:center">keyboard: true</td><td style="text-align:center">当按下 escape 键时关闭浮出层，设置为 false 时则按键无效。</td></tr><tr><td style="text-align:center">backdrop</td><td style="text-align:center">backdrop: true</td><td style="text-align:center">指定一个静态的背景，当用户点击模态框外部时不会关闭模态框。</td></tr><tr><td style="text-align:center">open</td><td style="text-align:center">open: null</td><td style="text-align:center">指定打开浮出层时的回调函数。</td></tr><tr><td style="text-align:center">beforeClose</td><td style="text-align:center">beforeClose: null</td><td style="text-align:center">指定关闭浮出层之前的回调函数。</td></tr><tr><td style="text-align:center">close</td><td style="text-align:center">close: null</td><td style="text-align:center">指定关闭浮出层的回调函数。</td></tr></tbody></table><p>除了这八个选项，还提供了show和hide两个方法。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">show</td><td style="text-align:center">打开弹出层</td><td style="text-align:center">let modal=new ModalFunc(options); modal.show();</td></tr><tr><td style="text-align:center">hide</td><td style="text-align:center">关闭弹出层</td><td style="text-align:center">let modal=new ModalFunc(options); modal.hide();</td></tr></tbody></table><p>接下来聊一聊我在实现过程中遇到的问题和收获。</p><h3 id="1、创建自定义类型"><a href="#1、创建自定义类型" class="headerlink" title="1、创建自定义类型"></a>1、创建自定义类型</h3><p>在这里创建了一个ModalFunc的自定义类型，采用的方式是组合使用构造函数与原型模式。基本代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ModalFunc = <span class="function"><span class="keyword">function</span>(<span class="params">elem, opts</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = elem;</span><br><span class="line">    <span class="keyword">this</span>.options = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">ModalFunc.prototype = &#123;</span><br><span class="line">    setConfig: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;，</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    hide:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。</p><h3 id="2、提供定制浮出层的选项"><a href="#2、提供定制浮出层的选项" class="headerlink" title="2、提供定制浮出层的选项"></a>2、提供定制浮出层的选项</h3><p>在ModalFunc构造函数中初始化options属性，options的值来源于用户定义或默认值。<br>如下是在ModalFunc构造函数中初始化options属性的代码。_default_options是options的默认值，opts是用户定义的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义options默认值</span></span><br><span class="line"><span class="keyword">const</span> _default_options = &#123;</span><br><span class="line">    size:&#123;</span><br><span class="line">        width: <span class="string">'600px'</span>,</span><br><span class="line">        height: <span class="string">'138px'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resizeable: <span class="literal">true</span>,</span><br><span class="line">    dragable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//当按下 escape 键时关闭浮出层，设置为 false 时则按键无效。</span></span><br><span class="line">    keyboard: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//当用户点击浮出层外部是否会关闭浮出层。</span></span><br><span class="line">    backdrop: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// open回调</span></span><br><span class="line">    open: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// close回调</span></span><br><span class="line">    close: <span class="literal">null</span>,</span><br><span class="line">    beforeClose: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.options = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (opts === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = _default_options;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> _default_options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options[key] = opts[key]!==<span class="literal">null</span> ? opts[key] : _default_options[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户是在使用浮出层的页面中new一个ModalFunc的对象，并且传入element和options两个参数。如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> modal=<span class="keyword">new</span> ModalFunc(myModal,&#123;</span><br><span class="line">    size:&#123;</span><br><span class="line">        width:<span class="string">"500px"</span>,</span><br><span class="line">        height:<span class="string">'138px'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    keyboard:<span class="literal">true</span>,</span><br><span class="line">    resizeable: <span class="literal">true</span>,</span><br><span class="line">    dragable: <span class="literal">true</span>,</span><br><span class="line">    backdrop:<span class="literal">true</span>,</span><br><span class="line">    open: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'浮出层打开'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeClose: <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (confirm(<span class="string">'before close'</span>)) &#123;</span><br><span class="line">            done();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'close failed by before close callback.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    close: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'浮出层关闭'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3、实现keyboard选项"><a href="#3、实现keyboard选项" class="headerlink" title="3、实现keyboard选项"></a>3、实现keyboard选项</h3><p>keyboard选项控制当按下 escape 键时关闭浮出层，当设置为 false 则按键无效。<br>这里我遇上的问题是如何在不人为调整焦点的情况下，当浮出层弹出，焦点自动处于其上。<br>解决方法是在使用show方法打开浮出层的时候，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.element.setAttribute(<span class="string">'tabindex'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.element.focus();</span><br></pre></td></tr></table></figure><p>this.element是指modal元素。这样当打开浮出层，焦点就在浮出层上。</p><h3 id="4、实现backdrop选项"><a href="#4、实现backdrop选项" class="headerlink" title="4、实现backdrop选项"></a>4、实现backdrop选项</h3><p>backdrop选项控制用户点击浮出层外部时是否关闭浮出层。当设置true则关闭。<br>这里我遇上的问题是如何实现点击阴影背景可关闭，但点击弹框不可关闭。<br>解决方法是在modal-dialog元素上设置event.stopPropagation();从而阻止冒泡进一步传播到modal元素上。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.options.backdrop)&#123;</span><br><span class="line">    <span class="keyword">const</span> dialog = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"modal-dialog"</span>);        </span><br><span class="line">    dialog[<span class="number">0</span>].addEventListener(<span class="string">"click"</span>,(event)=&gt;&#123;</span><br><span class="line">        event.stopPropagation();</span><br><span class="line">    &#125;,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.element.addEventListener(<span class="string">"click"</span>,(e)=&gt;&#123;</span><br><span class="line">        <span class="keyword">this</span>.hide();</span><br><span class="line">    &#125;,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、实现dragable选项"><a href="#5、实现dragable选项" class="headerlink" title="5、实现dragable选项"></a>5、实现dragable选项</h3><p>插件中的dragable选项控制浮出层是否可以拖拽。想要实现的效果是用鼠标点击浮出层然后在页面内拖动，最终放开鼠标，浮出层就处于放开最后一刻的位置。<br>在写浮出层的拖拽时，modal-dialog需要定位浮出层在drag过程中的位置，这里使用绝对定位。top和left设置为0，然后使用js使浮出层居中。<br>这里使用了html5原生的drag和drop事件。<br>制作可拖动对象非常简单。在要设为可移动的元素上设置 draggable=”true” 属性，再设置dragstart事件监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.element.addEventListener(<span class="string">'dragstart'</span>,(event) =&gt; &#123;</span><br><span class="line">    dragOffset.x = event.offsetX;</span><br><span class="line">    dragOffset.y = event.offsetY;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在drag事件中只要计算出模态框left和top的值，就能进行定位，代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.element.addEventListener(<span class="string">'drag'</span>,(event) =&gt; &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">if</span>(event.clientX - dragOffset.x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        dialog[<span class="number">0</span>].style.left = <span class="string">'0px'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.clientY - dragOffset.y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        dialog[<span class="number">0</span>].style.top = <span class="string">'0px'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dialog[<span class="number">0</span>].style.left = (event.clientX - dragOffset.x ) + <span class="string">'px'</span>;</span><br><span class="line">        dialog[<span class="number">0</span>].style.top = (event.clientY - dragOffset.y ) + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在drag事件中有一些和位置有关的属性可以帮助定位：event.clientX和event.clientY，这两个值是当前鼠标焦点到页面最左上角，两个坐标之间的X和Y。除了这两个值，我们还需要鼠标焦点到对话框最左上角的距离，这个值可以通过dragstart事件event.offsetX和event.offsetY获取。如图所示：</p><p><img src="UI2.png" alt=""></p><p>在dragenter和dragover事件期间调用preventDefault（）方法将指示在该位置允许放置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.element.addEventListener(<span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// prevent default to allow drop</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>但是令我困惑的是，未定义dragend事件，浮出层依然可以被放置到正确位置。</p><h3 id="6、实现resizeable选项"><a href="#6、实现resizeable选项" class="headerlink" title="6、实现resizeable选项"></a>6、实现resizeable选项</h3><p>插件中的resizeable选项实现了横向或纵向拖动浮出层的边框可以改变浮出层的宽度或高度。<br>实现参考了jquery-ui的缩放功能。<br>在浮出层的html结构上加了四条透明边框线（为了显示效果加了颜色），如图：</p><p><img src="UI3.png" alt=""></p><p>然后分别对这四条边进行drag&amp;drop事件监听。<br>下面以左边为例，只要计算出当前模态框宽度、left和top值就可以实现左边的拖拽。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">w_resize[<span class="number">0</span>].addEventListener(<span class="string">'dragstart'</span>,(event) =&gt; &#123;</span><br><span class="line">    dialogWidth = <span class="built_in">parseInt</span>(dialogContent[<span class="number">0</span>].style.width);</span><br><span class="line">    clientX = event.clientX;</span><br><span class="line">    dragOffset.x = event.offsetX;</span><br><span class="line">    dragOffset.y = event.offsetY;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">w_resize[<span class="number">0</span>].addEventListener(<span class="string">'drag'</span>,(event) =&gt; &#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    dialogContent[<span class="number">0</span>].style.width = (dialogWidth - (event.clientX - clientX)) + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">if</span>(event.clientX - dragOffset.x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        dialog[<span class="number">0</span>].style.left = <span class="string">'0px'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.clientY - dragOffset.y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        dialog[<span class="number">0</span>].style.top = <span class="string">'0px'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dialog[<span class="number">0</span>].style.left = (event.clientX - dragOffset.x ) + <span class="string">'px'</span>;</span><br><span class="line">        dialog[<span class="number">0</span>].style.top = (event.clientY - dragOffset.y ) + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">w_resize[<span class="number">0</span>].addEventListener(<span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// prevent default to allow drop</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UI组件之浮出层&lt;/p&gt;
&lt;p&gt;这是2017年百度前端学院的一道题，要求做出一个如图所示的浮出层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;UI1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下是浮出层的html代码。&lt;/p&gt;
&lt;figure class=&quot;highlight ht
      
    
    </summary>
    
    
  </entry>
  
</feed>
